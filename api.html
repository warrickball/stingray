<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Stingray API &#8212; stingray v</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-astropy.css?v=9d21690f" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=2afd17ea" />
    
    <script src="_static/jquery.js?v=5d32c60e"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <link rel="icon" href="_static/stingray_logo.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="History" href="history.html" />
    <link rel="prev" title="Gaussian Processes Inferencing in Stingray" href="notebooks/Modeling/GP_Modeling/GP_modeling_tutorial.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="genindex.html">Index</a></li>
    <li><a title="Module Index" href="py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li class="right">
	<a href="history.html" title="History">
	  next &raquo;
	</a>
      </li>
      <li class="right">
	<a href="notebooks/Modeling/GP_Modeling/GP_modeling_tutorial.html" title="Gaussian Processes Inferencing in Stingray">
	  &laquo; previous
	</a>
	 |
      </li>
      <li>
	<a href="index.html">stingray v</a>
	 &#187;
      </li>
      
      <li>Stingray API</li> 
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="stingray-api">
<span id="api"></span><h1>Stingray API<a class="headerlink" href="#stingray-api" title="Link to this heading">¶</a></h1>
<p>Library of Time Series Methods For Astronomical X-ray Data.</p>
<section id="base-class">
<h2>Base Class<a class="headerlink" href="#base-class" title="Link to this heading">¶</a></h2>
<p>Most <code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray`</span></code> classes are subclasses of a single class, <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.StingrayObject</span></code></a>, which
implements most of the I/O functionality and common behavior (e.g. strategies to combine data and
make operations such as the sum, difference, or negation). This class is not intended to be
instantiated directly, but rather to be used as a base class for other classes. Any class wanting
to inherit from <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.StingrayObject</span></code></a> should define a <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> attribute, which
defines the name of the attribute that will be used to store the “independent variable” main data array.
For example, for all time series-like objects, the main array is the time array, while for the
periodograms the main array is the frequency array.
All arrays sharing the length (not the shape: they might be multi-dimensional!) of the main array are called
“array attributes” and are accessible through the <code class="docutils literal notranslate"><span class="pre">array_attrs</span></code> method.
When applying a mask or any other selection to a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.StingrayObject</span></code></a>,
all array attributes are filtered in the same way. Some array-like attributes might have the same length
by chance, in this case the user or the developer should add these to the <code class="docutils literal notranslate"><span class="pre">not_array_attr</span></code> attribute.
For example, <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.StingrayTimeseries</span></code></a> has <code class="docutils literal notranslate"><span class="pre">gti</span></code> among the not_array_attrs, since it is an
array but not related 1-to-1 to the main array, even if in some cases it might happen to have the same numbers
of elements of the main array, which is <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
<section id="stingrayobject">
<h3>StingrayObject<a class="headerlink" href="#stingrayobject" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.StingrayObject">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">StingrayObject</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject" title="Link to this definition">¶</a></dt>
<dd><p>This base class defines some general-purpose utilities.</p>
<p>The main purpose is to have a consistent mechanism for:</p>
<ul class="simple">
<li><p>round-tripping to and from Astropy Tables and other dataframes</p></li>
<li><p>round-tripping to files in different formats</p></li>
</ul>
<p>The idea is that any object inheriting <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> should,
just by defining an attribute called <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>, be able to perform
the operations above, with no additional effort.</p>
<p><code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> is, e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> for <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> and
<a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a>, <code class="docutils literal notranslate"><span class="pre">freq</span></code> for <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a>, <code class="docutils literal notranslate"><span class="pre">energy</span></code> for
<code class="xref py py-class docutils literal notranslate"><span class="pre">VarEnergySpectrum</span></code>, and so on. It is the array with which all other
attributes are compared: if they are of the same shape, they get saved as
columns of the table/dataframe, otherwise as metadata.</p>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.add" title="Link to this definition">¶</a></dt>
<dd><p>Add two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances.</p>
<p>Add the array values of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming
the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.apply_mask">
<span class="sig-name descname"><span class="pre">apply_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">npt.ArrayLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtered_attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.apply_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.apply_mask" title="Link to this definition">¶</a></dt>
<dd><p>Apply a mask to all array attributes of the object</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>mask</strong><span class="classifier">array of <code class="docutils literal notranslate"><span class="pre">bool</span></code></span></dt><dd><p>The mask. Has to be of the same length as <code class="docutils literal notranslate"><span class="pre">self.time</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ts_new</strong><span class="classifier">StingrayObject object</span></dt><dd><p>The new object with the mask applied if <code class="docutils literal notranslate"><span class="pre">inplace</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, otherwise the
same object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current object. Otherwise, return a new one.</p>
</dd>
<dt><strong>filtered_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be filtered. Defaults to all array attributes if <code class="docutils literal notranslate"><span class="pre">None</span></code>.
The other array attributes will be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>. The main array attr is always
included.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.array_attrs">
<span class="sig-name descname"><span class="pre">array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.array_attrs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the array attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.data_attributes">
<span class="sig-name descname"><span class="pre">data_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.data_attributes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.data_attributes" title="Link to this definition">¶</a></dt>
<dd><p>Clean up the list of attributes, only giving out those pointing to data.</p>
<p>List all the attributes that point directly to valid data. This method goes through all the
attributes of the class, eliminating methods, properties, and attributes that are complicated
to serialize such as other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code>, or arrays of objects.</p>
<p>This function does not make difference between array-like data and scalar data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data_attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of attributes pointing to data that are not methods, properties,
or other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code> instances.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.dict">
<span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.dict" title="Link to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.from_astropy_table">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Table</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.from_astropy_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.from_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create a Stingray Object object from data in an Astropy Table.</p>
<p>The table MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.from_pandas">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">DataFrame</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.from_pandas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.from_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create an <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object from data in a pandas DataFrame.</p>
<p>The dataframe MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays can be
specified as <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_1d_arrays_into_nd</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.from_xarray">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_xarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dataset</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.from_xarray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.from_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> from data in an xarray Dataset.</p>
<p>The dataset MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.get_meta_dict">
<span class="sig-name descname"><span class="pre">get_meta_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.get_meta_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.get_meta_dict" title="Link to this definition">¶</a></dt>
<dd><p>Give a dictionary with all non-None meta attrs of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.internal_array_attrs">
<span class="sig-name descname"><span class="pre">internal_array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.internal_array_attrs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.internal_array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the internal array attributes of the Stingray Object.</p>
<p>These are array attributes that can be set by properties, and are generally indicated
by an underscore followed by the name of the property that links to it (E.g.
<code class="docutils literal notranslate"><span class="pre">_counts</span></code> in <code class="docutils literal notranslate"><span class="pre">Lightcurve</span></code>).
By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of internal array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.meta_attrs">
<span class="sig-name descname"><span class="pre">meta_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.meta_attrs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.meta_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the meta attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with a different size and shape
than <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of meta attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.pretty_print">
<span class="sig-name descname"><span class="pre">pretty_print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.pretty_print"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.pretty_print" title="Link to this definition">¶</a></dt>
<dd><p>Return a pretty-printed string representation of the object.</p>
<p>This is useful for debugging, and for interactive use.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func_to_apply</strong><span class="classifier">function</span></dt><dd><p>A function that modifies the attributes listed in <code class="docutils literal notranslate"><span class="pre">attrs_to_apply</span></code>.
It must return the modified attributes and a label to be printed.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no function is applied.</p>
</dd>
<dt><strong>attrs_to_apply</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be modified by <code class="docutils literal notranslate"><span class="pre">func_to_apply</span></code>.</p>
</dd>
<dt><strong>attrs_to_discard</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be discarded from the output.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.read">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.read" title="Link to this definition">¶</a></dt>
<dd><p>Generic reader for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>Files that need the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> interface MUST contain
at least a column named like the <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The default ascii format is enhanced CSV (ECSV). Data formats
supporting the serialization of metadata (such as ECSV and HDF5) can
contain all attributes such as <code class="docutils literal notranslate"><span class="pre">mission</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc with
no significant loss of information. Other file formats might lose part
of the metadata, so must be used with care.</p>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values should be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Path and file name for the file to be read.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>Available options are ‘pickle’, ‘hea’, and any <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code>-supported
format such as ‘hdf5’, ‘ascii.ecsv’, etc.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>obj: <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object</dt><dd><p>The object reconstructed from file</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.sub"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.sub" title="Link to this definition">¶</a></dt>
<dd><p>Subtract <em>all the array attrs</em> of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.to_astropy_table">
<span class="sig-name descname"><span class="pre">to_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">no_longdouble</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><span class="pre">Table</span></a></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.to_astropy_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.to_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create an Astropy Table from a <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code></p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">meta</span></code> dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>no_longdouble</strong><span class="classifier">bool</span></dt><dd><p>If True, reduce the precision of longdouble arrays to double precision.
This needs to be done in some cases, e.g. when the table is to be saved
in an architecture not supporting extended precision (e.g. ARM), but can
also be useful when an extended precision is not needed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.to_pandas">
<span class="sig-name descname"><span class="pre">to_pandas</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.to_pandas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.to_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays are
converted into columns before the conversion, with names <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_nd_into_arrays</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.to_xarray">
<span class="sig-name descname"><span class="pre">to_xarray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dataset</span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.to_xarray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.to_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create an <code class="docutils literal notranslate"><span class="pre">xarray</span></code> Dataset from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayObject.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayObject.write"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayObject.write" title="Link to this definition">¶</a></dt>
<dd><p>Generic writer for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values will be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Name and path of the file to save the object list to.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>The file format to store the data in.
Available options are <code class="docutils literal notranslate"><span class="pre">pickle</span></code>, <code class="docutils literal notranslate"><span class="pre">hdf5</span></code>, <code class="docutils literal notranslate"><span class="pre">ascii</span></code>, <code class="docutils literal notranslate"><span class="pre">fits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<hr class="docutils" />
<section id="data-classes">
<h2>Data Classes<a class="headerlink" href="#data-classes" title="Link to this heading">¶</a></h2>
<p>These classes define basic functionality related to common data types and typical methods
that apply to these data types, including basic read/write functionality. Currently
implemented are <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.StingrayTimeseries</span></code></a>, <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> and
<a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a>.</p>
<p>All time series-like data classes inherit from <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.StingrayTimeseries</span></code></a>, which
implements most of the common functionality. The main data array is stored in the <code class="docutils literal notranslate"><span class="pre">time</span></code>
attribute.
Good Time Intervals (GTIs) are stored in the <code class="docutils literal notranslate"><span class="pre">gti</span></code> attribute, which is a list of 2-tuples or 2-lists
containing the start and stop times of each GTI. The <code class="docutils literal notranslate"><span class="pre">gti</span></code> attribute is not an array attribute, since
it is not related 1-to-1 to the main array, even if in some cases it might happen to have the same number
of elements of the main array. It is by default added to the <code class="docutils literal notranslate"><span class="pre">not_array_attr</span></code> attribute.</p>
<section id="stingraytimeseries">
<h3>StingrayTimeseries<a class="headerlink" href="#stingraytimeseries" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">StingrayTimeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TTime</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mjdref</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TTime</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">npt.ArrayLike</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ephem</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeref</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timesys</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">other_kw</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries" title="Link to this definition">¶</a></dt>
<dd><p>Basic class for time series data.</p>
<p>This can be events, binned light curves, unevenly sampled light curves, etc. The only
requirement is that the data (which can be any quantity, related or not to an electromagnetic
measurement) are associated with a time measurement.
We make a distinction between the <em>array</em> attributes, which have the same length of the
<code class="docutils literal notranslate"><span class="pre">time</span></code> array, and the <em>meta</em> attributes, which can be scalars or arrays of different
size. The array attributes can be multidimensional (e.g. a spectrum for each time bin),
but their first dimension (<code class="docutils literal notranslate"><span class="pre">array.shape[0]</span></code>) must have same length of the <code class="docutils literal notranslate"><span class="pre">time</span></code> array.</p>
<p>Array attributes are singled out automatically depending on their shape. All filtering
operations (e.g. <code class="docutils literal notranslate"><span class="pre">apply_gtis</span></code>, <code class="docutils literal notranslate"><span class="pre">rebin</span></code>, etc.) are applied to array attributes only.
For this reason, it is advisable to specify whether a given attribute should <em>not</em> be
considered as an array attribute by adding it to the <code class="docutils literal notranslate"><span class="pre">not_array_attr</span></code> list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>time: iterable</strong></dt><dd><p>A list or array of time stamps</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>time: numpy.ndarray</strong></dt><dd><p>The array of time stamps, in seconds from the reference
MJD defined in <code class="docutils literal notranslate"><span class="pre">mjdref</span></code></p>
</dd>
<dt><strong>not_array_attr: list</strong></dt><dd><p>List of attributes that are never to be considered as array attributes. For example, GTIs
are not array attributes.</p>
</dd>
<dt><strong>dt: float</strong></dt><dd><p>The time resolution of the measurements. Can be a scalar or an array attribute (useful
for non-evenly sampled data or events from different instruments). It can also be 0, which
means that the time series is not evenly sampled and the effects of the time resolution are
considered negligible for the analysis. This is sometimes the case for events from
high-energy telescopes.</p>
</dd>
<dt><strong>mjdref</strong><span class="classifier">float</span></dt><dd><p>The MJD used as a reference for the time array.</p>
</dd>
<dt><strong>gtis: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Good Time Intervals</p>
</dd>
<dt><strong>high_precision</strong><span class="classifier">bool</span></dt><dd><p>Change the precision of self.time to float128. Useful while dealing with fast pulsars.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>array_attrs</strong><span class="classifier">dict</span></dt><dd><p>Array attributes to be set (e.g. <code class="docutils literal notranslate"><span class="pre">{&quot;flux&quot;:</span> <span class="pre">flux_array,</span> <span class="pre">&quot;flux_err&quot;:</span> <span class="pre">flux_err_array}</span></code>).
In principle, they could be specified as simple keyword arguments. But this way, we
will run a check on the length of the arrays, and raise an error if they are not of a
shape compatible with the <code class="docutils literal notranslate"><span class="pre">time</span></code> array.</p>
</dd>
<dt><strong>dt: float</strong></dt><dd><p>The time resolution of the time series. Can be a scalar or an array attribute (useful
for non-evenly sampled data or events from different instruments)</p>
</dd>
<dt><strong>mjdref</strong><span class="classifier">float</span></dt><dd><p>The MJD used as a reference for the time array.</p>
</dd>
<dt><strong>gtis: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Good Time Intervals</p>
</dd>
<dt><strong>high_precision</strong><span class="classifier">bool</span></dt><dd><p>Change the precision of self.time to float128. Useful while dealing with fast pulsars.</p>
</dd>
<dt><strong>timeref</strong><span class="classifier">str</span></dt><dd><p>The time reference, as recorded in the FITS file (e.g. SOLARSYSTEM)</p>
</dd>
<dt><strong>timesys</strong><span class="classifier">str</span></dt><dd><p>The time system, as recorded in the FITS file (e.g. TDB)</p>
</dd>
<dt><strong>ephem</strong><span class="classifier">str</span></dt><dd><p>The JPL ephemeris used to barycenter the data, if any (e.g. DE430)</p>
</dd>
<dt><strong>skip_checks</strong><span class="classifier">bool</span></dt><dd><p>Skip checks on the time array. Useful when the user is reasonably sure that the
input data are valid.</p>
</dd>
<dt><strong>**other_kw</strong></dt><dd><p>Used internally. Any other keyword arguments will be set as attributes of the object.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.analyze_by_gti">
<span class="sig-name descname"><span class="pre">analyze_by_gti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.analyze_by_gti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.analyze_by_gti" title="Link to this definition">¶</a></dt>
<dd><p>Analyze the light curve with any function, on a GTI-by-GTI base.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function accepting a <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object as single argument, plus
possible additional keyword arguments, and returning a number or a
tuple - e.g., <code class="docutils literal notranslate"><span class="pre">(result,</span> <span class="pre">error)</span></code> where both <code class="docutils literal notranslate"><span class="pre">result</span></code> and <code class="docutils literal notranslate"><span class="pre">error</span></code> are
numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>start_times</strong><span class="classifier">array</span></dt><dd><p>Lower time boundaries of all time segments.</p>
</dd>
<dt><strong>stop_times</strong><span class="classifier">array</span></dt><dd><p>upper time boundaries of all segments.</p>
</dd>
<dt><strong>result</strong><span class="classifier">array of N elements</span></dt><dd><p>The result of <code class="docutils literal notranslate"><span class="pre">func</span></code> for each segment of the light curve</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fraction_step</strong><span class="classifier">float</span></dt><dd><p>By default, segments do not overlap (<code class="docutils literal notranslate"><span class="pre">fraction_step</span></code> = 1). If <code class="docutils literal notranslate"><span class="pre">fraction_step</span></code> &lt; 1,
then the start points of consecutive segments are <code class="docutils literal notranslate"><span class="pre">fraction_step</span> <span class="pre">*</span> <span class="pre">segment_size</span></code>
apart, and consecutive segments overlap. For example, for <code class="docutils literal notranslate"><span class="pre">fraction_step</span></code> = 0.5,
the window shifts one half of <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>)</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>These additional keyword arguments, if present, they will be passed
to <code class="docutils literal notranslate"><span class="pre">func</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.analyze_segments">
<span class="sig-name descname"><span class="pre">analyze_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.analyze_segments"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.analyze_segments" title="Link to this definition">¶</a></dt>
<dd><p>Analyze segments of the light curve with any function.</p>
<p>Intervals with less than one data point are skipped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function accepting a <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object as single argument, plus
possible additional keyword arguments, and returning a number or a
tuple - e.g., <code class="docutils literal notranslate"><span class="pre">(result,</span> <span class="pre">error)</span></code> where both <code class="docutils literal notranslate"><span class="pre">result</span></code> and <code class="docutils literal notranslate"><span class="pre">error</span></code> are
numbers.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>Length in seconds of the light curve segments. If None, the full GTIs are considered
instead as segments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>start_times</strong><span class="classifier">array</span></dt><dd><p>Lower time boundaries of all time segments.</p>
</dd>
<dt><strong>stop_times</strong><span class="classifier">array</span></dt><dd><p>upper time boundaries of all segments.</p>
</dd>
<dt><strong>result</strong><span class="classifier">list of N elements</span></dt><dd><p>The result of <code class="docutils literal notranslate"><span class="pre">func</span></code> for each segment of the light curve. If the function
returns multiple outputs, they are returned as a list of arrays.
If a given interval has not enough data for a calculation, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fraction_step</strong><span class="classifier">float</span></dt><dd><p>If the step is not a full <code class="docutils literal notranslate"><span class="pre">segment_size</span></code> but less (e.g. a moving window),
this indicates the ratio between step step and <code class="docutils literal notranslate"><span class="pre">segment_size</span></code> (e.g.
0.5 means that the window shifts of half <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>)</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>These additional keyword arguments, if present, they will be passed
to <code class="docutils literal notranslate"><span class="pre">func</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">StingrayTimeseries</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="o">=</span><span class="n">counts</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define a function that calculates the mean</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the mean in segments of 5 seconds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">analyze_segments</span><span class="p">(</span><span class="n">mean_func</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.apply_gtis">
<span class="sig-name descname"><span class="pre">apply_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.apply_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.apply_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Apply Good Time Intervals (GTIs) to a time series. Filters all the array attributes, only
keeping the bins that fall into GTIs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.change_mjdref">
<span class="sig-name descname"><span class="pre">change_mjdref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_mjdref</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.base.StingrayTimeseries"><span class="pre">StingrayTimeseries</span></a></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.change_mjdref"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.change_mjdref" title="Link to this definition">¶</a></dt>
<dd><p>Change the MJD reference time (MJDREF) of the time series</p>
<p>The times of the time series will be shifted in order to be referred to
this new MJDREF</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>new_mjdref</strong><span class="classifier">float</span></dt><dd><p>New MJDREF</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>new_ts</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>The new time series, shifted by MJDREF</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.concatenate">
<span class="sig-name descname"><span class="pre">concatenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.concatenate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.concatenate" title="Link to this definition">¶</a></dt>
<dd><p>Concatenate two <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> objects.</p>
<p>This method concatenates two or more <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> objects along the time
axis. GTIs are recalculated by merging all the GTIs together. GTIs should not overlap at
any point.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object or list of <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> objects</span></dt><dd><p>A second time series object, or a list of objects to be concatenated</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>check_gti</strong><span class="classifier">bool</span></dt><dd><p>Check if the GTIs are overlapping or not. Default: True
If this is True and GTIs overlap, an error is raised.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.estimate_segment_size">
<span class="sig-name descname"><span class="pre">estimate_segment_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.estimate_segment_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.estimate_segment_size" title="Link to this definition">¶</a></dt>
<dd><p>Estimate a reasonable segment length for segment-by-segment analysis.</p>
<p>The user has to specify a criterion based on a minimum number of counts (if
the time series has a <code class="docutils literal notranslate"><span class="pre">counts</span></code> attribute) or a minimum number of time samples.
At least one between <code class="docutils literal notranslate"><span class="pre">min_counts</span></code> and <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> must be specified.
In the special case of a time series with <code class="docutils literal notranslate"><span class="pre">dt=0</span></code> (event list-like, where each time
stamp correspond to a single count), the two definitions are equivalent.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length of the light curve chunks that satisfies the conditions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>min_counts</strong><span class="classifier">int</span></dt><dd><p>Minimum number of counts for each chunk. Optional (but needs <code class="docutils literal notranslate"><span class="pre">min_samples</span></code>
if left unspecified). Only makes sense if the series has a <code class="docutils literal notranslate"><span class="pre">counts</span></code> attribute and
it is evenly sampled.</p>
</dd>
<dt><strong>min_samples</strong><span class="classifier">int</span></dt><dd><p>Minimum number of time bins. Optional (but needs <code class="docutils literal notranslate"><span class="pre">min_counts</span></code> if left unspecified).</p>
</dd>
<dt><strong>even_sampling</strong><span class="classifier">bool</span></dt><dd><p>Force the treatment of the data as evenly sampled or not. If None, the data are
considered evenly sampled if <code class="docutils literal notranslate"><span class="pre">self.dt</span></code> is larger than zero and the median
separation between subsequent times is within 1% of <code class="docutils literal notranslate"><span class="pre">self.dt</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">150</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">StingrayTimeseries</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="o">=</span><span class="n">counts</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="n">min_counts</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="n">min_counts</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">StingrayTimeseries</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="o">=</span><span class="n">counts</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="n">min_counts</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A slightly more complex example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">=</span><span class="mf">0.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">StingrayTimeseries</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="o">=</span><span class="n">counts</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_total_bins</span> <span class="o">=</span> <span class="mi">40</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="mf">8.0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.exposure">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">exposure</span></span><a class="headerlink" href="#stingray.StingrayTimeseries.exposure" title="Link to this definition">¶</a></dt>
<dd><p>Return the total exposure of the time series, i.e. the sum of the GTIs.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>total_exposure</strong><span class="classifier">float</span></dt><dd><p>The total exposure of the time series, in seconds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.fill_bad_time_intervals">
<span class="sig-name descname"><span class="pre">fill_bad_time_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_randomize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.fill_bad_time_intervals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.fill_bad_time_intervals" title="Link to this definition">¶</a></dt>
<dd><p>Fill short bad time intervals with random data.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is only appropriate for <em>very short</em> bad time intervals. The simulated data
are basically white noise, so they are able to alter the statistical properties of
variable data. For very short gaps in the data, the effect of these small
injections of white noise should be negligible. How short depends on the single case,
the user is urged not to use the method as a black box and make simulations to measure
its effect. If you have long bad time intervals, you should use more advanced
techniques, not currently available in Stingray for this use case, such as Gaussian
Processes. In particular, please verify that the values of <code class="docutils literal notranslate"><span class="pre">max_length</span></code> and
<code class="docutils literal notranslate"><span class="pre">buffer_size</span></code> are adequate to your case.</p>
</div>
<p>To fill the gaps in all but the time points (i.e., flux measures, energies), we take the
<code class="docutils literal notranslate"><span class="pre">buffer_size</span></code> (by default, the largest value between 100 and the estimated samples in
a <code class="docutils literal notranslate"><span class="pre">max_length</span></code>-long gap) valid data points closest to the gap and repeat them randomly
with the same empirical statistical distribution. So, if the <code class="xref py py-obj docutils literal notranslate"><span class="pre">my_fancy_attr</span></code> attribute, in
the 100 points of the buffer, has 30 times 10, 10 times 9, and 60 times 11, there will be
<em>on average</em> 30% of 10, 60% of 11, and 10% of 9 in the simulated data.</p>
<p>Times are treated differently depending on the fact that the time series is evenly
sampled or not. If it is not, the times are simulated from a uniform distribution with the
same count rate found in the buffer. Otherwise, times just follow the same grid used
inside GTIs. Using the evenly sampled or not is decided based on the <code class="docutils literal notranslate"><span class="pre">even_sampling</span></code>
parameter. If left to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the time series is considered evenly sampled if
<code class="docutils literal notranslate"><span class="pre">self.dt</span></code> is greater than zero and the median separation between subsequent times is
within 1% of the time resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_length</strong><span class="classifier">float</span></dt><dd><p>Maximum length of a bad time interval to be filled. If None, the criterion is bad
time intervals shorter than 1/100th of the longest good time interval.</p>
</dd>
<dt><strong>attrs_to_randomize</strong><span class="classifier">list of str, default None</span></dt><dd><p>List of array_attrs to randomize. <code class="docutils literal notranslate"><span class="pre">If</span> <span class="pre">None</span></code>, all array_attrs are randomized.
It should not include <code class="docutils literal notranslate"><span class="pre">time</span></code> and <code class="docutils literal notranslate"><span class="pre">_mask</span></code>, which are treated separately.</p>
</dd>
<dt><strong>buffer_size</strong><span class="classifier">int, default 100</span></dt><dd><p>Number of good data points to use to calculate the means and variance the random data
on each side of the bad time interval</p>
</dd>
<dt><strong>even_sampling</strong><span class="classifier">bool, default None</span></dt><dd><p>Force the treatment of the data as evenly sampled or not. If None, the data are
considered evenly sampled if <code class="docutils literal notranslate"><span class="pre">self.dt</span></code> is larger than zero and the median
separation between subsequent times is within 1% of <code class="docutils literal notranslate"><span class="pre">self.dt</span></code>.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, default None</span></dt><dd><p>Random seed to use for the simulation. If None, a random seed is generated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.from_astropy_timeseries">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_astropy_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TimeSeries</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><span class="pre">StingrayTimeseries</span></a></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.from_astropy_timeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.from_astropy_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> from data in an Astropy TimeSeries</p>
<p>The timeseries has to define at least a column called time,
the rest of columns will form the array attributes of the
new time series, while the attributes in table.meta will
form the new meta attributes of the time series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ts</strong><span class="classifier"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.timeseries.TimeSeries.html#astropy.timeseries.TimeSeries" title="(in Astropy v6.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astropy.timeseries.TimeSeries</span></code></a></span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">TimeSeries</span></code> object with the array attributes as columns,
and the meta attributes in the <code class="xref py py-obj docutils literal notranslate"><span class="pre">meta</span></code> dictionary</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>ts</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a></span></dt><dd><p>Timeseries object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.join"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.join" title="Link to this definition">¶</a></dt>
<dd><p>Join other <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> objects with the current one.</p>
<p>If both are empty, an empty <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> is returned.</p>
<p>Standard attributes such as <code class="docutils literal notranslate"><span class="pre">pi</span></code> and <code class="docutils literal notranslate"><span class="pre">energy</span></code> remain <code class="docutils literal notranslate"><span class="pre">None</span></code> if they are <code class="docutils literal notranslate"><span class="pre">None</span></code>
in both. Otherwise, <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> is used as a default value for the missing values.
Arbitrary array attributes are created and joined using the same convention.</p>
<p>Multiple checks are done on the joined time series. If the time array of the series
being joined is empty, it is ignored. If the time resolution is different, the final
time series will have the rougher time resolution. If the MJDREF is different, the time
reference will be changed to the one of the first time series. An empty time series will
be ignored.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">join</span></code> is not equivalent to <code class="docutils literal notranslate"><span class="pre">concatenate</span></code>. <code class="docutils literal notranslate"><span class="pre">concatenate</span></code> is used to join
multiple <strong>non-overlapping</strong> time series along the time axis, while <code class="docutils literal notranslate"><span class="pre">join</span></code> is more
general, and can be used to join multiple time series with different strategies (see
parameter <code class="docutils literal notranslate"><span class="pre">strategy</span></code> below).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> or class:<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code></a> of <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a></span></dt><dd><p>The other <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object which is supposed to be joined with.
If <code class="docutils literal notranslate"><span class="pre">other</span></code> is a list, it is assumed to be a list of <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a>
and they are all joined, one by one.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>`ts_new`</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>The resulting <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>strategy</strong><span class="classifier">{“intersection”, “union”, “append”, “infer”, “none”}</span></dt><dd><p>Method to use to merge the GTIs. If “intersection”, the GTIs are merged
using the intersection of the GTIs. If “union”, the GTIs are merged
using the union of the GTIs. If “none”, a single GTI with the minimum and
the maximum time stamps of all GTIs is returned. If “infer”, the strategy
is decided based on the GTIs. If there are no overlaps, “union” is used,
otherwise “intersection” is used. If “append”, the GTIs are simply appended
but they must be mutually exclusive.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">witherrors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_btis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the time series using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<p>Plot the time series object on a graph <code class="docutils literal notranslate"><span class="pre">self.time</span></code> on x-axis and
<code class="docutils literal notranslate"><span class="pre">self.counts</span></code> on y-axis with <code class="docutils literal notranslate"><span class="pre">self.counts_err</span></code> optionally
as error bars.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attr: str</strong></dt><dd><p>Attribute to plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>witherrors: boolean, default False</strong></dt><dd><p>Whether to plot the StingrayTimeseries with errorbars or not</p>
</dd>
<dt><strong>labels</strong><span class="classifier">iterable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A list or tuple with <code class="docutils literal notranslate"><span class="pre">xlabel</span></code> and <code class="docutils literal notranslate"><span class="pre">ylabel</span></code> as strings. E.g.
if the attribute is <code class="docutils literal notranslate"><span class="pre">'counts'</span></code>, the list of labels
could be <code class="docutils literal notranslate"><span class="pre">['Time</span> <span class="pre">(s)',</span> <span class="pre">'Counts</span> <span class="pre">(s^-1)']</span></code></p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis</span></code> object</span></dt><dd><p>Axis to be used for plotting. Defaults to creating a new one.</p>
</dd>
<dt><strong>axis_limits</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for the``matplotlib.pyplot.axis()`` method.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The title of the plot.</p>
</dd>
<dt><strong>marker</strong><span class="classifier">str, default ‘-’</span></dt><dd><p>Line style and color of the plot. Line styles and colors are
combined in a single format string, as in <code class="docutils literal notranslate"><span class="pre">'bo'</span></code> for blue
circles. See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> for more options.</p>
</dd>
<dt><strong>save</strong><span class="classifier">boolean, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
<dt><strong>plot_btis</strong><span class="classifier">bool</span></dt><dd><p>Plot the bad time intervals as red areas on the plot</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.rebin">
<span class="sig-name descname"><span class="pre">rebin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt_new</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sum'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.rebin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.rebin" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the time series to a new time resolution. While the new
resolution need not be an integer multiple of the previous time
resolution, be aware that if it is not, the last bin will be cut
off by the fraction left over by the integer division.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt_new: float</strong></dt><dd><p>The new time resolution of the time series. Must be larger than
the time resolution of the old time series!</p>
</dd>
<dt><strong>method: {``sum`` | ``mean`` | ``average``}, optional, default ``sum``</strong></dt><dd><p>This keyword argument sets whether the counts in the new bins
should be summed or averaged.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ts_new: <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</dt><dd><p>The <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object with the new, binned time series.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float</strong></dt><dd><p>the rebin factor. If specified, it substitutes <code class="docutils literal notranslate"><span class="pre">dt_new</span></code> with
<code class="docutils literal notranslate"><span class="pre">f*self.dt</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.shift">
<span class="sig-name descname"><span class="pre">shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_shift</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><span class="pre">float</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.base.StingrayTimeseries"><span class="pre">StingrayTimeseries</span></a></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.shift"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.shift" title="Link to this definition">¶</a></dt>
<dd><p>Shift the time and the GTIs by the same amount</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>time_shift: float</strong></dt><dd><p>The time interval by which the time series will be shifted (in
the same units as the time array in <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>ts</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code> object</span></dt><dd><p>The new time series shifted by <code class="docutils literal notranslate"><span class="pre">time_shift</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.sort"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.sort" title="Link to this definition">¶</a></dt>
<dd><p>Sort a <code class="docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code> object by time.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code> can be sorted in either increasing or decreasing order
using this method. The time array gets sorted and the counts array is
changed accordingly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reverse</strong><span class="classifier">boolean, default False</span></dt><dd><p>If True then the object is sorted in reverse order.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ts_new: <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</dt><dd><p>The <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object with sorted time and counts
arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">StingrayTimeseries</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">array_attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;counts&quot;</span><span class="p">:</span> <span class="n">count</span><span class="p">},</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts_new</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts_new</span><span class="o">.</span><span class="n">time</span>
<span class="go">array([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ts_new</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.split_by_gti">
<span class="sig-name descname"><span class="pre">split_by_gti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.split_by_gti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.split_by_gti" title="Link to this definition">¶</a></dt>
<dd><p>Split the current <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object into a list of
<a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> objects, one for each continuous GTI segment
as defined in the <code class="docutils literal notranslate"><span class="pre">gti</span></code> attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_points</strong><span class="classifier">int, default 1</span></dt><dd><p>The minimum number of data points in each time series. Light
curves with fewer data points will be ignored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>list_of_tss</strong><span class="classifier">list</span></dt><dd><p>A list of <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> objects, one for each GTI segment</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.to_astropy_timeseries">
<span class="sig-name descname"><span class="pre">to_astropy_timeseries</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TimeSeries</span></span></span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.to_astropy_timeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.to_astropy_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Save the <code class="docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code> to an <code class="docutils literal notranslate"><span class="pre">Astropy</span></code> timeseries.</p>
<p>Array attributes (time, pi, energy, etc.) are converted
into columns, while meta attributes (mjdref, gti, etc.)
are saved into the <code class="docutils literal notranslate"><span class="pre">meta</span></code> dictionary.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ts</strong><span class="classifier"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.timeseries.TimeSeries.html#astropy.timeseries.TimeSeries" title="(in Astropy v6.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astropy.timeseries.TimeSeries</span></code></a></span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">TimeSeries</span></code> object with the array attributes as columns,
and the meta attributes in the <code class="xref py py-obj docutils literal notranslate"><span class="pre">meta</span></code> dictionary</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.StingrayTimeseries.truncate">
<span class="sig-name descname"><span class="pre">truncate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'index'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/base.html#StingrayTimeseries.truncate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.StingrayTimeseries.truncate" title="Link to this definition">¶</a></dt>
<dd><p>Truncate a <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object.</p>
<p>This method takes a <code class="docutils literal notranslate"><span class="pre">start</span></code> and a <code class="docutils literal notranslate"><span class="pre">stop</span></code> point (either as indices,
or as times in the same unit as those in the <code class="docutils literal notranslate"><span class="pre">time</span></code> attribute, and truncates
all bins before <code class="docutils literal notranslate"><span class="pre">start</span></code> and after <code class="docutils literal notranslate"><span class="pre">stop</span></code>, then returns a new
<a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object with the truncated time series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>start</strong><span class="classifier">int, default 0</span></dt><dd><p>Index (or time stamp) of the starting point of the truncation. If no value is set
for the start point, then all points from the first element in the <code class="docutils literal notranslate"><span class="pre">time</span></code> array
are taken into account.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Index (or time stamp) of the ending point (exclusive) of the truncation. If no
value of stop is set, then points including the last point in
the counts array are taken in count.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">index</span></code> | <code class="docutils literal notranslate"><span class="pre">time</span></code>}, optional, default <code class="docutils literal notranslate"><span class="pre">index</span></code></span></dt><dd><p>Type of the start and stop values. If set to <code class="docutils literal notranslate"><span class="pre">index</span></code> then
the values are treated as indices of the counts array, or
if set to <code class="docutils literal notranslate"><span class="pre">time</span></code>, the values are treated as actual time values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ts_new: <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</dt><dd><p>The <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object with truncated time and arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span> <span class="o">=</span> <span class="n">StingrayTimeseries</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">array_attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;counts&quot;</span><span class="p">:</span> <span class="n">count</span><span class="p">},</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts_new</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ts_new</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ts_new</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Truncation can also be done by time values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ts_new</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ts_new</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ts_new</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="lightcurve">
<h3>Lightcurve<a class="headerlink" href="#lightcurve" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.Lightcurve">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">Lightcurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_dist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poisson'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac_exp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mjdref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">other_kw</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve" title="Link to this definition">¶</a></dt>
<dd><p>Make a light curve object from an array of time stamps and an
array of counts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>time: Iterable, `:class:astropy.time.Time`, or `:class:astropy.units.Quantity` object</strong></dt><dd><p>A list or array of time stamps for a light curve. Must be a type that
can be cast to <code class="xref py py-obj docutils literal notranslate"><span class="pre">:class:np.array</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">:class:List</span></code> of floats, or that
has a <code class="xref py py-obj docutils literal notranslate"><span class="pre">value</span></code> attribute that does (e.g. a
<code class="xref py py-obj docutils literal notranslate"><span class="pre">:class:astropy.units.Quantity</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">:class:astropy.time.Time</span></code> object).</p>
</dd>
<dt><strong>counts: iterable, optional, default ``None``</strong></dt><dd><p>A list or array of the counts in each bin corresponding to the
bins defined in <a class="reference external" href="https://docs.python.org/3/library/time.html#module-time" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time</span></code></a> (note: use <code class="docutils literal notranslate"><span class="pre">input_counts=False</span></code> to
input the count range, i.e. counts/second, otherwise use
counts/bin).</p>
</dd>
<dt><strong>err: iterable, optional, default ``None``</strong></dt><dd><p>A list or array of the uncertainties in each bin corresponding to
the bins defined in <code class="docutils literal notranslate"><span class="pre">time</span></code> (note: use <code class="docutils literal notranslate"><span class="pre">input_counts=False</span></code> to
input the count rage, i.e. counts/second, otherwise use
counts/bin). If <code class="docutils literal notranslate"><span class="pre">None</span></code>, we assume the data is poisson distributed
and calculate the error from the average of the lower and upper
1-sigma confidence intervals for the Poissonian distribution with
mean equal to <code class="docutils literal notranslate"><span class="pre">counts</span></code>.</p>
</dd>
<dt><strong>input_counts: bool, optional, default True</strong></dt><dd><p>If True, the code assumes that the input data in <code class="docutils literal notranslate"><span class="pre">counts</span></code>
is in units of counts/bin. If False, it assumes the data
in <code class="docutils literal notranslate"><span class="pre">counts</span></code> is in counts/second.</p>
</dd>
<dt><strong>gti: 2-d float array, default ``None``</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>
Good Time Intervals. They are <em>not</em> applied to the data by default.
They will be used by other methods to have an indication of the
“safe” time intervals to use during analysis.</p>
</dd>
<dt><strong>err_dist: str, optional, default ``None``</strong></dt><dd><p>Statistical distribution used to calculate the
uncertainties and other statistical values appropriately.
Default makes no assumptions and keep errors equal to zero.</p>
</dd>
<dt><strong>bg_counts: iterable,`:class:numpy.array` or `:class:List` of floats, optional, default ``None``</strong></dt><dd><p>A list or array of background counts detected in the background extraction region
in each bin corresponding to the bins defined in <a class="reference external" href="https://docs.python.org/3/library/time.html#module-time" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time</span></code></a>.</p>
</dd>
<dt><strong>bg_ratio: iterable, `:class:numpy.array` or `:class:List` of floats, optional, default ``None``</strong></dt><dd><p>A list or array of source region area to background region area ratio in each bin. These are
factors by which the <code class="xref py py-obj docutils literal notranslate"><span class="pre">bg_counts</span></code> should be scaled to estimate background counts within the
source aperture.</p>
</dd>
<dt><strong>frac_exp: iterable, `:class:numpy.array` or `:class:List` of floats, optional, default ``None``</strong></dt><dd><p>A list or array of fractional exposers in each bin.</p>
</dd>
<dt><strong>mjdref: float</strong></dt><dd><p>MJD reference (useful in most high-energy mission data)</p>
</dd>
<dt><strong>dt: float or array of floats. Default median(diff(time))</strong></dt><dd><p>Time resolution of the light curve. Can be an array of the same dimension
as <code class="docutils literal notranslate"><span class="pre">time</span></code> specifying width of each bin.</p>
</dd>
<dt><strong>skip_checks: bool</strong></dt><dd><p>If True, the user specifies that data are already sorted and contain no
infinite or nan points. Use at your own risk</p>
</dd>
<dt><strong>low_memory: bool</strong></dt><dd><p>If True, all the lazily evaluated attribute (e.g., countrate and
countrate_err if input_counts is True) will _not_ be stored in memory,
but calculated every time they are requested.</p>
</dd>
<dt><strong>mission</strong><span class="classifier">str</span></dt><dd><p>Mission that recorded the data (e.g. NICER)</p>
</dd>
<dt><strong>instr</strong><span class="classifier">str</span></dt><dd><p>Instrument onboard the mission</p>
</dd>
<dt><strong>header</strong><span class="classifier">str</span></dt><dd><p>The full header of the original FITS file, if relevant</p>
</dd>
<dt><strong>**other_kw</strong></dt><dd><p>Used internally. Any other keyword arguments will be ignored</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>time: numpy.ndarray</strong></dt><dd><p>The array of midpoints of time bins.</p>
</dd>
<dt><strong>bin_lo: numpy.ndarray</strong></dt><dd><p>The array of lower time stamp of time bins.</p>
</dd>
<dt><strong>bin_hi: numpy.ndarray</strong></dt><dd><p>The array of higher time stamp of time bins.</p>
</dd>
<dt><strong>counts: numpy.ndarray</strong></dt><dd><p>The counts per bin corresponding to the bins in <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
<dt><strong>counts_err: numpy.ndarray</strong></dt><dd><p>The uncertainties corresponding to <code class="docutils literal notranslate"><span class="pre">counts</span></code></p>
</dd>
<dt><strong>bg_counts: numpy.ndarray</strong></dt><dd><p>The background counts corresponding to the bins in <a class="reference external" href="https://docs.python.org/3/library/time.html#module-time" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time</span></code></a>.</p>
</dd>
<dt><strong>bg_ratio: numpy.ndarray</strong></dt><dd><p>The ratio of source region area to background region area corresponding to each bin.</p>
</dd>
<dt><strong>frac_exp: numpy.ndarray</strong></dt><dd><p>The fractional exposers in each bin.</p>
</dd>
<dt><strong>countrate: numpy.ndarray</strong></dt><dd><p>The counts per second in each of the bins defined in <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
<dt><strong>countrate_err: numpy.ndarray</strong></dt><dd><p>The uncertainties corresponding to <code class="docutils literal notranslate"><span class="pre">countrate</span></code></p>
</dd>
<dt><strong>meanrate: float</strong></dt><dd><p>The mean count rate of the light curve.</p>
</dd>
<dt><strong>meancounts: float</strong></dt><dd><p>The mean counts of the light curve.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>The number of data points in the light curve.</p>
</dd>
<dt><strong>dt: float or array of floats</strong></dt><dd><p>The time resolution of the light curve.</p>
</dd>
<dt><strong>mjdref: float</strong></dt><dd><p>MJD reference date (<code class="docutils literal notranslate"><span class="pre">tstart</span></code> / 86400 gives the date in MJD at the
start of the observation)</p>
</dd>
<dt><strong>tseg: float</strong></dt><dd><p>The total duration of the light curve.</p>
</dd>
<dt><strong>tstart: float</strong></dt><dd><p>The start time of the light curve.</p>
</dd>
<dt><strong>gti: 2-d float array</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>
Good Time Intervals. They indicate the “safe” time intervals
to be used during the analysis of the light curve.</p>
</dd>
<dt><strong>err_dist: string</strong></dt><dd><p>Statistic of the Lightcurve, it is used to calculate the
uncertainties and other statistical values appropriately.
It propagates to Spectrum classes.</p>
</dd>
<dt><strong>mission</strong><span class="classifier">str</span></dt><dd><p>Mission that recorded the data (e.g. NICER)</p>
</dd>
<dt><strong>instr</strong><span class="classifier">str</span></dt><dd><p>Instrument onboard the mission</p>
</dd>
<dt><strong>detector_id</strong><span class="classifier">iterable</span></dt><dd><p>The detector that recoded each photon, if relevant (e.g. XMM, Chandra)</p>
</dd>
<dt><strong>header</strong><span class="classifier">str</span></dt><dd><p>The full header of the original FITS file, if relevant</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.analyze_lc_chunks">
<span class="sig-name descname"><span class="pre">analyze_lc_chunks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.analyze_lc_chunks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.analyze_lc_chunks" title="Link to this definition">¶</a></dt>
<dd><p>Analyze segments of the light curve with any function.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 2.0: </span>Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Lightcurve.analyze_segments(func,</span> <span class="pre">segment_size)()</span></code> instead.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>Length in seconds of the light curve segments</p>
</dd>
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>Function accepting a <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object as single argument, plus
possible additional keyword arguments, and returning a number or a
tuple - e.g., <code class="docutils literal notranslate"><span class="pre">(result,</span> <span class="pre">error)</span></code> where both <code class="docutils literal notranslate"><span class="pre">result</span></code> and <code class="docutils literal notranslate"><span class="pre">error</span></code> are
numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>start_times</strong><span class="classifier">array</span></dt><dd><p>Lower time boundaries of all time segments.</p>
</dd>
<dt><strong>stop_times</strong><span class="classifier">array</span></dt><dd><p>upper time boundaries of all segments.</p>
</dd>
<dt><strong>result</strong><span class="classifier">array of N elements</span></dt><dd><p>The result of <code class="docutils literal notranslate"><span class="pre">func</span></code> for each segment of the light curve</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fraction_step</strong><span class="classifier">float</span></dt><dd><p>By default, segments do not overlap (<code class="docutils literal notranslate"><span class="pre">fraction_step</span></code> = 1). If <code class="docutils literal notranslate"><span class="pre">fraction_step</span></code> &lt; 1,
then the start points of consecutive segments are <code class="docutils literal notranslate"><span class="pre">fraction_step</span> <span class="pre">*</span> <span class="pre">segment_size</span></code>
apart, and consecutive segments overlap. For example, for <code class="docutils literal notranslate"><span class="pre">fraction_step</span></code> = 0.5,
the window shifts one half of <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>)</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>These additional keyword arguments, if present, they will be passed
to <code class="docutils literal notranslate"><span class="pre">func</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.apply_gtis">
<span class="sig-name descname"><span class="pre">apply_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.apply_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.apply_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Apply GTIs to a light curve. Filters the <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">counts</span></code>,
<code class="docutils literal notranslate"><span class="pre">countrate</span></code>, <code class="docutils literal notranslate"><span class="pre">counts_err</span></code> and <code class="docutils literal notranslate"><span class="pre">countrate_err</span></code> arrays for all bins
that fall into Good Time Intervals and recalculates mean countrate
and the number of bins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current light curve. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.baseline">
<span class="sig-name descname"><span class="pre">baseline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.baseline"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.baseline" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the baseline of the light curve, accounting for GTIs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lam</strong><span class="classifier">float</span></dt><dd><p>“smoothness” parameter. Larger values make the baseline stiffer
Typically <code class="docutils literal notranslate"><span class="pre">1e2</span> <span class="pre">&lt;</span> <span class="pre">lam</span> <span class="pre">&lt;</span> <span class="pre">1e9</span></code></p>
</dd>
<dt><strong>p</strong><span class="classifier">float</span></dt><dd><p>“asymmetry” parameter. Smaller values make the baseline more
“horizontal”. Typically <code class="docutils literal notranslate"><span class="pre">0.001</span> <span class="pre">&lt;</span> <span class="pre">p</span> <span class="pre">&lt;</span> <span class="pre">0.1</span></code>, but not necessary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>baseline</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array with the baseline of the light curve</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offset_correction</strong><span class="classifier">bool, default False</span></dt><dd><p>by default, this method does not align to the running mean of the
light curve, but it goes below the light curve. Setting align to
True, an additional step is done to shift the baseline so that it
is shifted to the middle of the light curve noise distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.bexvar">
<span class="sig-name descname"><span class="pre">bexvar</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.bexvar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.bexvar" title="Link to this definition">¶</a></dt>
<dd><p>Finds posterior samples of Bayesian excess variance (bexvar) for the light curve.
It requires source counts in <code class="docutils literal notranslate"><span class="pre">counts</span></code> and time intervals for each bin.
If the <code class="docutils literal notranslate"><span class="pre">dt</span></code> is an array then uses its elements as time intervals
for each bin. If <code class="docutils literal notranslate"><span class="pre">dt</span></code> is float, it calculates the time intervals by assuming
all intervals to be equal to <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lc_bexvar</strong><span class="classifier">iterable, <code class="xref py py-obj docutils literal notranslate"><span class="pre">:class:numpy.array</span></code> of floats</span></dt><dd><p>An array of posterior samples of Bayesian excess variance (bexvar).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.check_lightcurve">
<span class="sig-name descname"><span class="pre">check_lightcurve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.check_lightcurve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.check_lightcurve" title="Link to this definition">¶</a></dt>
<dd><p>Make various checks on the lightcurve.</p>
<p>It can be slow, use it if you are not sure about your
input data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.estimate_chunk_length">
<span class="sig-name descname"><span class="pre">estimate_chunk_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.estimate_chunk_length"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.estimate_chunk_length" title="Link to this definition">¶</a></dt>
<dd><p>Deprecated alias of estimate_segment_size.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.estimate_segment_size">
<span class="sig-name descname"><span class="pre">estimate_segment_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.estimate_segment_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.estimate_segment_size" title="Link to this definition">¶</a></dt>
<dd><p>Estimate a reasonable segment length for segment-by-segment analysis.</p>
<p>The user has to specify a criterion based on a minimum number of counts (if
the time series has a <code class="docutils literal notranslate"><span class="pre">counts</span></code> attribute) or a minimum number of time samples.
At least one between <code class="docutils literal notranslate"><span class="pre">min_counts</span></code> and <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> must be specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length of the light curve chunks that satisfies the conditions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>min_counts</strong><span class="classifier">int</span></dt><dd><p>Minimum number of counts for each chunk. Optional (but needs <code class="docutils literal notranslate"><span class="pre">min_samples</span></code>
if left unspecified). Only makes sense if the series has a <code class="docutils literal notranslate"><span class="pre">counts</span></code> attribute and
it is evenly sampled.</p>
</dd>
<dt><strong>min_samples</strong><span class="classifier">int</span></dt><dd><p>Minimum number of time bins. Optional (but needs <code class="docutils literal notranslate"><span class="pre">min_counts</span></code> if left unspecified).</p>
</dd>
<dt><strong>even_sampling</strong><span class="classifier">bool</span></dt><dd><p>Force the treatment of the data as evenly sampled or not. If None, the data are
considered evenly sampled if <code class="docutils literal notranslate"><span class="pre">self.dt</span></code> is larger than zero and the median
separation between subsequent times is within 1% of <code class="docutils literal notranslate"><span class="pre">self.dt</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">150</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">lc</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="n">min_counts</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="n">min_counts</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="n">min_counts</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A slightly more complex example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">=</span><span class="mf">0.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_total_bins</span> <span class="o">=</span> <span class="mi">40</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="mf">8.0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.from_astropy_table">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.from_astropy_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.from_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create a Stingray Object object from data in an Astropy Table.</p>
<p>The table MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.from_astropy_timeseries">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_astropy_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.from_astropy_timeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.from_astropy_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> from data in an Astropy TimeSeries</p>
<p>The timeseries has to define at least a column called time,
the rest of columns will form the array attributes of the
new time series, while the attributes in table.meta will
form the new meta attributes of the time series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ts</strong><span class="classifier"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.timeseries.TimeSeries.html#astropy.timeseries.TimeSeries" title="(in Astropy v6.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astropy.timeseries.TimeSeries</span></code></a></span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">TimeSeries</span></code> object with the array attributes as columns,
and the meta attributes in the <code class="xref py py-obj docutils literal notranslate"><span class="pre">meta</span></code> dictionary</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>ts</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a></span></dt><dd><p>Timeseries object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.from_lightkurve">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lightkurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.from_lightkurve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.from_lightkurve" title="Link to this definition">¶</a></dt>
<dd><p>Creates a new <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> from a <code class="xref py py-obj docutils literal notranslate"><span class="pre">lightkurve.LightCurve</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lk</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lightkurve.LightCurve</span></code></span></dt><dd><p>A lightkurve LightCurve object</p>
</dd>
<dt><strong>skip_checks: bool</strong></dt><dd><p>If True, the user specifies that data are already sorted and contain no
infinite or nan points. Use at your own risk.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.join"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.join" title="Link to this definition">¶</a></dt>
<dd><p>Join two lightcurves into a single object.</p>
<p>The new <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object will contain time stamps from both the
objects. The <code class="docutils literal notranslate"><span class="pre">counts</span></code> and <code class="docutils literal notranslate"><span class="pre">countrate</span></code> attributes in the resulting object
will contain the union of the non-overlapping parts of the two individual objects,
or the average in case of overlapping <code class="docutils literal notranslate"><span class="pre">time</span></code> arrays of both <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> objects.</p>
<p>Good Time Intervals are also joined.</p>
<p>Note : Ideally, the <code class="docutils literal notranslate"><span class="pre">time</span></code> array of both lightcurves should not overlap.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object</span></dt><dd><p>The other <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object which is supposed to be joined with.</p>
</dd>
<dt><strong>skip_checks: bool</strong></dt><dd><p>If True, the user specifies that data are already sorted and
contain no infinite or nan points. Use at your own risk.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>lc_new</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object</span></dt><dd><p>The resulting <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">600</span><span class="p">,</span> <span class="mi">1200</span><span class="p">,</span> <span class="mi">800</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc1</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">time1</span><span class="p">,</span> <span class="n">count1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc2</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">time2</span><span class="p">,</span> <span class="n">count2</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span> <span class="o">=</span> <span class="n">lc1</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lc2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span><span class="o">.</span><span class="n">time</span>
<span class="go">array([ 5, 10, 15, 20, 25, 30])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="p">[</span> <span class="mi">300</span><span class="p">,</span>  <span class="mi">100</span><span class="p">,</span>  <span class="mi">400</span><span class="p">,</span>  <span class="mi">600</span><span class="p">,</span> <span class="mi">1200</span><span class="p">,</span>  <span class="mi">800</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.make_lightcurve">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">make_lightcurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">toa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tseg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mjdref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.make_lightcurve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.make_lightcurve" title="Link to this definition">¶</a></dt>
<dd><p>Make a light curve out of photon arrival times, with a given time resolution <code class="docutils literal notranslate"><span class="pre">dt</span></code>.
Note that <code class="docutils literal notranslate"><span class="pre">dt</span></code> should be larger than the native time resolution of the instrument
that has taken the data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>toa: iterable</strong></dt><dd><p>list of photon arrival times</p>
</dd>
<dt><strong>dt: float</strong></dt><dd><p>time resolution of the light curve (the bin width)</p>
</dd>
<dt><strong>tseg: float, optional, default ``None``</strong></dt><dd><p>The total duration of the light curve.
If this is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then the total duration of the light curve will
be the interval between the arrival between either the first and the last
gti boundary or, if gti is not set, the first and the last photon in <code class="docutils literal notranslate"><span class="pre">toa</span></code>.</p>
<blockquote>
<div><p><strong>Note</strong>: If <code class="docutils literal notranslate"><span class="pre">tseg</span></code> is not divisible by <code class="docutils literal notranslate"><span class="pre">dt</span></code> (i.e. if <code class="docutils literal notranslate"><span class="pre">tseg</span></code>/<code class="docutils literal notranslate"><span class="pre">dt</span></code> is
not an integer number), then the last fractional bin will be
dropped!</p>
</div></blockquote>
</dd>
<dt><strong>tstart: float, optional, default ``None``</strong></dt><dd><p>The start time of the light curve.
If this is <code class="docutils literal notranslate"><span class="pre">None</span></code>, either the first gti boundary or, if not available,
the arrival time of the first photon will be used
as the start time of the light curve.</p>
</dd>
<dt><strong>gti: 2-d float array</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>
Good Time Intervals</p>
</dd>
<dt><strong>use_hist</strong><span class="classifier">bool</span></dt><dd><p>Use <code class="docutils literal notranslate"><span class="pre">np.histogram</span></code> instead of <code class="docutils literal notranslate"><span class="pre">np.bincounts</span></code>. Might be advantageous
for very short datasets.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lc: <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object</dt><dd><p>A <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object with the binned light curve</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">witherrors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_btis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the light curve using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<p>Plot the light curve object on a graph <code class="docutils literal notranslate"><span class="pre">self.time</span></code> on x-axis and
<code class="docutils literal notranslate"><span class="pre">self.counts</span></code> on y-axis with <code class="docutils literal notranslate"><span class="pre">self.counts_err</span></code> optionally
as error bars.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>witherrors: boolean, default False</strong></dt><dd><p>Whether to plot the Lightcurve with errorbars or not</p>
</dd>
<dt><strong>labels</strong><span class="classifier">iterable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A list of tuple with <code class="docutils literal notranslate"><span class="pre">xlabel</span></code> and <code class="docutils literal notranslate"><span class="pre">ylabel</span></code> as strings.</p>
</dd>
<dt><strong>axis_limits</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for the``matplotlib.pyplot.axis()`` method.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Deprecated in favor of <code class="docutils literal notranslate"><span class="pre">axis_limits</span></code>, same functionality.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The title of the plot.</p>
</dd>
<dt><strong>marker</strong><span class="classifier">str, default ‘-’</span></dt><dd><p>Line style and color of the plot. Line styles and colors are
combined in a single format string, as in <code class="docutils literal notranslate"><span class="pre">'bo'</span></code> for blue
circles. See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> for more options.</p>
</dd>
<dt><strong>save</strong><span class="classifier">boolean, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis</span></code> object</span></dt><dd><p>Axis to be used for plotting. Defaults to creating a new one.</p>
</dd>
<dt><strong>plot_btis</strong><span class="classifier">bool</span></dt><dd><p>Plot the bad time intervals as red areas on the plot</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.read">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err_dist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">fits_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.read" title="Link to this definition">¶</a></dt>
<dd><p>Read a <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object from file.</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>hea : FITS Light curves from HEASARC-supported missions.</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>Files that need the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> interface MUST contain
at least a <code class="docutils literal notranslate"><span class="pre">time</span></code> column and a <code class="docutils literal notranslate"><span class="pre">counts</span></code> or <code class="docutils literal notranslate"><span class="pre">countrate</span></code> column.
The default ascii format is enhanced CSV (ECSV). Data formats
supporting the serialization of metadata (such as ECSV and HDF5) can
contain all lightcurve attributes such as <code class="docutils literal notranslate"><span class="pre">dt</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc with
no significant loss of information. Other file formats might lose part
of the metadata, so must be used with care.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Path and file name for the file to be read.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>Available options are ‘pickle’, ‘hea’, and any <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code>-supported
format such as ‘hdf5’, ‘ascii.ecsv’, etc.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>lc</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>err_dist: str, default=’gauss’</strong></dt><dd><p>Default error distribution if not specified in the file (e.g. for
ASCII files). The default is ‘gauss’ just because it is likely
that people using ASCII light curves will want to specify Gaussian
error bars, if any.</p>
</dd>
<dt><strong>skip_checks</strong><span class="classifier">bool</span></dt><dd><p>See <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> documentation</p>
</dd>
<dt><strong>**fits_kwargs</strong><span class="classifier">additional keyword arguments</span></dt><dd><p>Any other arguments to be passed to <code class="xref py py-obj docutils literal notranslate"><span class="pre">lcurve_from_fits</span></code> (only relevant
for hea/ogip formats)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.rebin">
<span class="sig-name descname"><span class="pre">rebin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt_new</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sum'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.rebin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.rebin" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the light curve to a new time resolution. While the new
resolution need not be an integer multiple of the previous time
resolution, be aware that if it is not, the last bin will be cut
off by the fraction left over by the integer division.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt_new: float</strong></dt><dd><p>The new time resolution of the light curve. Must be larger than
the time resolution of the old light curve!</p>
</dd>
<dt><strong>method: {``sum`` | ``mean`` | ``average``}, optional, default ``sum``</strong></dt><dd><p>This keyword argument sets whether the counts in the new bins
should be summed or averaged.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lc_new: <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object</dt><dd><p>The <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object with the new, binned light curve.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float</strong></dt><dd><p>the rebin factor. If specified, it substitutes <code class="docutils literal notranslate"><span class="pre">dt_new</span></code> with
<code class="docutils literal notranslate"><span class="pre">f*self.dt</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.sort"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.sort" title="Link to this definition">¶</a></dt>
<dd><p>Sort a Lightcurve object by time.</p>
<p>A Lightcurve can be sorted in either increasing or decreasing order
using this method. The time array gets sorted and the counts array is
changed accordingly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reverse</strong><span class="classifier">boolean, default False</span></dt><dd><p>If True then the object is sorted in reverse order.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current light curve. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lc_new: <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object</dt><dd><p>The <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object with sorted time and counts
arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc_new</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc_new</span><span class="o">.</span><span class="n">time</span>
<span class="go">array([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lc_new</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.sort_counts">
<span class="sig-name descname"><span class="pre">sort_counts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.sort_counts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.sort_counts" title="Link to this definition">¶</a></dt>
<dd><p>Sort a <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object in accordance with its counts array.</p>
<p>A <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> can be sorted in either increasing or decreasing order
using this method. The counts array gets sorted and the time array is
changed accordingly.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>reverse</strong><span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> then the object is sorted in reverse order.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current light curve. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lc_new: <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object</dt><dd><p>The <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object with sorted <code class="docutils literal notranslate"><span class="pre">time</span></code> and <code class="docutils literal notranslate"><span class="pre">counts</span></code>
arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc_new</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">sort_counts</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc_new</span><span class="o">.</span><span class="n">time</span>
<span class="go">array([2, 1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lc_new</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_gap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.split" title="Link to this definition">¶</a></dt>
<dd><p>For data with gaps, it can sometimes be useful to be able to split
the light curve into separate, evenly sampled objects along those
data gaps. This method allows to do this: it finds data gaps of a
specified minimum size, and produces a list of new <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lightcurve</span></code></a>
objects for each contiguous segment.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_gap</strong><span class="classifier">float</span></dt><dd><p>The length of a data gap, in the same units as the <a class="reference external" href="https://docs.python.org/3/library/time.html#module-time" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time</span></code></a> attribute
of the <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object. Any smaller gaps will be ignored, any
larger gaps will be identified and used to split the light curve.</p>
</dd>
<dt><strong>min_points</strong><span class="classifier">int, default 1</span></dt><dd><p>The minimum number of data points in each light curve. Light
curves with fewer data points will be ignored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>lc_split</strong><span class="classifier">iterable of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> objects</span></dt><dd><p>The list of all contiguous light curves</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_lc</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.to_astropy_table">
<span class="sig-name descname"><span class="pre">to_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.to_astropy_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.to_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Save the light curve to an <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> object.</p>
<p>The time array and all the array attributes become columns. The meta attributes become
metadata of the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>no_longdouble</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, the data are converted to double precision before being saved.
This is useful, e.g., for saving to FITS files, which do not support long double precision.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.to_astropy_timeseries">
<span class="sig-name descname"><span class="pre">to_astropy_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.to_astropy_timeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.to_astropy_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Save the light curve to an <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.timeseries.TimeSeries.html#astropy.timeseries.TimeSeries" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.timeseries.TimeSeries</span></code></a> object.</p>
<p>The time array and all the array attributes become columns. The meta attributes become
metadata of the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.timeseries.TimeSeries.html#astropy.timeseries.TimeSeries" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.timeseries.TimeSeries</span></code></a> object.
The time array is saved as a TimeDelta object.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>no_longdouble</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, the data are converted to double precision before being saved.
This is useful, e.g., for saving to FITS files, which do not support long double precision.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.to_lightkurve">
<span class="sig-name descname"><span class="pre">to_lightkurve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.to_lightkurve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.to_lightkurve" title="Link to this definition">¶</a></dt>
<dd><p>Returns a <code class="xref py py-obj docutils literal notranslate"><span class="pre">lightkurve.LightCurve</span></code> object.
This feature requires <code class="docutils literal notranslate"><span class="pre">Lightkurve</span></code> to be installed
(e.g. <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">lightkurve</span></code>).  An <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ImportError" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImportError</span></code></a> will
be raised if this package is not available.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lightcurve</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lightkurve.LightCurve</span></code></span></dt><dd><p>A lightkurve LightCurve object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Lightcurve.truncate">
<span class="sig-name descname"><span class="pre">truncate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'index'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/lightcurve.html#Lightcurve.truncate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Lightcurve.truncate" title="Link to this definition">¶</a></dt>
<dd><p>Truncate a <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object.</p>
<p>This method takes a <code class="docutils literal notranslate"><span class="pre">start</span></code> and a <code class="docutils literal notranslate"><span class="pre">stop</span></code> point (either as indices,
or as times in the same unit as those in the <code class="docutils literal notranslate"><span class="pre">time</span></code> attribute, and truncates
all bins before <code class="docutils literal notranslate"><span class="pre">start</span></code> and after <code class="docutils literal notranslate"><span class="pre">stop</span></code>, then returns a new <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a>
object with the truncated light curve.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>start</strong><span class="classifier">int, default 0</span></dt><dd><p>Index (or time stamp) of the starting point of the truncation. If no value is set
for the start point, then all points from the first element in the <code class="docutils literal notranslate"><span class="pre">time</span></code> array
are taken into account.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Index (or time stamp) of the ending point (exclusive) of the truncation. If no
value of stop is set, then points including the last point in
the counts array are taken in count.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">index</span></code> | <code class="docutils literal notranslate"><span class="pre">time</span></code>}, optional, default <code class="docutils literal notranslate"><span class="pre">index</span></code></span></dt><dd><p>Type of the start and stop values. If set to <code class="docutils literal notranslate"><span class="pre">index</span></code> then
the values are treated as indices of the counts array, or
if set to <code class="docutils literal notranslate"><span class="pre">time</span></code>, the values are treated as actual time values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lc_new: <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object</dt><dd><p>The <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object with truncated time and counts
arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc_new</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lc_new</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc_new</span><span class="o">.</span><span class="n">time</span>
<span class="go">array([3, 4, 5, 6, 7, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Truncation can also be done by time values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc_new</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc_new</span><span class="o">.</span><span class="n">time</span>
<span class="go">array([6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lc_new</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="eventlist">
<h3>EventList<a class="headerlink" href="#eventlist" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.events.EventList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.events.</span></span><span class="sig-name descname"><span class="pre">EventList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncounts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mjdref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ephem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timesys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmf_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">other_kw</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList" title="Link to this definition">¶</a></dt>
<dd><p>Basic class for event list data. Event lists generally correspond to individual events (e.g. photons)
recorded by the detector, and their associated properties. For X-ray data where this type commonly occurs,
events are time stamps of when a photon arrived in the detector, and (optionally) the photon energy associated
with the event.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>time: iterable</strong></dt><dd><p>A list or array of time stamps</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>time: numpy.ndarray</strong></dt><dd><p>The array of event arrival times, in seconds from the reference
MJD defined in <code class="docutils literal notranslate"><span class="pre">mjdref</span></code></p>
</dd>
<dt><strong>energy: numpy.ndarray</strong></dt><dd><p>The array of photon energy values</p>
</dd>
<dt><strong>ncounts: int</strong></dt><dd><p>The number of data points in the event list</p>
</dd>
<dt><strong>dt: float</strong></dt><dd><p>The time resolution of the events. Only relevant when using events
to produce light curves with similar bin time.</p>
</dd>
<dt><strong>mjdref</strong><span class="classifier">float</span></dt><dd><p>The MJD used as a reference for the time array.</p>
</dd>
<dt><strong>gtis: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Good Time Intervals</p>
</dd>
<dt><strong>pi</strong><span class="classifier">integer, numpy.ndarray</span></dt><dd><p>PI channels</p>
</dd>
<dt><strong>high_precision</strong><span class="classifier">bool</span></dt><dd><p>Change the precision of self.time to float128. Useful while dealing with fast pulsars.</p>
</dd>
<dt><strong>mission</strong><span class="classifier">str</span></dt><dd><p>Mission that recorded the data (e.g. NICER)</p>
</dd>
<dt><strong>instr</strong><span class="classifier">str</span></dt><dd><p>Instrument onboard the mission</p>
</dd>
<dt><strong>detector_id</strong><span class="classifier">iterable</span></dt><dd><p>The detector that recoded each photon, if relevant (e.g. XMM, Chandra)</p>
</dd>
<dt><strong>header</strong><span class="classifier">str</span></dt><dd><p>The full header of the original FITS file, if relevant</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt: float</strong></dt><dd><p>The time resolution of the events. Only relevant when using events
to produce light curves with similar bin time.</p>
</dd>
<dt><strong>energy: iterable</strong></dt><dd><p>A list of array of photon energy values in keV</p>
</dd>
<dt><strong>mjdref</strong><span class="classifier">float</span></dt><dd><p>The MJD used as a reference for the time array.</p>
</dd>
<dt><strong>ncounts: int</strong></dt><dd><p>Number of desired data points in event list. Deprecated</p>
</dd>
<dt><strong>gtis: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Good Time Intervals</p>
</dd>
<dt><strong>pi</strong><span class="classifier">integer, numpy.ndarray</span></dt><dd><p>PI channels</p>
</dd>
<dt><strong>notes</strong><span class="classifier">str</span></dt><dd><p>Any useful annotations</p>
</dd>
<dt><strong>high_precision</strong><span class="classifier">bool</span></dt><dd><p>Change the precision of self.time to float128. Useful while dealing with fast pulsars.</p>
</dd>
<dt><strong>mission</strong><span class="classifier">str</span></dt><dd><p>Mission that recorded the data (e.g. NICER)</p>
</dd>
<dt><strong>instr</strong><span class="classifier">str</span></dt><dd><p>Instrument onboard the mission</p>
</dd>
<dt><strong>header</strong><span class="classifier">str</span></dt><dd><p>The full header of the original FITS file, if relevant</p>
</dd>
<dt><strong>detector_id</strong><span class="classifier">iterable</span></dt><dd><p>The detector that recorded each photon (if the instrument has more than
one, e.g. XMM/EPIC-pn)</p>
</dd>
<dt><strong>timeref</strong><span class="classifier">str</span></dt><dd><p>The time reference, as recorded in the FITS file (e.g. SOLARSYSTEM)</p>
</dd>
<dt><strong>timesys</strong><span class="classifier">str</span></dt><dd><p>The time system, as recorded in the FITS file (e.g. TDB)</p>
</dd>
<dt><strong>ephem</strong><span class="classifier">str</span></dt><dd><p>The JPL ephemeris used to barycenter the data, if any (e.g. DE430)</p>
</dd>
<dt><strong>rmf_file</strong><span class="classifier">str, default None</span></dt><dd><p>The file name of the RMF file to use for calibration.</p>
</dd>
<dt><strong>skip_checks</strong><span class="classifier">bool, default False</span></dt><dd><p>Skip checks for the validity of the event list. Use with caution.</p>
</dd>
<dt><strong>**other_kw</strong></dt><dd><p>Used internally. Any other keyword arguments will be ignored</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.apply_deadtime">
<span class="sig-name descname"><span class="pre">apply_deadtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deadtime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.apply_deadtime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.apply_deadtime" title="Link to this definition">¶</a></dt>
<dd><p>Apply deadtime filter to this event list.</p>
<p>Additional arguments in <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> are passed to <code class="xref py py-obj docutils literal notranslate"><span class="pre">get_deadtime_mask</span></code></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>deadtime</strong><span class="classifier">float</span></dt><dd><p>Value of dead time to apply to data</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, apply the deadtime to the current event list. Otherwise,
return a new event list.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>new_event_list</strong><span class="classifier"><a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EventList</span></code></a> object</span></dt><dd><p>Filtered event list. if <code class="xref py py-obj docutils literal notranslate"><span class="pre">inplace</span></code> is True, this is the input object
filtered for deadtime, otherwise this is a new object.</p>
</dd>
<dt><strong>additional_output</strong><span class="classifier">object</span></dt><dd><p>Only returned if <code class="xref py py-obj docutils literal notranslate"><span class="pre">return_all</span></code> is True. See <code class="xref py py-obj docutils literal notranslate"><span class="pre">get_deadtime_mask</span></code> for
more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">,</span> <span class="mf">1.07</span><span class="p">,</span> <span class="mf">1.08</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">events</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">gti</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">events</span><span class="o">.</span><span class="n">pi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">events</span><span class="o">.</span><span class="n">energy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">events</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt_events</span><span class="p">,</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">apply_deadtime</span><span class="p">(</span><span class="mf">0.11</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="gp">... </span>                                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="gp">... </span>                                            <span class="n">return_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">filt_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">events</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">filt_events</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">filt_events</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">filt_events</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt_events</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">apply_deadtime</span><span class="p">(</span><span class="mf">0.11</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">filt_events</span> <span class="ow">is</span> <span class="n">events</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.convert_pi_to_energy">
<span class="sig-name descname"><span class="pre">convert_pi_to_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rmf_file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.convert_pi_to_energy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.convert_pi_to_energy" title="Link to this definition">¶</a></dt>
<dd><p>Calibrate the energy column of the event list.</p>
<p>Defines the <code class="docutils literal notranslate"><span class="pre">energy</span></code> attribute of the event list by converting the
PI channels to energy using the provided RMF file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rmf_file</strong><span class="classifier">str</span></dt><dd><p>The file name of the RMF file to use for calibration.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.filter_energy_range">
<span class="sig-name descname"><span class="pre">filter_energy_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">energy_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_pi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.filter_energy_range"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.filter_energy_range" title="Link to this definition">¶</a></dt>
<dd><p>Filter the event list from a given energy range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>energy_range: [float, float]</strong></dt><dd><p>Energy range in keV, or in PI channel (if <code class="docutils literal notranslate"><span class="pre">use_pi</span></code> is True)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>Do the change in place (modify current event list). Otherwise, copy
to a new event list.</p>
</dd>
<dt><strong>use_pi</strong><span class="classifier">bool, default False</span></dt><dd><p>Use PI channel instead of energy in keV</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">events</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">energy</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">pi</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">filter_energy_range</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">e1</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e2</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">filter_energy_range</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">use_pi</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">e2</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.from_lc">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.from_lc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.from_lc" title="Link to this definition">¶</a></dt>
<dd><p>Create an <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> from a <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object. Note that all
events in a given time bin will have the same time stamp.</p>
<p>Bins with negative counts will be ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lc: :class:`stingray.Lightcurve` object</strong></dt><dd><p>Light curve to use for creation of the event list.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ev: <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> object</dt><dd><p>The resulting list of photon arrival times generated from the light curve.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.get_color_evolution">
<span class="sig-name descname"><span class="pre">get_color_evolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">energy_ranges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_pi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.get_color_evolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.get_color_evolution" title="Link to this definition">¶</a></dt>
<dd><p>Compute the color in equal-length segments of the event list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>energy_ranges</strong><span class="classifier">2x2 list</span></dt><dd><p>List of energy ranges to compute the color:
<code class="docutils literal notranslate"><span class="pre">[[en1_min,</span> <span class="pre">en1_max],</span> <span class="pre">[en2_min,</span> <span class="pre">en2_max]]</span></code></p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>Segment size in seconds. If None, the full GTIs are considered
instead as segments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>color</strong><span class="classifier">array-like</span></dt><dd><p>Array of colors, computed in each segment as the ratio of the
counts in the second energy range to the counts in the first energy
range.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>use_pi</strong><span class="classifier">bool, default False</span></dt><dd><p>Use PI channel instead of energy in keV</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.get_energy_mask">
<span class="sig-name descname"><span class="pre">get_energy_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">energy_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_pi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.get_energy_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.get_energy_mask" title="Link to this definition">¶</a></dt>
<dd><p>Get a mask corresponding to events with a given energy range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>energy_range: [float, float]</strong></dt><dd><p>Energy range in keV, or in PI channel (if <code class="docutils literal notranslate"><span class="pre">use_pi</span></code> is True)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>use_pi</strong><span class="classifier">bool, default False</span></dt><dd><p>Use PI channel instead of energy in keV</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.get_intensity_evolution">
<span class="sig-name descname"><span class="pre">get_intensity_evolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">energy_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_pi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.get_intensity_evolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.get_intensity_evolution" title="Link to this definition">¶</a></dt>
<dd><p>Compute the intensity in equal-length segments (or full GTIs) of the event list.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>energy_range</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[en1_min,</span> <span class="pre">en1_max]</span></code></span></dt><dd><p>Energy range to compute the intensity</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>Segment size in seconds. If None, the full GTIs are considered
instead as segments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>intensity</strong><span class="classifier">array-like</span></dt><dd><p>Array of intensities (in counts/s), computed in each segment.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>use_pi</strong><span class="classifier">bool, default False</span></dt><dd><p>Use PI channel instead of energy in keV</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'infer'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.join"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.join" title="Link to this definition">¶</a></dt>
<dd><p>Join two <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> objects into one.</p>
<p>If both are empty, an empty <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> is returned.</p>
<p>GTIs are crossed if the event lists are over a common time interval,
and appended otherwise.</p>
<p>Standard attributes such as <code class="docutils literal notranslate"><span class="pre">pi</span></code> and <code class="docutils literal notranslate"><span class="pre">energy</span></code> remain <code class="docutils literal notranslate"><span class="pre">None</span></code> if they are <code class="docutils literal notranslate"><span class="pre">None</span></code>
in both. Otherwise, <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> is used as a default value for the <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> where
they were None. Arbitrary attributes (e.g., Stokes parameters in polarimetric data) are
created and joined using the same convention.</p>
<p>Multiple checks are done on the joined event lists. If the time array of the event list
being joined is empty, it is ignored. If the time resolution is different, the final
event list will have the rougher time resolution. If the MJDREF is different, the time
reference will be changed to the one of the first event list. An empty event list will
be ignored.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> object or class:<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code></a> of <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> objects</span></dt><dd><p>The other <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> object which is supposed to be joined with.
If <code class="docutils literal notranslate"><span class="pre">other</span></code> is a list, it is assumed to be a list of <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> objects
and they are all joined, one by one.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>`ev_new`</strong><span class="classifier"><a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> object</span></dt><dd><p>The resulting <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>strategy</strong><span class="classifier">{“intersection”, “union”, “append”, “infer”, “none”}</span></dt><dd><p>Method to use to merge the GTIs. If “intersection”, the GTIs are merged
using the intersection of the GTIs. If “union”, the GTIs are merged
using the union of the GTIs. If “none”, a single GTI with the minimum and
the maximum time stamps of all GTIs is returned. If “infer”, the strategy
is decided based on the GTIs. If there are no overlaps, “union” is used,
otherwise “intersection” is used. If “append”, the GTIs are simply appended
but they must be mutually exclusive.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="stingray.events.EventList.ncounts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ncounts</span></span><a class="headerlink" href="#stingray.events.EventList.ncounts" title="Link to this definition">¶</a></dt>
<dd><p>Number of events in the event list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.read">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmf_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.read" title="Link to this definition">¶</a></dt>
<dd><p>Read a <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> object from file.</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>hea or ogip : FITS Event files from (well, some) HEASARC-supported missions.</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>Files that need the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> interface MUST contain
at least a <code class="docutils literal notranslate"><span class="pre">time</span></code> column. Other recognized columns are <code class="docutils literal notranslate"><span class="pre">energy</span></code> and
<code class="docutils literal notranslate"><span class="pre">pi</span></code>.
The default ascii format is enhanced CSV (ECSV). Data formats
supporting the serialization of metadata (such as ECSV and HDF5) can
contain all eventlist attributes such as <code class="docutils literal notranslate"><span class="pre">mission</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc with
no significant loss of information. Other file formats might lose part
of the metadata, so must be used with care.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Path and file name for the file to be read.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>Available options are ‘pickle’, ‘hea’, and any <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code>-supported
format such as ‘hdf5’, ‘ascii.ecsv’, etc.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ev: <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> object</dt><dd><p>The <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> object reconstructed from file</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rmf_file</strong><span class="classifier">str, default None</span></dt><dd><p>The file name of the RMF file to use for energy calibration. Defaults to
None, which implies no channel-&gt;energy conversion at this stage (or a default
calibration applied to selected missions).</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Any further keyword arguments to be passed to <code class="xref py py-obj docutils literal notranslate"><span class="pre">load_events_and_gtis</span></code>
for reading in event lists in OGIP/HEASOFT format</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.simulate_energies">
<span class="sig-name descname"><span class="pre">simulate_energies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_spline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.simulate_energies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.simulate_energies" title="Link to this definition">¶</a></dt>
<dd><p>Assign (simulate) energies to event list from a spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>spectrum: 2-d array or list [energies, spectrum]</strong></dt><dd><p>Energies versus corresponding fluxes. The 2-d array or list must
have energies across the first dimension and fluxes across the
second one. If the dimension of the energies is the same as
spectrum, they are interpreted as bin centers.
If it is longer by one, they are interpreted as proper bin edges
(similarly to the bins of <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.histogram</span></code>).
Note that for non-uniformly binned spectra, it is advisable to pass
the exact edges.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.simulate_times">
<span class="sig-name descname"><span class="pre">simulate_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_spline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.simulate_times"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.simulate_times" title="Link to this definition">¶</a></dt>
<dd><p>Simulate times from an input light curve.</p>
<p>Randomly simulate photon arrival times to an <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code></a> from a
<a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object, using the inverse CDF method.</p>
<dl class="simple">
<dt>..note::</dt><dd><p>Preferably use model light curves containing <strong>no Poisson noise</strong>,
as this method will intrinsically add Poisson noise to them.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lc: :class:`stingray.Lightcurve` object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>times</strong><span class="classifier">array-like</span></dt><dd><p>Simulated photon arrival times</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>use_spline</strong><span class="classifier">bool</span></dt><dd><p>Approximate the light curve with a spline to avoid binning effects</p>
</dd>
<dt><strong>bin_time</strong><span class="classifier">float default None</span></dt><dd><p>Ignored and deprecated, maintained for backwards compatibility.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.sort"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.sort" title="Link to this definition">¶</a></dt>
<dd><p>Sort the event list in time.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>eventlist</strong><span class="classifier"><a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EventList</span></code></a></span></dt><dd><p>The sorted event list. If <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>, it will be a shallow copy
of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>Sort in place. If False, return a new event list.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">events</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">energy</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="n">pi</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">e1</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">e1</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">e1</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
</pre></div>
</div>
<p>But the original event list has not been altered (<code class="docutils literal notranslate"><span class="pre">inplace=False</span></code> by
default):
&gt;&gt;&gt; assert np.allclose(events.time, [0, 2, 1])</p>
<p>Let’s do it in place instead
&gt;&gt;&gt; e2 = events.sort(inplace=True)
&gt;&gt;&gt; assert np.allclose(e2.time, [0, 1, 2])</p>
<p>In this case, the original event list has been altered.
&gt;&gt;&gt; assert np.allclose(events.time, [0, 1, 2])</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.to_binned_timeseries">
<span class="sig-name descname"><span class="pre">to_binned_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.to_binned_timeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.to_binned_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Convert the event list to a binned <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.StingrayTimeseries</span></code></a> object.</p>
<p>The result will be something similar to a light curve, but with arbitrary
attributes corresponding to a weighted sum of each specified attribute of
the event list.</p>
<p>E.g. if the event list has a <code class="docutils literal notranslate"><span class="pre">q</span></code> attribute, the final time series will
have a <code class="docutils literal notranslate"><span class="pre">q</span></code> attribute, which is the sum of all <code class="docutils literal notranslate"><span class="pre">q</span></code> values in each time bin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt: float</strong></dt><dd><p>Binning time of the light curve</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lc: <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object</dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>array_attrs: list of str</strong></dt><dd><p>List of attributes to be converted to light curve arrays. If None,
all array attributes will be converted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.to_lc">
<span class="sig-name descname"><span class="pre">to_lc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tseg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.to_lc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.to_lc" title="Link to this definition">¶</a></dt>
<dd><p>Convert event list to a <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt: float</strong></dt><dd><p>Binning time of the light curve</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lc: <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object</dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tstart</strong><span class="classifier">float</span></dt><dd><p>Start time of the light curve</p>
</dd>
<dt><strong>tseg: float</strong></dt><dd><p>Total duration of light curve</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.to_lc_iter">
<span class="sig-name descname"><span class="pre">to_lc_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.to_lc_iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.to_lc_iter" title="Link to this definition">¶</a></dt>
<dd><p>Convert event list to a generator of Lightcurves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt: float</strong></dt><dd><p>Binning time of the light curves</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lc_gen: <code class="xref py py-obj docutils literal notranslate"><span class="pre">generator</span></code></dt><dd><p>Generates one <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object for each GTI or segment</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float, default None</span></dt><dd><p>Optional segment size. If None, use the GTI boundaries</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.events.EventList.to_lc_list">
<span class="sig-name descname"><span class="pre">to_lc_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/events.html#EventList.to_lc_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.events.EventList.to_lc_list" title="Link to this definition">¶</a></dt>
<dd><p>Convert event list to a list of Lightcurves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt: float</strong></dt><dd><p>Binning time of the light curves</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lc_list: <code class="xref py py-obj docutils literal notranslate"><span class="pre">List</span></code></dt><dd><p>List containing one <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object for each GTI or segment</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float, default None</span></dt><dd><p>Optional segment size. If None, use the GTI boundaries</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<hr class="docutils" />
<section id="fourier-products">
<h2>Fourier Products<a class="headerlink" href="#fourier-products" title="Link to this heading">¶</a></h2>
<p>These classes implement commonly used Fourier analysis products, most importantly <code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">Powerspectrum</span></code>, along with the variants for averaged cross/power spectra.</p>
<section id="crossspectrum">
<h3>Crossspectrum<a class="headerlink" href="#crossspectrum" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.Crossspectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">Crossspectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum" title="Link to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.classical_significances">
<span class="sig-name descname"><span class="pre">classical_significances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.classical_significances"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.classical_significances" title="Link to this definition">¶</a></dt>
<dd><p>Compute the classical significances for the powers in the power
spectrum, assuming an underlying noise distribution that follows a
chi-square distributions with 2M degrees of freedom, where M is the
number of powers averaged in each bin.</p>
<p>Note that this function will <em>only</em> produce correct results when the
following underlying assumptions are fulfilled:</p>
<ol class="arabic simple">
<li><p>The power spectrum is Leahy-normalized</p></li>
<li><p>There is no source of variability in the data other than the
periodic signal to be determined with this method. This is important!
If there are other sources of (aperiodic) variability in the data, this
method will <em>not</em> produce correct results, but instead produce a large
number of spurious false positive detections!</p></li>
<li><p>There are no significant instrumental effects changing the
statistical distribution of the powers (e.g. pile-up or dead time)</p></li>
</ol>
<p>By default, the method produces <code class="docutils literal notranslate"><span class="pre">(index,p-values)</span></code> for all powers in
the power spectrum, where index is the numerical index of the power in
question. If a <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is set, then only powers with p-values
<em>below</em> that threshold with their respective indices. If
<code class="docutils literal notranslate"><span class="pre">trial_correction</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the threshold will be corrected
for the number of trials (frequencies) in the power spectrum before
being used.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>threshold</strong><span class="classifier">float, optional, default <code class="docutils literal notranslate"><span class="pre">1</span></code></span></dt><dd><p>The threshold to be used when reporting p-values of potentially
significant powers. Must be between 0 and 1.
Default is <code class="docutils literal notranslate"><span class="pre">1</span></code> (all p-values will be reported).</p>
</dd>
<dt><strong>trial_correction</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>A Boolean flag that sets whether the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> will be corrected
by the number of frequencies before being applied. This decreases
the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (p-values need to be lower to count as significant).
Default is <code class="docutils literal notranslate"><span class="pre">False</span></code> (report all powers) though for any application
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold`</span></code> is set to something meaningful, this should also
be applied!</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pvals</strong><span class="classifier">iterable</span></dt><dd><p>A list of <code class="docutils literal notranslate"><span class="pre">(index,</span> <span class="pre">p-value)</span></code> tuples for all powers that have p-values
lower than the threshold specified in <code class="docutils literal notranslate"><span class="pre">threshold</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.coherence">
<span class="sig-name descname"><span class="pre">coherence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.coherence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.coherence" title="Link to this definition">¶</a></dt>
<dd><p>Compute Coherence function of the cross spectrum.</p>
<p>Coherence is defined in Vaughan and Nowak, 1996 <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.
It is a Fourier frequency dependent measure of the linear correlation
between time series measured simultaneously in two energy channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coh</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Coherence function</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://iopscience.iop.org/article/10.1086/310430">https://iopscience.iop.org/article/10.1086/310430</a></p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.deadtime_correct">
<span class="sig-name descname"><span class="pre">deadtime_correct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dead_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paralyzable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.deadtime_correct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.deadtime_correct" title="Link to this definition">¶</a></dt>
<dd><p>Correct the power spectrum for dead time effects.</p>
<p>This correction is based on the formula given in Zhang et al. 2015, assuming
a constant dead time for all events.
For more advanced dead time corrections, see the FAD method from <a class="reference internal" href="#module-stingray.deadtime.fad" title="stingray.deadtime.fad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.deadtime.fad</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dead_time: float</strong></dt><dd><p>The dead time of the detector.</p>
</dd>
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>Detected source count rate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>spectrum: <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> or derivative.</dt><dd><p>The dead-time corrected spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>background_rate</strong><span class="classifier">float, default 0</span></dt><dd><p>Detected background count rate. This is important to estimate when deadtime is given by the
combination of the source counts and background counts (e.g. in an imaging X-ray detector).</p>
</dd>
<dt><strong>paralyzable: bool, default False</strong></dt><dd><p>If True, the dead time correction is done assuming a paralyzable
dead time. If False, the correction is done assuming a non-paralyzable
(more common) dead time.</p>
</dd>
<dt><strong>limit_k</strong><span class="classifier">int, default 200</span></dt><dd><p>Limit to this value the number of terms in the inner loops of
calculations. Check the plots returned by  the <code class="xref py py-obj docutils literal notranslate"><span class="pre">check_B</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">check_A</span></code> functions to test that this number is adequate.</p>
</dd>
<dt><strong>n_approx</strong><span class="classifier">int, default None</span></dt><dd><p>Number of bins to calculate the model power spectrum. If None, it will use the size of
the input frequency array. Relatively simple models (e.g., low count rates compared to
dead time) can use a smaller number of bins to speed up the calculation, and the final
power values will be interpolated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.from_events">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">events2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.from_events"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.from_events" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two event lists</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.EventList</span></code></span></dt><dd><p>Events from channel 1</p>
</dd>
<dt><strong>events2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.EventList</span></code></span></dt><dd><p>Events from channel 2</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.from_lc_iterable">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lc_iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iter_lc1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_lc2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.from_lc_iterable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.from_lc_iterable" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two light curves</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>iter_lc1</strong><span class="classifier">iterable of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects or <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Light curves from channel 1. If arrays, use them as counts</p>
</dd>
<dt><strong>iter_lc1</strong><span class="classifier">iterable of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects or <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Light curves from channel 2. If arrays, use them as counts</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, save the cross spectrum of each segment in the <code class="docutils literal notranslate"><span class="pre">cs_all</span></code>
attribute of the output <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.from_lightcurve">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lightcurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.from_lightcurve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.from_lightcurve" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two light curves</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lc1</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a></span></dt><dd><p>Light curve from channel 1</p>
</dd>
<dt><strong>lc2</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a></span></dt><dd><p>Light curve from channel 2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.from_stingray_timeseries">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_stingray_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux_attr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_flux_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.from_stingray_timeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.from_stingray_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two light curves</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ts1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Timeseries</span></code></span></dt><dd><p>Time series from channel 1</p>
</dd>
<dt><strong>ts2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Timeseries</span></code></span></dt><dd><p>Time series from channel 2</p>
</dd>
<dt><strong>flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>error_flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used as error bar.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.from_time_array">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_time_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.from_time_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.from_time_array" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two arrays of event times.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>times1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Event arrival times of channel 1</p>
</dd>
<dt><strong>times2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Event arrival times of channel 2</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for <a class="reference internal" href="#stingray.AveragedCrossspectrum" title="stingray.AveragedCrossspectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AveragedCrossspectrum</span></code></a>.</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti0, gti1], …]</span></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.initial_checks">
<span class="sig-name descname"><span class="pre">initial_checks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.initial_checks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.initial_checks" title="Link to this definition">¶</a></dt>
<dd><p>Run initial checks on the input.</p>
<p>Returns True if checks are passed, False if they are not.</p>
<p>Raises various errors for different bad inputs</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc1</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc2</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev1</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev2</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Crossspectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac</span> <span class="o">=</span> <span class="n">AveragedCrossspectrum</span><span class="p">()</span>
</pre></div>
</div>
<p>If norm is not a string, raise a TypeError
&gt;&gt;&gt; Crossspectrum.initial_checks(c, norm=1)
Traceback (most recent call last):
…
TypeError: norm must be a string…</p>
<p>If <code class="docutils literal notranslate"><span class="pre">norm</span></code> is not one of the valid norms, raise a ValueError
&gt;&gt;&gt; Crossspectrum.initial_checks(c, norm=”blabla”)
Traceback (most recent call last):
…
ValueError: norm must be ‘frac’…</p>
<p>If <code class="docutils literal notranslate"><span class="pre">power_type</span></code> is not one of the valid norms, raise a ValueError
&gt;&gt;&gt; Crossspectrum.initial_checks(c, power_type=”blabla”)
Traceback (most recent call last):
…
ValueError: <code class="xref py py-obj docutils literal notranslate"><span class="pre">power_type</span></code> not recognized!</p>
<p>If the user passes only one light curve, raise a ValueError</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Crossspectrum</span><span class="o">.</span><span class="n">initial_checks</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="n">lc1</span><span class="p">,</span> <span class="n">data2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">You can&#39;t do a cross spectrum...</span>
</pre></div>
</div>
<p>If the user passes an event list without dt, raise a ValueError</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Crossspectrum</span><span class="o">.</span><span class="n">initial_checks</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="n">ev1</span><span class="p">,</span> <span class="n">data2</span><span class="o">=</span><span class="n">ev2</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">If using event lists, please specify...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.phase_lag">
<span class="sig-name descname"><span class="pre">phase_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.phase_lag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.phase_lag" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the fourier phase lag of the cross spectrum.</p>
<p>This is defined as the argument of the complex cross spectrum, and gives
the delay at all frequencies, in cycles, of one input light curve with respect
to the other.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the amplitude of the cross spectrum vs. the frequency using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier">iterable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A list of tuple with <code class="docutils literal notranslate"><span class="pre">xlabel</span></code> and <code class="docutils literal notranslate"><span class="pre">ylabel</span></code> as strings.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for the``matplotlib.pyplot.axis()`` method.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The title of the plot.</p>
</dd>
<dt><strong>marker</strong><span class="classifier">str, default ‘-’</span></dt><dd><p>Line style and color of the plot. Line styles and colors are
combined in a single format string, as in <code class="docutils literal notranslate"><span class="pre">'bo'</span></code> for blue
circles. See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> for more options.</p>
</dd>
<dt><strong>save</strong><span class="classifier">boolean, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.Axes</span></code> object</span></dt><dd><p>An axes object to fill with the cross correlation plot.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.rebin">
<span class="sig-name descname"><span class="pre">rebin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.rebin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.rebin" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the cross spectrum to a new frequency resolution <code class="docutils literal notranslate"><span class="pre">df</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: float</strong></dt><dd><p>The new frequency resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>bin_cs = <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> (or one of its subclasses) object</dt><dd><p>The newly binned cross spectrum or power spectrum.
Note: this object will be of the same type as the object
that called this method. For example, if this method is called
from <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, it will return an object of class
<a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, too.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float</strong></dt><dd><p>the rebin factor. If specified, it substitutes df with <code class="docutils literal notranslate"><span class="pre">f*self.df</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.rebin_log">
<span class="sig-name descname"><span class="pre">rebin_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.rebin_log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.rebin_log" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic rebin of the periodogram.
The new frequency depends on the previous frequency
modified by a factor f:</p>
<div class="math notranslate nohighlight">
\[d\nu_j = d\nu_{j-1} (1+f)\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float, optional, default ``0.01``</strong></dt><dd><p>parameter that steers the frequency resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>new_spec</strong><span class="classifier"><a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> (or one of its subclasses) object</span></dt><dd><p>The newly binned cross spectrum or power spectrum.
Note: this object will be of the same type as the object
that called this method. For example, if this method is called
from <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, it will return an object of class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.time_lag">
<span class="sig-name descname"><span class="pre">time_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.time_lag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.time_lag" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the fourier time lag of the cross spectrum.
The time lag is calculated by taking the phase lag <span class="math notranslate nohighlight">\(\phi\)</span> and</p>
<p>..math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">tau</span> <span class="o">=</span> \<span class="n">frac</span><span class="p">{</span>\<span class="n">phi</span><span class="p">}{</span>\<span class="n">two</span> <span class="n">pi</span> \<span class="n">nu</span><span class="p">}</span>
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(\nu\)</span> is the center of the frequency bins.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Crossspectrum.to_norm">
<span class="sig-name descname"><span class="pre">to_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#Crossspectrum.to_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Crossspectrum.to_norm" title="Link to this definition">¶</a></dt>
<dd><p>Convert Cross spectrum to new normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">str</span></dt><dd><p>The new normalization of the spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_spec</strong><span class="classifier">object, same class as input</span></dt><dd><p>The new, normalized, spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace: bool, default False</strong></dt><dd><p>If True, change the current instance. Otherwise, return a new one</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="stingray.Crossspectrum.type">
<span class="sig-name descname"><span class="pre">type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'crossspectrum'</span></em><a class="headerlink" href="#stingray.Crossspectrum.type" title="Link to this definition">¶</a></dt>
<dd><p>Make a cross spectrum from a (binned) light curve.
You can also make an empty <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> object to populate with your
own Fourier-transformed data (this can sometimes be useful when making
binned power spectra). Stingray uses the scipy.fft standards for the sign
of the Nyquist frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data1: :class:`stingray.Lightcurve` or :class:`stingray.events.EventList`, optional, default ``None``</strong></dt><dd><p>The dataset for the first channel/band of interest.</p>
</dd>
<dt><strong>data2: :class:`stingray.Lightcurve` or :class:`stingray.events.EventList`, optional, default ``None``</strong></dt><dd><p>The dataset for the second, or “reference”, band.</p>
</dd>
<dt><strong>norm: {``frac``, ``abs``, ``leahy``, ``none``}, default ``none``</strong></dt><dd><p>The normalization of the (real part of the) cross spectrum.</p>
</dd>
<dt><strong>power_type: string, optional, default ``real``</strong></dt><dd><p>Parameter to choose among complete, real part and magnitude of the cross spectrum.</p>
</dd>
<dt><strong>fullspec: boolean, optional, default ``False``</strong></dt><dd><p>If False, keep only the positive frequencies, or if True, keep all of them .</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>freq: numpy.ndarray</strong></dt><dd><p>The array of mid-bin frequencies that the Fourier transform samples</p>
</dd>
<dt><strong>power: numpy.ndarray</strong></dt><dd><p>The array of cross spectra (complex numbers)</p>
</dd>
<dt><strong>power_err: numpy.ndarray</strong></dt><dd><p>The uncertainties of <code class="docutils literal notranslate"><span class="pre">power</span></code>.
An approximation for each bin given by <code class="docutils literal notranslate"><span class="pre">power_err=</span> <span class="pre">power/sqrt(m)</span></code>.
Where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the number of power averaged in each bin (by frequency
binning, or averaging more than one spectra). Note that for a single
realization (<code class="docutils literal notranslate"><span class="pre">m=1</span></code>) the error is equal to the power.</p>
</dd>
<dt><strong>df: float</strong></dt><dd><p>The frequency resolution</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>The number of averaged cross-spectra amplitudes in each bin.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>The number of data points/time bins in one segment of the light
curves.</p>
</dd>
<dt><strong>k: array of int</strong></dt><dd><p>The rebinning scheme if the object has been rebinned otherwise is set to 1.</p>
</dd>
<dt><strong>nphots1: float</strong></dt><dd><p>The total number of photons in light curve 1</p>
</dd>
<dt><strong>nphots2: float</strong></dt><dd><p>The total number of photons in light curve 2</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the input
<a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> GTIs! If you’re getting errors regarding your GTIs, don’t
use this and only give GTIs to the <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> objects before making
the cross spectrum.</p>
</dd>
<dt><strong>lc1: :class:`stingray.Lightcurve`object OR iterable of :class:`stingray.Lightcurve` objects</strong></dt><dd><p>For backwards compatibility only. Like <code class="docutils literal notranslate"><span class="pre">data1</span></code>, but no
<a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> objects allowed</p>
</dd>
<dt><strong>lc2: :class:`stingray.Lightcurve`object OR iterable of :class:`stingray.Lightcurve` objects</strong></dt><dd><p>For backwards compatibility only. Like <code class="docutils literal notranslate"><span class="pre">data2</span></code>, but no
<a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> objects allowed</p>
</dd>
<dt><strong>dt: float</strong></dt><dd><p>The time resolution of the light curve. Only needed when constructing
light curves in the case where <code class="docutils literal notranslate"><span class="pre">data1</span></code>, <code class="docutils literal notranslate"><span class="pre">data2</span></code> are
<code class="xref py py-class docutils literal notranslate"><span class="pre">EventList</span></code> objects</p>
</dd>
<dt><strong>skip_checks: bool</strong></dt><dd><p>Skip initial checks, for speed or other reasons (you need to trust your
inputs!)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="coherence">
<h3>Coherence<a class="headerlink" href="#coherence" title="Link to this heading">¶</a></h3>
<p>Convenience function to compute the coherence between two <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a>
objects.</p>
<dl class="py function">
<dt class="sig sig-object py" id="stingray.coherence">
<span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">coherence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#coherence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.coherence" title="Link to this definition">¶</a></dt>
<dd><p>Estimate coherence function of two light curves.
For details on the definition of the coherence, see Vaughan and Nowak,
1996 <a class="footnote-reference brackets" href="#id4" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lc1: :class:`stingray.Lightcurve` object</strong></dt><dd><p>The first light curve data for the channel of interest.</p>
</dd>
<dt><strong>lc2: :class:`stingray.Lightcurve` object</strong></dt><dd><p>The light curve data for reference band</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>coh</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code></span></dt><dd><p>The array of coherence versus frequency</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://iopscience.iop.org/article/10.1086/310430">https://iopscience.iop.org/article/10.1086/310430</a></p>
</aside>
</aside>
</dd></dl>

</section>
<hr class="docutils" />
<section id="powerspectrum">
<h3>Powerspectrum<a class="headerlink" href="#powerspectrum" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.Powerspectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">Powerspectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum" title="Link to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum._initialize_empty">
<span class="sig-name descname"><span class="pre">_initialize_empty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum._initialize_empty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum._initialize_empty" title="Link to this definition">¶</a></dt>
<dd><p>Set all attributes to None.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum._initialize_from_any_input">
<span class="sig-name descname"><span class="pre">_initialize_from_any_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum._initialize_from_any_input"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum._initialize_from_any_input" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the class, trying to understand the input types.</p>
<p>The input arguments are the same as <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>. Based on the type
of <code class="docutils literal notranslate"><span class="pre">data</span></code>, this method will call the appropriate
<code class="docutils literal notranslate"><span class="pre">powerspectrum_from_XXXX</span></code> function, and initialize <code class="docutils literal notranslate"><span class="pre">self</span></code> with
the correct attributes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum._normalize_crossspectrum">
<span class="sig-name descname"><span class="pre">_normalize_crossspectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unnorm_power</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum._normalize_crossspectrum" title="Link to this definition">¶</a></dt>
<dd><p>Normalize the real part of the cross spectrum to Leahy, absolute rms^2,
fractional rms^2 normalization, or not at all.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unnorm_power: numpy.ndarray</strong></dt><dd><p>The unnormalized cross spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>power: numpy.nd.array</dt><dd><p>The normalized co-spectrum (real part of the cross spectrum). For
‘none’ normalization, imaginary part is returned as well.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum._operation_with_other_obj">
<span class="sig-name descname"><span class="pre">_operation_with_other_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum._operation_with_other_obj" title="Link to this definition">¶</a></dt>
<dd><p>Helper method to codify an operation of one time series with another (e.g. add, subtract).
Takes into account the GTIs, and returns a new <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
<dt><strong>operation</strong><span class="classifier">function</span></dt><dd><p>An operation between the <a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object calling this method, and
<code class="docutils literal notranslate"><span class="pre">other</span></code>, operating on all the specified array attributes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ts_new</strong><span class="classifier">StingrayTimeseries object</span></dt><dd><p>The new time series calculated in <code class="docutils literal notranslate"><span class="pre">operation</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>The function used for error propagation. Defaults to the sum of squares.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum._rms_error">
<span class="sig-name descname"><span class="pre">_rms_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">powers</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum._rms_error"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum._rms_error" title="Link to this definition">¶</a></dt>
<dd><p>Compute the error on the fractional rms amplitude using error
propagation.
Note: this uses the actual measured powers, which is not
strictly correct. We should be using the underlying power spectrum,
but in the absence of an estimate of that, this will have to do.</p>
<div class="math notranslate nohighlight">
\[r = \sqrt{P}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\delta r = \\frac{1}{2 * \sqrt{P}} \delta P\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>powers: iterable</strong></dt><dd><p>The list of powers used to compute the fractional rms amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>delta_rms: float</dt><dd><p>The error on the fractional rms amplitude.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.add" title="Link to this definition">¶</a></dt>
<dd><p>Add two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances.</p>
<p>Add the array values of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming
the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.apply_mask">
<span class="sig-name descname"><span class="pre">apply_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">npt.ArrayLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtered_attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.apply_mask" title="Link to this definition">¶</a></dt>
<dd><p>Apply a mask to all array attributes of the object</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>mask</strong><span class="classifier">array of <code class="docutils literal notranslate"><span class="pre">bool</span></code></span></dt><dd><p>The mask. Has to be of the same length as <code class="docutils literal notranslate"><span class="pre">self.time</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ts_new</strong><span class="classifier">StingrayObject object</span></dt><dd><p>The new object with the mask applied if <code class="docutils literal notranslate"><span class="pre">inplace</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, otherwise the
same object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current object. Otherwise, return a new one.</p>
</dd>
<dt><strong>filtered_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be filtered. Defaults to all array attributes if <code class="docutils literal notranslate"><span class="pre">None</span></code>.
The other array attributes will be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>. The main array attr is always
included.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.array_attrs">
<span class="sig-name descname"><span class="pre">array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.Powerspectrum.array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the array attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.classical_significances">
<span class="sig-name descname"><span class="pre">classical_significances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum.classical_significances"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum.classical_significances" title="Link to this definition">¶</a></dt>
<dd><p>Compute the classical significances for the powers in the power
spectrum, assuming an underlying noise distribution that follows a
chi-square distributions with 2M degrees of freedom, where M is the
number of powers averaged in each bin.</p>
<p>Note that this function will <em>only</em> produce correct results when the
following underlying assumptions are fulfilled:</p>
<ol class="arabic simple">
<li><p>The power spectrum is Leahy-normalized</p></li>
<li><p>There is no source of variability in the data other than the
periodic signal to be determined with this method. This is
important! If there are other sources of (aperiodic) variability in
the data, this method will <em>not</em> produce correct results, but
instead produce a large number of spurious false positive
detections!</p></li>
<li><p>There are no significant instrumental effects changing the
statistical distribution of the powers (e.g. pile-up or dead time)</p></li>
</ol>
<p>By default, the method produces <code class="docutils literal notranslate"><span class="pre">(index,p-values)</span></code> for all powers in
the power spectrum, where index is the numerical index of the power in
question. If a <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is set, then only powers with p-values
<em>below</em> that threshold with their respective indices. If
<code class="docutils literal notranslate"><span class="pre">trial_correction</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the threshold will be
corrected for the number of trials (frequencies) in the power spectrum
before being used.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>threshold</strong><span class="classifier">float, optional, default <code class="docutils literal notranslate"><span class="pre">1</span></code></span></dt><dd><p>The threshold to be used when reporting p-values of potentially
significant powers. Must be between 0 and 1.
Default is <code class="docutils literal notranslate"><span class="pre">1</span></code> (all p-values will be reported).</p>
</dd>
<dt><strong>trial_correction</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>A Boolean flag that sets whether the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> will be
corrected by the number of frequencies before being applied. This
decreases the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (p-values need to be lower to count as
significant). Default is <code class="docutils literal notranslate"><span class="pre">False</span></code> (report all powers) though for
any application where <code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold`</span></code> is set to something meaningful,
this should also be applied!</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pvals</strong><span class="classifier">iterable</span></dt><dd><p>A list of <code class="docutils literal notranslate"><span class="pre">(p-value,</span> <span class="pre">index)</span></code> tuples for all powers that have
p-values lower than the threshold specified in <code class="docutils literal notranslate"><span class="pre">threshold</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.coherence">
<span class="sig-name descname"><span class="pre">coherence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.coherence" title="Link to this definition">¶</a></dt>
<dd><p>Compute Coherence function of the cross spectrum.</p>
<p>Coherence is defined in Vaughan and Nowak, 1996 <a class="footnote-reference brackets" href="#id6" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.
It is a Fourier frequency dependent measure of the linear correlation
between time series measured simultaneously in two energy channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coh</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Coherence function</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://iopscience.iop.org/article/10.1086/310430">https://iopscience.iop.org/article/10.1086/310430</a></p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.compute_rms">
<span class="sig-name descname"><span class="pre">compute_rms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poisson_noise_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum.compute_rms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum.compute_rms" title="Link to this definition">¶</a></dt>
<dd><p>Compute the fractional rms amplitude in the power spectrum
between two frequencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_freq: float</strong></dt><dd><p>The lower frequency bound for the calculation.</p>
</dd>
<dt><strong>max_freq: float</strong></dt><dd><p>The upper frequency bound for the calculation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>rms: float</dt><dd><p>The fractional rms amplitude contained between <code class="docutils literal notranslate"><span class="pre">min_freq</span></code> and
<code class="docutils literal notranslate"><span class="pre">max_freq</span></code>.</p>
</dd>
<dt>rms_err: float</dt><dd><p>The error on the fractional rms amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poisson_noise_level</strong><span class="classifier">float, default is None</span></dt><dd><p>This is the Poisson noise level of the PDS with same
normalization as the PDS. If poissoin_noise_level is None,
the Poisson noise is calculated in the idealcase
e.g. 2./&lt;countrate&gt; for fractional rms normalisation
Dead time and other instrumental effects can alter it.
The user can fit the Poisson noise level outside
this function using the same normalisation of the PDS
and it will get subtracted from powers here.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.data_attributes">
<span class="sig-name descname"><span class="pre">data_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.Powerspectrum.data_attributes" title="Link to this definition">¶</a></dt>
<dd><p>Clean up the list of attributes, only giving out those pointing to data.</p>
<p>List all the attributes that point directly to valid data. This method goes through all the
attributes of the class, eliminating methods, properties, and attributes that are complicated
to serialize such as other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code>, or arrays of objects.</p>
<p>This function does not make difference between array-like data and scalar data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data_attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of attributes pointing to data that are not methods, properties,
or other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code> instances.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.deadtime_correct">
<span class="sig-name descname"><span class="pre">deadtime_correct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dead_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paralyzable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.deadtime_correct" title="Link to this definition">¶</a></dt>
<dd><p>Correct the power spectrum for dead time effects.</p>
<p>This correction is based on the formula given in Zhang et al. 2015, assuming
a constant dead time for all events.
For more advanced dead time corrections, see the FAD method from <a class="reference internal" href="#module-stingray.deadtime.fad" title="stingray.deadtime.fad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.deadtime.fad</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dead_time: float</strong></dt><dd><p>The dead time of the detector.</p>
</dd>
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>Detected source count rate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>spectrum: <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> or derivative.</dt><dd><p>The dead-time corrected spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>background_rate</strong><span class="classifier">float, default 0</span></dt><dd><p>Detected background count rate. This is important to estimate when deadtime is given by the
combination of the source counts and background counts (e.g. in an imaging X-ray detector).</p>
</dd>
<dt><strong>paralyzable: bool, default False</strong></dt><dd><p>If True, the dead time correction is done assuming a paralyzable
dead time. If False, the correction is done assuming a non-paralyzable
(more common) dead time.</p>
</dd>
<dt><strong>limit_k</strong><span class="classifier">int, default 200</span></dt><dd><p>Limit to this value the number of terms in the inner loops of
calculations. Check the plots returned by  the <code class="xref py py-obj docutils literal notranslate"><span class="pre">check_B</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">check_A</span></code> functions to test that this number is adequate.</p>
</dd>
<dt><strong>n_approx</strong><span class="classifier">int, default None</span></dt><dd><p>Number of bins to calculate the model power spectrum. If None, it will use the size of
the input frequency array. Relatively simple models (e.g., low count rates compared to
dead time) can use a smaller number of bins to speed up the calculation, and the final
power values will be interpolated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.dict">
<span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.Powerspectrum.dict" title="Link to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.from_astropy_table">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Table</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.Powerspectrum.from_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create a Stingray Object object from data in an Astropy Table.</p>
<p>The table MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.from_events">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum.from_events"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum.from_events" title="Link to this definition">¶</a></dt>
<dd><p>Calculate an average power spectrum from an event list.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.EventList</span></code></span></dt><dd><p>Event list to be analyzed.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for
<code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code>.</p>
</dd>
<dt><strong>gti: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Additional, optional Good Time intervals that get intersected with
the GTIs of the input object. Can cause errors if there are
overlaps between these GTIs and the input object GTIs. If that
happens, assign the desired GTIs to the input object.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. <a class="reference external" href="https://docs.python.org/3/library/functions.html#abs" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a> is absolute rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">frac</span></code>
is fractional rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">leahy</span></code> is Leahy+83 normalization, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">none</span></code> is
the unnormalized periodogram.</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or
on the full light curve. This gives different results
(Alston+2013). By default, we assume the mean is calculated on the
full light curve, but the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False
to calculate it on a per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.from_lc_iterable">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lc_iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iter_lc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum.from_lc_iterable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum.from_lc_iterable" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the average power spectrum of an iterable collection of
light curves.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>iter_lc</strong><span class="classifier">iterable of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects or <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Light curves. If arrays, use them as counts.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for
<code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code>.</p>
</dd>
<dt><strong>gti: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Additional, optional Good Time intervals that get intersected with
the GTIs of the input object. Can cause errors if there are
overlaps between these GTIs and the input object GTIs. If that
happens, assign the desired GTIs to the input object.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. <a class="reference external" href="https://docs.python.org/3/library/functions.html#abs" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a> is absolute rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">frac</span></code>
is fractional rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">leahy</span></code> is Leahy+83 normalization, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">none</span></code> is
the unnormalized periodogram.</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or
on the full light curve. This gives different results
(Alston+2013). By default, we assume the mean is calculated on the
full light curve, but the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False
to calculate it on a per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.from_lightcurve">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lightcurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum.from_lightcurve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum.from_lightcurve" title="Link to this definition">¶</a></dt>
<dd><p>Calculate a power spectrum from a light curve.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a></span></dt><dd><p>Light curve to be analyzed.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for
<code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code>.</p>
</dd>
<dt><strong>gti: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Additional, optional Good Time intervals that get intersected with
the GTIs of the input object. Can cause errors if there are
overlaps between these GTIs and the input object GTIs. If that
happens, assign the desired GTIs to the input object.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. <a class="reference external" href="https://docs.python.org/3/library/functions.html#abs" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a> is absolute rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">frac</span></code>
is fractional rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">leahy</span></code> is Leahy+83 normalization, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">none</span></code> is
the unnormalized periodogram.</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or
on the full light curve. This gives different results
(Alston+2013). By default, we assume the mean is calculated on the
full light curve, but the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False
to calculate it on a per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.from_pandas">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">DataFrame</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.Powerspectrum.from_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create an <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object from data in a pandas DataFrame.</p>
<p>The dataframe MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays can be
specified as <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_1d_arrays_into_nd</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.from_stingray_timeseries">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_stingray_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux_attr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_flux_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum.from_stingray_timeseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum.from_stingray_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedPowerspectrum from a time series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ts</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Timeseries</span></code></span></dt><dd><p>Input Time Series</p>
</dd>
<dt><strong>flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>error_flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used as error bar.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.from_time_array">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_time_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum.from_time_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum.from_time_array" title="Link to this definition">¶</a></dt>
<dd><p>Calculate an average power spectrum from an array of event times.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>times</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Event arrival times.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for
<code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code>.</p>
</dd>
<dt><strong>gti: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Additional, optional Good Time intervals that get intersected with
the GTIs of the input object. Can cause errors if there are
overlaps between these GTIs and the input object GTIs. If that
happens, assign the desired GTIs to the input object.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. <a class="reference external" href="https://docs.python.org/3/library/functions.html#abs" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a> is absolute rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">frac</span></code>
is fractional rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">leahy</span></code> is Leahy+83 normalization, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">none</span></code> is
the unnormalized periodogram.</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or
on the full light curve. This gives different results
(Alston+2013). By default, we assume the mean is calculated on the
full light curve, but the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False
to calculate it on a per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.from_xarray">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_xarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dataset</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.Powerspectrum.from_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> from data in an xarray Dataset.</p>
<p>The dataset MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.get_meta_dict">
<span class="sig-name descname"><span class="pre">get_meta_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.Powerspectrum.get_meta_dict" title="Link to this definition">¶</a></dt>
<dd><p>Give a dictionary with all non-None meta attrs of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.initial_checks">
<span class="sig-name descname"><span class="pre">initial_checks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.initial_checks" title="Link to this definition">¶</a></dt>
<dd><p>Run initial checks on the input.</p>
<p>Returns True if checks are passed, False if they are not.</p>
<p>Raises various errors for different bad inputs</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc1</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc2</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev1</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev2</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Crossspectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac</span> <span class="o">=</span> <span class="n">AveragedCrossspectrum</span><span class="p">()</span>
</pre></div>
</div>
<p>If norm is not a string, raise a TypeError
&gt;&gt;&gt; Crossspectrum.initial_checks(c, norm=1)
Traceback (most recent call last):
…
TypeError: norm must be a string…</p>
<p>If <code class="docutils literal notranslate"><span class="pre">norm</span></code> is not one of the valid norms, raise a ValueError
&gt;&gt;&gt; Crossspectrum.initial_checks(c, norm=”blabla”)
Traceback (most recent call last):
…
ValueError: norm must be ‘frac’…</p>
<p>If <code class="docutils literal notranslate"><span class="pre">power_type</span></code> is not one of the valid norms, raise a ValueError
&gt;&gt;&gt; Crossspectrum.initial_checks(c, power_type=”blabla”)
Traceback (most recent call last):
…
ValueError: <code class="xref py py-obj docutils literal notranslate"><span class="pre">power_type</span></code> not recognized!</p>
<p>If the user passes only one light curve, raise a ValueError</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Crossspectrum</span><span class="o">.</span><span class="n">initial_checks</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="n">lc1</span><span class="p">,</span> <span class="n">data2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">You can&#39;t do a cross spectrum...</span>
</pre></div>
</div>
<p>If the user passes an event list without dt, raise a ValueError</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Crossspectrum</span><span class="o">.</span><span class="n">initial_checks</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="n">ev1</span><span class="p">,</span> <span class="n">data2</span><span class="o">=</span><span class="n">ev2</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">If using event lists, please specify...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.internal_array_attrs">
<span class="sig-name descname"><span class="pre">internal_array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.Powerspectrum.internal_array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the internal array attributes of the Stingray Object.</p>
<p>These are array attributes that can be set by properties, and are generally indicated
by an underscore followed by the name of the property that links to it (E.g.
<code class="docutils literal notranslate"><span class="pre">_counts</span></code> in <code class="docutils literal notranslate"><span class="pre">Lightcurve</span></code>).
By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of internal array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.meta_attrs">
<span class="sig-name descname"><span class="pre">meta_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.Powerspectrum.meta_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the meta attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with a different size and shape
than <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of meta attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.modulation_upper_limit">
<span class="sig-name descname"><span class="pre">modulation_upper_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum.modulation_upper_limit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum.modulation_upper_limit" title="Link to this definition">¶</a></dt>
<dd><p>Upper limit on a sinusoidal modulation.</p>
<p>To understand the meaning of this amplitude: if the modulation is
described by:</p>
<p>..math:: p = overline{p} (1 + a * sin(x))</p>
<p>this function returns a.</p>
<p>If it is a sum of sinusoidal harmonics instead
..math:: p = overline{p} (1 + sum_l a_l * sin(lx))
a is equivalent to <span class="math notranslate nohighlight">\(\sqrt(\sum_l a_l^2)\)</span>.</p>
<p>See <a class="reference internal" href="#stingray.stats.power_upper_limit" title="stingray.stats.power_upper_limit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.stats.power_upper_limit</span></code></a>,
<a class="reference internal" href="#stingray.stats.amplitude_upper_limit" title="stingray.stats.amplitude_upper_limit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.stats.amplitude_upper_limit</span></code></a>
for more information.</p>
<p>The formula used to calculate the upper limit assumes the Leahy
normalization.
If the periodogram is in another normalization, we will internally
convert it to Leahy before calculating the upper limit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fmin: float</strong></dt><dd><p>The minimum frequency to search (defaults to the first nonzero bin)</p>
</dd>
<dt><strong>fmax: float</strong></dt><dd><p>The maximum frequency to search (defaults to the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>a: float</dt><dd><p>The modulation amplitude that could produce P&gt;pmeas with 1 - c
probability.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c: float</strong></dt><dd><p>The confidence value for the upper limit (e.g. 0.95 = 95%)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span> <span class="o">=</span> <span class="n">Powerspectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="s2">&quot;leahy&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note: this pds has 40 as maximum value between 2 and 5 Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">100000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">nphots</span> <span class="o">=</span> <span class="mi">30000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pds</span><span class="o">.</span><span class="n">modulation_upper_limit</span><span class="p">(</span><span class="n">fmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.99</span><span class="p">),</span>
<span class="gp">... </span>    <span class="mf">0.10164</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">atol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.phase_lag">
<span class="sig-name descname"><span class="pre">phase_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.phase_lag" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the fourier phase lag of the cross spectrum.</p>
<p>This is defined as the argument of the complex cross spectrum, and gives
the delay at all frequencies, in cycles, of one input light curve with respect
to the other.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the amplitude of the cross spectrum vs. the frequency using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier">iterable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A list of tuple with <code class="docutils literal notranslate"><span class="pre">xlabel</span></code> and <code class="docutils literal notranslate"><span class="pre">ylabel</span></code> as strings.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for the``matplotlib.pyplot.axis()`` method.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The title of the plot.</p>
</dd>
<dt><strong>marker</strong><span class="classifier">str, default ‘-’</span></dt><dd><p>Line style and color of the plot. Line styles and colors are
combined in a single format string, as in <code class="docutils literal notranslate"><span class="pre">'bo'</span></code> for blue
circles. See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> for more options.</p>
</dd>
<dt><strong>save</strong><span class="classifier">boolean, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.Axes</span></code> object</span></dt><dd><p>An axes object to fill with the cross correlation plot.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.pretty_print">
<span class="sig-name descname"><span class="pre">pretty_print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></span><a class="headerlink" href="#stingray.Powerspectrum.pretty_print" title="Link to this definition">¶</a></dt>
<dd><p>Return a pretty-printed string representation of the object.</p>
<p>This is useful for debugging, and for interactive use.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func_to_apply</strong><span class="classifier">function</span></dt><dd><p>A function that modifies the attributes listed in <code class="docutils literal notranslate"><span class="pre">attrs_to_apply</span></code>.
It must return the modified attributes and a label to be printed.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no function is applied.</p>
</dd>
<dt><strong>attrs_to_apply</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be modified by <code class="docutils literal notranslate"><span class="pre">func_to_apply</span></code>.</p>
</dd>
<dt><strong>attrs_to_discard</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be discarded from the output.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.read">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.Powerspectrum.read" title="Link to this definition">¶</a></dt>
<dd><p>Generic reader for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>Files that need the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> interface MUST contain
at least a column named like the <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The default ascii format is enhanced CSV (ECSV). Data formats
supporting the serialization of metadata (such as ECSV and HDF5) can
contain all attributes such as <code class="docutils literal notranslate"><span class="pre">mission</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc with
no significant loss of information. Other file formats might lose part
of the metadata, so must be used with care.</p>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values should be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Path and file name for the file to be read.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>Available options are ‘pickle’, ‘hea’, and any <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code>-supported
format such as ‘hdf5’, ‘ascii.ecsv’, etc.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>obj: <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object</dt><dd><p>The object reconstructed from file</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.rebin">
<span class="sig-name descname"><span class="pre">rebin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#Powerspectrum.rebin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Powerspectrum.rebin" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the power spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: float</strong></dt><dd><p>The new frequency resolution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>bin_cs = <a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Powerspectrum</span></code></a> object</dt><dd><p>The newly binned power spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float</strong></dt><dd><p>The rebin factor. If specified, it substitutes <code class="docutils literal notranslate"><span class="pre">df</span></code> with
<code class="docutils literal notranslate"><span class="pre">f*self.df</span></code>, so <code class="docutils literal notranslate"><span class="pre">f&gt;1</span></code> is recommended.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.rebin_log">
<span class="sig-name descname"><span class="pre">rebin_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.rebin_log" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic rebin of the periodogram.
The new frequency depends on the previous frequency
modified by a factor f:</p>
<div class="math notranslate nohighlight">
\[d\nu_j = d\nu_{j-1} (1+f)\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float, optional, default ``0.01``</strong></dt><dd><p>parameter that steers the frequency resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>new_spec</strong><span class="classifier"><a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> (or one of its subclasses) object</span></dt><dd><p>The newly binned cross spectrum or power spectrum.
Note: this object will be of the same type as the object
that called this method. For example, if this method is called
from <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, it will return an object of class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.sub" title="Link to this definition">¶</a></dt>
<dd><p>Subtract <em>all the array attrs</em> of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.time_lag">
<span class="sig-name descname"><span class="pre">time_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.time_lag" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the fourier time lag of the cross spectrum.
The time lag is calculated by taking the phase lag <span class="math notranslate nohighlight">\(\phi\)</span> and</p>
<p>..math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">tau</span> <span class="o">=</span> \<span class="n">frac</span><span class="p">{</span>\<span class="n">phi</span><span class="p">}{</span>\<span class="n">two</span> <span class="n">pi</span> \<span class="n">nu</span><span class="p">}</span>
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(\nu\)</span> is the center of the frequency bins.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.to_astropy_table">
<span class="sig-name descname"><span class="pre">to_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">no_longdouble</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><span class="pre">Table</span></a></span></span><a class="headerlink" href="#stingray.Powerspectrum.to_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create an Astropy Table from a <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code></p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">meta</span></code> dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>no_longdouble</strong><span class="classifier">bool</span></dt><dd><p>If True, reduce the precision of longdouble arrays to double precision.
This needs to be done in some cases, e.g. when the table is to be saved
in an architecture not supporting extended precision (e.g. ARM), but can
also be useful when an extended precision is not needed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.to_norm">
<span class="sig-name descname"><span class="pre">to_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.Powerspectrum.to_norm" title="Link to this definition">¶</a></dt>
<dd><p>Convert Cross spectrum to new normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">str</span></dt><dd><p>The new normalization of the spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_spec</strong><span class="classifier">object, same class as input</span></dt><dd><p>The new, normalized, spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace: bool, default False</strong></dt><dd><p>If True, change the current instance. Otherwise, return a new one</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.to_pandas">
<span class="sig-name descname"><span class="pre">to_pandas</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#stingray.Powerspectrum.to_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays are
converted into columns before the conversion, with names <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_nd_into_arrays</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.to_xarray">
<span class="sig-name descname"><span class="pre">to_xarray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dataset</span></span></span><a class="headerlink" href="#stingray.Powerspectrum.to_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create an <code class="docutils literal notranslate"><span class="pre">xarray</span></code> Dataset from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="stingray.Powerspectrum.type">
<span class="sig-name descname"><span class="pre">type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'powerspectrum'</span></em><a class="headerlink" href="#stingray.Powerspectrum.type" title="Link to this definition">¶</a></dt>
<dd><p>Make a <a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Powerspectrum</span></code></a> (also called periodogram) from a (binned)
light curve. Periodograms can be normalized by either Leahy normalization,
fractional rms normalization, absolute rms normalization, or not at all.</p>
<p>You can also make an empty <a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Powerspectrum</span></code></a> object to populate with
your own fourier-transformed data (this can sometimes be useful when making
binned power spectra).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data: :class:`stingray.Lightcurve` object, optional, default ``None``</strong></dt><dd><p>The light curve data to be Fourier-transformed.</p>
</dd>
<dt><strong>norm: {“leahy” | “frac” | “abs” | “none” }, optional, default “frac”</strong></dt><dd><p>The normaliation of the power spectrum to be used. Options are
“leahy”, “frac”, “abs” and “none”, default is “frac”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>norm: {“leahy” | “frac” | “abs” | “none” }</strong></dt><dd><p>The normalization of the power spectrum.</p>
</dd>
<dt><strong>freq: numpy.ndarray</strong></dt><dd><p>The array of mid-bin frequencies that the Fourier transform samples.</p>
</dd>
<dt><strong>power: numpy.ndarray</strong></dt><dd><p>The array of normalized squared absolute values of Fourier
amplitudes.</p>
</dd>
<dt><strong>power_err: numpy.ndarray</strong></dt><dd><p>The uncertainties of <code class="docutils literal notranslate"><span class="pre">power</span></code>.
An approximation for each bin given by <code class="docutils literal notranslate"><span class="pre">power_err=</span> <span class="pre">power/sqrt(m)</span></code>.
Where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the number of power averaged in each bin (by frequency
binning, or averaging power spectra of segments of a light curve).
Note that for a single realization (<code class="docutils literal notranslate"><span class="pre">m=1</span></code>) the error is equal to the
power.</p>
</dd>
<dt><strong>unnorm_power: numpy.ndarray</strong></dt><dd><p>The array of unnormalized powers</p>
</dd>
<dt><strong>unnorm_power_err: numpy.ndarray</strong></dt><dd><p>The uncertainties of <code class="docutils literal notranslate"><span class="pre">unnorm_power</span></code>.</p>
</dd>
<dt><strong>df: float</strong></dt><dd><p>The frequency resolution.</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>The number of averaged powers in each bin.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>The number of data points in the light curve.</p>
</dd>
<dt><strong>nphots: float</strong></dt><dd><p>The total number of photons in the light curve.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti: 2-d float array</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code> – Good Time intervals.
This choice overrides the GTIs in the single light curves. Use with
care, especially if these GTIs have overlaps with the input
object GTIs! If you’re getting errors regarding your GTIs, don’t
use this and only give GTIs to the input object before making
the power spectrum.</p>
</dd>
<dt><strong>skip_checks: bool</strong></dt><dd><p>Skip initial checks, for speed or other reasons (you need to trust your
inputs!).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.Powerspectrum.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span></span><a class="headerlink" href="#stingray.Powerspectrum.write" title="Link to this definition">¶</a></dt>
<dd><p>Generic writer for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values will be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Name and path of the file to save the object list to.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>The file format to store the data in.
Available options are <code class="docutils literal notranslate"><span class="pre">pickle</span></code>, <code class="docutils literal notranslate"><span class="pre">hdf5</span></code>, <code class="docutils literal notranslate"><span class="pre">ascii</span></code>, <code class="docutils literal notranslate"><span class="pre">fits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="averagedcrossspectrum">
<h3>AveragedCrossspectrum<a class="headerlink" href="#averagedcrossspectrum" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">AveragedCrossspectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#AveragedCrossspectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.AveragedCrossspectrum" title="Link to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.add" title="Link to this definition">¶</a></dt>
<dd><p>Add two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances.</p>
<p>Add the array values of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming
the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.apply_mask">
<span class="sig-name descname"><span class="pre">apply_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">npt.ArrayLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtered_attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.apply_mask" title="Link to this definition">¶</a></dt>
<dd><p>Apply a mask to all array attributes of the object</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>mask</strong><span class="classifier">array of <code class="docutils literal notranslate"><span class="pre">bool</span></code></span></dt><dd><p>The mask. Has to be of the same length as <code class="docutils literal notranslate"><span class="pre">self.time</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ts_new</strong><span class="classifier">StingrayObject object</span></dt><dd><p>The new object with the mask applied if <code class="docutils literal notranslate"><span class="pre">inplace</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, otherwise the
same object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current object. Otherwise, return a new one.</p>
</dd>
<dt><strong>filtered_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be filtered. Defaults to all array attributes if <code class="docutils literal notranslate"><span class="pre">None</span></code>.
The other array attributes will be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>. The main array attr is always
included.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.array_attrs">
<span class="sig-name descname"><span class="pre">array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the array attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.classical_significances">
<span class="sig-name descname"><span class="pre">classical_significances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.classical_significances" title="Link to this definition">¶</a></dt>
<dd><p>Compute the classical significances for the powers in the power
spectrum, assuming an underlying noise distribution that follows a
chi-square distributions with 2M degrees of freedom, where M is the
number of powers averaged in each bin.</p>
<p>Note that this function will <em>only</em> produce correct results when the
following underlying assumptions are fulfilled:</p>
<ol class="arabic simple">
<li><p>The power spectrum is Leahy-normalized</p></li>
<li><p>There is no source of variability in the data other than the
periodic signal to be determined with this method. This is important!
If there are other sources of (aperiodic) variability in the data, this
method will <em>not</em> produce correct results, but instead produce a large
number of spurious false positive detections!</p></li>
<li><p>There are no significant instrumental effects changing the
statistical distribution of the powers (e.g. pile-up or dead time)</p></li>
</ol>
<p>By default, the method produces <code class="docutils literal notranslate"><span class="pre">(index,p-values)</span></code> for all powers in
the power spectrum, where index is the numerical index of the power in
question. If a <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is set, then only powers with p-values
<em>below</em> that threshold with their respective indices. If
<code class="docutils literal notranslate"><span class="pre">trial_correction</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the threshold will be corrected
for the number of trials (frequencies) in the power spectrum before
being used.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>threshold</strong><span class="classifier">float, optional, default <code class="docutils literal notranslate"><span class="pre">1</span></code></span></dt><dd><p>The threshold to be used when reporting p-values of potentially
significant powers. Must be between 0 and 1.
Default is <code class="docutils literal notranslate"><span class="pre">1</span></code> (all p-values will be reported).</p>
</dd>
<dt><strong>trial_correction</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>A Boolean flag that sets whether the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> will be corrected
by the number of frequencies before being applied. This decreases
the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (p-values need to be lower to count as significant).
Default is <code class="docutils literal notranslate"><span class="pre">False</span></code> (report all powers) though for any application
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold`</span></code> is set to something meaningful, this should also
be applied!</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pvals</strong><span class="classifier">iterable</span></dt><dd><p>A list of <code class="docutils literal notranslate"><span class="pre">(index,</span> <span class="pre">p-value)</span></code> tuples for all powers that have p-values
lower than the threshold specified in <code class="docutils literal notranslate"><span class="pre">threshold</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.coherence">
<span class="sig-name descname"><span class="pre">coherence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#AveragedCrossspectrum.coherence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.AveragedCrossspectrum.coherence" title="Link to this definition">¶</a></dt>
<dd><p>Averaged Coherence function.</p>
<p>Coherence is defined in Vaughan and Nowak, 1996 <a class="footnote-reference brackets" href="#id8" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.
It is a Fourier frequency dependent measure of the linear correlation
between time series measured simultaneously in two energy channels.</p>
<p>Compute an averaged Coherence function of cross spectrum by computing
coherence function of each segment and averaging them. The return type
is a tuple with first element as the coherence function and the second
element as the corresponding uncertainty associated with it.</p>
<p>Note : The uncertainty in coherence function is strictly valid for Gaussian                statistics only.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>(coh, uncertainty)</strong><span class="classifier">tuple of np.ndarray</span></dt><dd><p>Tuple comprising the coherence function and uncertainty.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://iopscience.iop.org/article/10.1086/310430">https://iopscience.iop.org/article/10.1086/310430</a></p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.data_attributes">
<span class="sig-name descname"><span class="pre">data_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.data_attributes" title="Link to this definition">¶</a></dt>
<dd><p>Clean up the list of attributes, only giving out those pointing to data.</p>
<p>List all the attributes that point directly to valid data. This method goes through all the
attributes of the class, eliminating methods, properties, and attributes that are complicated
to serialize such as other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code>, or arrays of objects.</p>
<p>This function does not make difference between array-like data and scalar data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data_attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of attributes pointing to data that are not methods, properties,
or other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code> instances.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.deadtime_correct">
<span class="sig-name descname"><span class="pre">deadtime_correct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dead_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paralyzable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.deadtime_correct" title="Link to this definition">¶</a></dt>
<dd><p>Correct the power spectrum for dead time effects.</p>
<p>This correction is based on the formula given in Zhang et al. 2015, assuming
a constant dead time for all events.
For more advanced dead time corrections, see the FAD method from <a class="reference internal" href="#module-stingray.deadtime.fad" title="stingray.deadtime.fad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.deadtime.fad</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dead_time: float</strong></dt><dd><p>The dead time of the detector.</p>
</dd>
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>Detected source count rate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>spectrum: <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> or derivative.</dt><dd><p>The dead-time corrected spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>background_rate</strong><span class="classifier">float, default 0</span></dt><dd><p>Detected background count rate. This is important to estimate when deadtime is given by the
combination of the source counts and background counts (e.g. in an imaging X-ray detector).</p>
</dd>
<dt><strong>paralyzable: bool, default False</strong></dt><dd><p>If True, the dead time correction is done assuming a paralyzable
dead time. If False, the correction is done assuming a non-paralyzable
(more common) dead time.</p>
</dd>
<dt><strong>limit_k</strong><span class="classifier">int, default 200</span></dt><dd><p>Limit to this value the number of terms in the inner loops of
calculations. Check the plots returned by  the <code class="xref py py-obj docutils literal notranslate"><span class="pre">check_B</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">check_A</span></code> functions to test that this number is adequate.</p>
</dd>
<dt><strong>n_approx</strong><span class="classifier">int, default None</span></dt><dd><p>Number of bins to calculate the model power spectrum. If None, it will use the size of
the input frequency array. Relatively simple models (e.g., low count rates compared to
dead time) can use a smaller number of bins to speed up the calculation, and the final
power values will be interpolated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.dict">
<span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.dict" title="Link to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.from_astropy_table">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Table</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.from_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create a Stingray Object object from data in an Astropy Table.</p>
<p>The table MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.from_events">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">events2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.from_events" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two event lists</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.EventList</span></code></span></dt><dd><p>Events from channel 1</p>
</dd>
<dt><strong>events2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.EventList</span></code></span></dt><dd><p>Events from channel 2</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.from_lc_iterable">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lc_iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iter_lc1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_lc2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.from_lc_iterable" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two light curves</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>iter_lc1</strong><span class="classifier">iterable of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects or <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Light curves from channel 1. If arrays, use them as counts</p>
</dd>
<dt><strong>iter_lc1</strong><span class="classifier">iterable of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects or <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Light curves from channel 2. If arrays, use them as counts</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, save the cross spectrum of each segment in the <code class="docutils literal notranslate"><span class="pre">cs_all</span></code>
attribute of the output <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.from_lightcurve">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lightcurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.from_lightcurve" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two light curves</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lc1</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a></span></dt><dd><p>Light curve from channel 1</p>
</dd>
<dt><strong>lc2</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a></span></dt><dd><p>Light curve from channel 2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.from_pandas">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">DataFrame</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.from_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create an <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object from data in a pandas DataFrame.</p>
<p>The dataframe MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays can be
specified as <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_1d_arrays_into_nd</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.from_stingray_timeseries">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_stingray_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux_attr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_flux_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.from_stingray_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two light curves</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ts1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Timeseries</span></code></span></dt><dd><p>Time series from channel 1</p>
</dd>
<dt><strong>ts2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Timeseries</span></code></span></dt><dd><p>Time series from channel 2</p>
</dd>
<dt><strong>flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>error_flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used as error bar.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.from_time_array">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_time_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.from_time_array" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two arrays of event times.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>times1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Event arrival times of channel 1</p>
</dd>
<dt><strong>times2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Event arrival times of channel 2</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for <a class="reference internal" href="#stingray.AveragedCrossspectrum" title="stingray.AveragedCrossspectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AveragedCrossspectrum</span></code></a>.</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti0, gti1], …]</span></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.from_xarray">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_xarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dataset</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.from_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> from data in an xarray Dataset.</p>
<p>The dataset MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.get_meta_dict">
<span class="sig-name descname"><span class="pre">get_meta_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.get_meta_dict" title="Link to this definition">¶</a></dt>
<dd><p>Give a dictionary with all non-None meta attrs of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.initial_checks">
<span class="sig-name descname"><span class="pre">initial_checks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#AveragedCrossspectrum.initial_checks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.AveragedCrossspectrum.initial_checks" title="Link to this definition">¶</a></dt>
<dd><p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev1</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev2</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac</span> <span class="o">=</span> <span class="n">AveragedCrossspectrum</span><span class="p">()</span>
</pre></div>
</div>
<p>If AveragedCrossspectrum, you need <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>
&gt;&gt;&gt; AveragedCrossspectrum.initial_checks(ac, data1=ev1, data2=ev2, dt=1)
Traceback (most recent call last):
…
ValueError: segment_size must be specified…</p>
<p>And it needs to be finite!
&gt;&gt;&gt; AveragedCrossspectrum.initial_checks(ac, data1=ev1, data2=ev2, dt=1., segment_size=np.nan)
Traceback (most recent call last):
…
ValueError: segment_size must be finite!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.internal_array_attrs">
<span class="sig-name descname"><span class="pre">internal_array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.internal_array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the internal array attributes of the Stingray Object.</p>
<p>These are array attributes that can be set by properties, and are generally indicated
by an underscore followed by the name of the property that links to it (E.g.
<code class="docutils literal notranslate"><span class="pre">_counts</span></code> in <code class="docutils literal notranslate"><span class="pre">Lightcurve</span></code>).
By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of internal array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.meta_attrs">
<span class="sig-name descname"><span class="pre">meta_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.meta_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the meta attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with a different size and shape
than <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of meta attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.phase_lag">
<span class="sig-name descname"><span class="pre">phase_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#AveragedCrossspectrum.phase_lag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.AveragedCrossspectrum.phase_lag" title="Link to this definition">¶</a></dt>
<dd><p>Return the fourier phase lag of the cross spectrum.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the amplitude of the cross spectrum vs. the frequency using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier">iterable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A list of tuple with <code class="docutils literal notranslate"><span class="pre">xlabel</span></code> and <code class="docutils literal notranslate"><span class="pre">ylabel</span></code> as strings.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for the``matplotlib.pyplot.axis()`` method.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The title of the plot.</p>
</dd>
<dt><strong>marker</strong><span class="classifier">str, default ‘-’</span></dt><dd><p>Line style and color of the plot. Line styles and colors are
combined in a single format string, as in <code class="docutils literal notranslate"><span class="pre">'bo'</span></code> for blue
circles. See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> for more options.</p>
</dd>
<dt><strong>save</strong><span class="classifier">boolean, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.Axes</span></code> object</span></dt><dd><p>An axes object to fill with the cross correlation plot.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.pretty_print">
<span class="sig-name descname"><span class="pre">pretty_print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.pretty_print" title="Link to this definition">¶</a></dt>
<dd><p>Return a pretty-printed string representation of the object.</p>
<p>This is useful for debugging, and for interactive use.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func_to_apply</strong><span class="classifier">function</span></dt><dd><p>A function that modifies the attributes listed in <code class="docutils literal notranslate"><span class="pre">attrs_to_apply</span></code>.
It must return the modified attributes and a label to be printed.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no function is applied.</p>
</dd>
<dt><strong>attrs_to_apply</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be modified by <code class="docutils literal notranslate"><span class="pre">func_to_apply</span></code>.</p>
</dd>
<dt><strong>attrs_to_discard</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be discarded from the output.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.read">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.read" title="Link to this definition">¶</a></dt>
<dd><p>Generic reader for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>Files that need the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> interface MUST contain
at least a column named like the <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The default ascii format is enhanced CSV (ECSV). Data formats
supporting the serialization of metadata (such as ECSV and HDF5) can
contain all attributes such as <code class="docutils literal notranslate"><span class="pre">mission</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc with
no significant loss of information. Other file formats might lose part
of the metadata, so must be used with care.</p>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values should be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Path and file name for the file to be read.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>Available options are ‘pickle’, ‘hea’, and any <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code>-supported
format such as ‘hdf5’, ‘ascii.ecsv’, etc.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>obj: <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object</dt><dd><p>The object reconstructed from file</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.rebin">
<span class="sig-name descname"><span class="pre">rebin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.rebin" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the cross spectrum to a new frequency resolution <code class="docutils literal notranslate"><span class="pre">df</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: float</strong></dt><dd><p>The new frequency resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>bin_cs = <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> (or one of its subclasses) object</dt><dd><p>The newly binned cross spectrum or power spectrum.
Note: this object will be of the same type as the object
that called this method. For example, if this method is called
from <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, it will return an object of class
<a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, too.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float</strong></dt><dd><p>the rebin factor. If specified, it substitutes df with <code class="docutils literal notranslate"><span class="pre">f*self.df</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.rebin_log">
<span class="sig-name descname"><span class="pre">rebin_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.rebin_log" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic rebin of the periodogram.
The new frequency depends on the previous frequency
modified by a factor f:</p>
<div class="math notranslate nohighlight">
\[d\nu_j = d\nu_{j-1} (1+f)\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float, optional, default ``0.01``</strong></dt><dd><p>parameter that steers the frequency resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>new_spec</strong><span class="classifier"><a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> (or one of its subclasses) object</span></dt><dd><p>The newly binned cross spectrum or power spectrum.
Note: this object will be of the same type as the object
that called this method. For example, if this method is called
from <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, it will return an object of class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.sub" title="Link to this definition">¶</a></dt>
<dd><p>Subtract <em>all the array attrs</em> of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.time_lag">
<span class="sig-name descname"><span class="pre">time_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crossspectrum.html#AveragedCrossspectrum.time_lag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.AveragedCrossspectrum.time_lag" title="Link to this definition">¶</a></dt>
<dd><p>Calculate time lag and uncertainty.</p>
<p>Equation from Bendat &amp; Piersol, 2011 [bendat-2011]__.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lag</strong><span class="classifier">np.ndarray</span></dt><dd><p>The time lag</p>
</dd>
<dt><strong>lag_err</strong><span class="classifier">np.ndarray</span></dt><dd><p>The uncertainty in the time lag</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.to_astropy_table">
<span class="sig-name descname"><span class="pre">to_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">no_longdouble</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><span class="pre">Table</span></a></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.to_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create an Astropy Table from a <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code></p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">meta</span></code> dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>no_longdouble</strong><span class="classifier">bool</span></dt><dd><p>If True, reduce the precision of longdouble arrays to double precision.
This needs to be done in some cases, e.g. when the table is to be saved
in an architecture not supporting extended precision (e.g. ARM), but can
also be useful when an extended precision is not needed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.to_norm">
<span class="sig-name descname"><span class="pre">to_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedCrossspectrum.to_norm" title="Link to this definition">¶</a></dt>
<dd><p>Convert Cross spectrum to new normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">str</span></dt><dd><p>The new normalization of the spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_spec</strong><span class="classifier">object, same class as input</span></dt><dd><p>The new, normalized, spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace: bool, default False</strong></dt><dd><p>If True, change the current instance. Otherwise, return a new one</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.to_pandas">
<span class="sig-name descname"><span class="pre">to_pandas</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.to_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays are
converted into columns before the conversion, with names <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_nd_into_arrays</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.to_xarray">
<span class="sig-name descname"><span class="pre">to_xarray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dataset</span></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.to_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create an <code class="docutils literal notranslate"><span class="pre">xarray</span></code> Dataset from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.type">
<span class="sig-name descname"><span class="pre">type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'crossspectrum'</span></em><a class="headerlink" href="#stingray.AveragedCrossspectrum.type" title="Link to this definition">¶</a></dt>
<dd><p>Make an averaged cross spectrum from a light curve by segmenting two
light curves, Fourier-transforming each segment and then averaging the
resulting cross spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data1: :class:`stingray.Lightcurve`object OR iterable of :class:`stingray.Lightcurve` objects OR :class:`stingray.EventList` object</strong></dt><dd><p>A light curve from which to compute the cross spectrum. In some cases,
this would be the light curve of the wavelength/energy/frequency band
of interest.</p>
</dd>
<dt><strong>data2: :class:`stingray.Lightcurve`object OR iterable of :class:`stingray.Lightcurve` objects OR :class:`stingray.EventList` object</strong></dt><dd><p>A second light curve to use in the cross spectrum. In some cases, this
would be the wavelength/energy/frequency reference band to compare the
band of interest with.</p>
</dd>
<dt><strong>segment_size: float</strong></dt><dd><p>The size of each segment to average. Note that if the total duration of
each <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object in <code class="docutils literal notranslate"><span class="pre">lc1</span></code> or <code class="docutils literal notranslate"><span class="pre">lc2</span></code> is not an
integer multiple of the <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>, then any fraction left-over
at the end of the time series will be lost. Otherwise you introduce
artifacts.</p>
</dd>
<dt><strong>norm: {``frac``, ``abs``, ``leahy``, ``none``}, default ``none``</strong></dt><dd><p>The normalization of the (real part of the) cross spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>freq: numpy.ndarray</strong></dt><dd><p>The array of mid-bin frequencies that the Fourier transform samples.</p>
</dd>
<dt><strong>power: numpy.ndarray</strong></dt><dd><p>The array of cross spectra.</p>
</dd>
<dt><strong>power_err: numpy.ndarray</strong></dt><dd><p>The uncertainties of <code class="docutils literal notranslate"><span class="pre">power</span></code>.
An approximation for each bin given by <code class="docutils literal notranslate"><span class="pre">power_err=</span> <span class="pre">power/sqrt(m)</span></code>.
Where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the number of power averaged in each bin (by frequency
binning, or averaging power spectra of segments of a light curve).
Note that for a single realization (<code class="docutils literal notranslate"><span class="pre">m=1</span></code>) the error is equal to the
power.</p>
</dd>
<dt><strong>df: float</strong></dt><dd><p>The frequency resolution.</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>The number of averaged cross spectra.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>The number of time bins per segment of light curve.</p>
</dd>
<dt><strong>nphots1: float</strong></dt><dd><p>The total number of photons in the first (interest) light curve.</p>
</dd>
<dt><strong>nphots2: float</strong></dt><dd><p>The total number of photons in the second (reference) light curve.</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the light curve. Only needed when constructing
light curves in the case where data1 or data2 are of :class:EventList</p>
</dd>
<dt><strong>power_type: string, optional, default ``all``</strong></dt><dd><p>Parameter to choose among complete, real part and magnitude of
the cross spectrum.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Do not show a progress bar when generating an averaged cross spectrum.
Useful for the batch execution of many spectra</p>
</dd>
<dt><strong>lc1: :class:`stingray.Lightcurve`object OR iterable of :class:`stingray.Lightcurve` objects</strong></dt><dd><p>For backwards compatibility only. Like <code class="docutils literal notranslate"><span class="pre">data1</span></code>, but no
<a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> objects allowed</p>
</dd>
<dt><strong>lc2: :class:`stingray.Lightcurve`object OR iterable of :class:`stingray.Lightcurve` objects</strong></dt><dd><p>For backwards compatibility only. Like <code class="docutils literal notranslate"><span class="pre">data2</span></code>, but no
<a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> objects allowed</p>
</dd>
<dt><strong>fullspec: boolean, optional, default ``False``</strong></dt><dd><p>If True, return the full array of frequencies, otherwise return just the
positive frequencies.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average. Use with care.
This is likely to fill up your RAM on medium-sized datasets, and to
slow down the computation when rebinning.</p>
</dd>
<dt><strong>skip_checks: bool</strong></dt><dd><p>Skip initial checks, for speed or other reasons (you need to trust your
inputs!)</p>
</dd>
<dt><strong>use_common_mean: bool</strong></dt><dd><p>Averaged cross spectra are normalized in two possible ways: one is by normalizing
each of the single spectra that get averaged, the other is by normalizing after the
averaging. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">use_common_mean</span></code> is selected, the spectrum will be normalized
after the average.</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedCrossspectrum.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span></span><a class="headerlink" href="#stingray.AveragedCrossspectrum.write" title="Link to this definition">¶</a></dt>
<dd><p>Generic writer for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values will be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Name and path of the file to save the object list to.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>The file format to store the data in.
Available options are <code class="docutils literal notranslate"><span class="pre">pickle</span></code>, <code class="docutils literal notranslate"><span class="pre">hdf5</span></code>, <code class="docutils literal notranslate"><span class="pre">ascii</span></code>, <code class="docutils literal notranslate"><span class="pre">fits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="averagedpowerspectrum">
<h3>AveragedPowerspectrum<a class="headerlink" href="#averagedpowerspectrum" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">AveragedPowerspectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_checks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#AveragedPowerspectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.AveragedPowerspectrum" title="Link to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.add" title="Link to this definition">¶</a></dt>
<dd><p>Add two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances.</p>
<p>Add the array values of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming
the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.apply_mask">
<span class="sig-name descname"><span class="pre">apply_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">npt.ArrayLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtered_attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.apply_mask" title="Link to this definition">¶</a></dt>
<dd><p>Apply a mask to all array attributes of the object</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>mask</strong><span class="classifier">array of <code class="docutils literal notranslate"><span class="pre">bool</span></code></span></dt><dd><p>The mask. Has to be of the same length as <code class="docutils literal notranslate"><span class="pre">self.time</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ts_new</strong><span class="classifier">StingrayObject object</span></dt><dd><p>The new object with the mask applied if <code class="docutils literal notranslate"><span class="pre">inplace</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, otherwise the
same object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current object. Otherwise, return a new one.</p>
</dd>
<dt><strong>filtered_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be filtered. Defaults to all array attributes if <code class="docutils literal notranslate"><span class="pre">None</span></code>.
The other array attributes will be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>. The main array attr is always
included.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.array_attrs">
<span class="sig-name descname"><span class="pre">array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the array attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.classical_significances">
<span class="sig-name descname"><span class="pre">classical_significances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.classical_significances" title="Link to this definition">¶</a></dt>
<dd><p>Compute the classical significances for the powers in the power
spectrum, assuming an underlying noise distribution that follows a
chi-square distributions with 2M degrees of freedom, where M is the
number of powers averaged in each bin.</p>
<p>Note that this function will <em>only</em> produce correct results when the
following underlying assumptions are fulfilled:</p>
<ol class="arabic simple">
<li><p>The power spectrum is Leahy-normalized</p></li>
<li><p>There is no source of variability in the data other than the
periodic signal to be determined with this method. This is
important! If there are other sources of (aperiodic) variability in
the data, this method will <em>not</em> produce correct results, but
instead produce a large number of spurious false positive
detections!</p></li>
<li><p>There are no significant instrumental effects changing the
statistical distribution of the powers (e.g. pile-up or dead time)</p></li>
</ol>
<p>By default, the method produces <code class="docutils literal notranslate"><span class="pre">(index,p-values)</span></code> for all powers in
the power spectrum, where index is the numerical index of the power in
question. If a <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is set, then only powers with p-values
<em>below</em> that threshold with their respective indices. If
<code class="docutils literal notranslate"><span class="pre">trial_correction</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the threshold will be
corrected for the number of trials (frequencies) in the power spectrum
before being used.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>threshold</strong><span class="classifier">float, optional, default <code class="docutils literal notranslate"><span class="pre">1</span></code></span></dt><dd><p>The threshold to be used when reporting p-values of potentially
significant powers. Must be between 0 and 1.
Default is <code class="docutils literal notranslate"><span class="pre">1</span></code> (all p-values will be reported).</p>
</dd>
<dt><strong>trial_correction</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>A Boolean flag that sets whether the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> will be
corrected by the number of frequencies before being applied. This
decreases the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (p-values need to be lower to count as
significant). Default is <code class="docutils literal notranslate"><span class="pre">False</span></code> (report all powers) though for
any application where <code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold`</span></code> is set to something meaningful,
this should also be applied!</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pvals</strong><span class="classifier">iterable</span></dt><dd><p>A list of <code class="docutils literal notranslate"><span class="pre">(p-value,</span> <span class="pre">index)</span></code> tuples for all powers that have
p-values lower than the threshold specified in <code class="docutils literal notranslate"><span class="pre">threshold</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.coherence">
<span class="sig-name descname"><span class="pre">coherence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.coherence" title="Link to this definition">¶</a></dt>
<dd><p>Averaged Coherence function.</p>
<p>Coherence is defined in Vaughan and Nowak, 1996 <a class="footnote-reference brackets" href="#id10" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.
It is a Fourier frequency dependent measure of the linear correlation
between time series measured simultaneously in two energy channels.</p>
<p>Compute an averaged Coherence function of cross spectrum by computing
coherence function of each segment and averaging them. The return type
is a tuple with first element as the coherence function and the second
element as the corresponding uncertainty associated with it.</p>
<p>Note : The uncertainty in coherence function is strictly valid for Gaussian                statistics only.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>(coh, uncertainty)</strong><span class="classifier">tuple of np.ndarray</span></dt><dd><p>Tuple comprising the coherence function and uncertainty.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://iopscience.iop.org/article/10.1086/310430">https://iopscience.iop.org/article/10.1086/310430</a></p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.compute_rms">
<span class="sig-name descname"><span class="pre">compute_rms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poisson_noise_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.compute_rms" title="Link to this definition">¶</a></dt>
<dd><p>Compute the fractional rms amplitude in the power spectrum
between two frequencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_freq: float</strong></dt><dd><p>The lower frequency bound for the calculation.</p>
</dd>
<dt><strong>max_freq: float</strong></dt><dd><p>The upper frequency bound for the calculation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>rms: float</dt><dd><p>The fractional rms amplitude contained between <code class="docutils literal notranslate"><span class="pre">min_freq</span></code> and
<code class="docutils literal notranslate"><span class="pre">max_freq</span></code>.</p>
</dd>
<dt>rms_err: float</dt><dd><p>The error on the fractional rms amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poisson_noise_level</strong><span class="classifier">float, default is None</span></dt><dd><p>This is the Poisson noise level of the PDS with same
normalization as the PDS. If poissoin_noise_level is None,
the Poisson noise is calculated in the idealcase
e.g. 2./&lt;countrate&gt; for fractional rms normalisation
Dead time and other instrumental effects can alter it.
The user can fit the Poisson noise level outside
this function using the same normalisation of the PDS
and it will get subtracted from powers here.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.data_attributes">
<span class="sig-name descname"><span class="pre">data_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.data_attributes" title="Link to this definition">¶</a></dt>
<dd><p>Clean up the list of attributes, only giving out those pointing to data.</p>
<p>List all the attributes that point directly to valid data. This method goes through all the
attributes of the class, eliminating methods, properties, and attributes that are complicated
to serialize such as other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code>, or arrays of objects.</p>
<p>This function does not make difference between array-like data and scalar data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data_attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of attributes pointing to data that are not methods, properties,
or other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code> instances.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.deadtime_correct">
<span class="sig-name descname"><span class="pre">deadtime_correct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dead_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paralyzable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.deadtime_correct" title="Link to this definition">¶</a></dt>
<dd><p>Correct the power spectrum for dead time effects.</p>
<p>This correction is based on the formula given in Zhang et al. 2015, assuming
a constant dead time for all events.
For more advanced dead time corrections, see the FAD method from <a class="reference internal" href="#module-stingray.deadtime.fad" title="stingray.deadtime.fad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.deadtime.fad</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dead_time: float</strong></dt><dd><p>The dead time of the detector.</p>
</dd>
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>Detected source count rate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>spectrum: <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> or derivative.</dt><dd><p>The dead-time corrected spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>background_rate</strong><span class="classifier">float, default 0</span></dt><dd><p>Detected background count rate. This is important to estimate when deadtime is given by the
combination of the source counts and background counts (e.g. in an imaging X-ray detector).</p>
</dd>
<dt><strong>paralyzable: bool, default False</strong></dt><dd><p>If True, the dead time correction is done assuming a paralyzable
dead time. If False, the correction is done assuming a non-paralyzable
(more common) dead time.</p>
</dd>
<dt><strong>limit_k</strong><span class="classifier">int, default 200</span></dt><dd><p>Limit to this value the number of terms in the inner loops of
calculations. Check the plots returned by  the <code class="xref py py-obj docutils literal notranslate"><span class="pre">check_B</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">check_A</span></code> functions to test that this number is adequate.</p>
</dd>
<dt><strong>n_approx</strong><span class="classifier">int, default None</span></dt><dd><p>Number of bins to calculate the model power spectrum. If None, it will use the size of
the input frequency array. Relatively simple models (e.g., low count rates compared to
dead time) can use a smaller number of bins to speed up the calculation, and the final
power values will be interpolated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.dict">
<span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.dict" title="Link to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.from_astropy_table">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Table</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.from_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create a Stingray Object object from data in an Astropy Table.</p>
<p>The table MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.from_events">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.from_events" title="Link to this definition">¶</a></dt>
<dd><p>Calculate an average power spectrum from an event list.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.EventList</span></code></span></dt><dd><p>Event list to be analyzed.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for
<code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code>.</p>
</dd>
<dt><strong>gti: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Additional, optional Good Time intervals that get intersected with
the GTIs of the input object. Can cause errors if there are
overlaps between these GTIs and the input object GTIs. If that
happens, assign the desired GTIs to the input object.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. <a class="reference external" href="https://docs.python.org/3/library/functions.html#abs" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a> is absolute rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">frac</span></code>
is fractional rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">leahy</span></code> is Leahy+83 normalization, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">none</span></code> is
the unnormalized periodogram.</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or
on the full light curve. This gives different results
(Alston+2013). By default, we assume the mean is calculated on the
full light curve, but the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False
to calculate it on a per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.from_lc_iterable">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lc_iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iter_lc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.from_lc_iterable" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the average power spectrum of an iterable collection of
light curves.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>iter_lc</strong><span class="classifier">iterable of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects or <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Light curves. If arrays, use them as counts.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for
<code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code>.</p>
</dd>
<dt><strong>gti: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Additional, optional Good Time intervals that get intersected with
the GTIs of the input object. Can cause errors if there are
overlaps between these GTIs and the input object GTIs. If that
happens, assign the desired GTIs to the input object.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. <a class="reference external" href="https://docs.python.org/3/library/functions.html#abs" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a> is absolute rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">frac</span></code>
is fractional rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">leahy</span></code> is Leahy+83 normalization, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">none</span></code> is
the unnormalized periodogram.</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or
on the full light curve. This gives different results
(Alston+2013). By default, we assume the mean is calculated on the
full light curve, but the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False
to calculate it on a per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.from_lightcurve">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lightcurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.from_lightcurve" title="Link to this definition">¶</a></dt>
<dd><p>Calculate a power spectrum from a light curve.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a></span></dt><dd><p>Light curve to be analyzed.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for
<code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code>.</p>
</dd>
<dt><strong>gti: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Additional, optional Good Time intervals that get intersected with
the GTIs of the input object. Can cause errors if there are
overlaps between these GTIs and the input object GTIs. If that
happens, assign the desired GTIs to the input object.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. <a class="reference external" href="https://docs.python.org/3/library/functions.html#abs" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a> is absolute rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">frac</span></code>
is fractional rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">leahy</span></code> is Leahy+83 normalization, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">none</span></code> is
the unnormalized periodogram.</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or
on the full light curve. This gives different results
(Alston+2013). By default, we assume the mean is calculated on the
full light curve, but the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False
to calculate it on a per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.from_pandas">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">DataFrame</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.from_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create an <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object from data in a pandas DataFrame.</p>
<p>The dataframe MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays can be
specified as <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_1d_arrays_into_nd</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.from_stingray_timeseries">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_stingray_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux_attr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_flux_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.from_stingray_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedPowerspectrum from a time series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ts</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Timeseries</span></code></span></dt><dd><p>Input Time Series</p>
</dd>
<dt><strong>flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>error_flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used as error bar.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.from_time_array">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_time_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.from_time_array" title="Link to this definition">¶</a></dt>
<dd><p>Calculate an average power spectrum from an array of event times.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>times</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Event arrival times.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for
<code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code>.</p>
</dd>
<dt><strong>gti: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], …]``</strong></dt><dd><p>Additional, optional Good Time intervals that get intersected with
the GTIs of the input object. Can cause errors if there are
overlaps between these GTIs and the input object GTIs. If that
happens, assign the desired GTIs to the input object.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. <a class="reference external" href="https://docs.python.org/3/library/functions.html#abs" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a> is absolute rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">frac</span></code>
is fractional rms, <code class="xref py py-obj docutils literal notranslate"><span class="pre">leahy</span></code> is Leahy+83 normalization, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">none</span></code> is
the unnormalized periodogram.</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or
on the full light curve. This gives different results
(Alston+2013). By default, we assume the mean is calculated on the
full light curve, but the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False
to calculate it on a per-segment basis.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.from_xarray">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_xarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dataset</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.from_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> from data in an xarray Dataset.</p>
<p>The dataset MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.get_meta_dict">
<span class="sig-name descname"><span class="pre">get_meta_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.get_meta_dict" title="Link to this definition">¶</a></dt>
<dd><p>Give a dictionary with all non-None meta attrs of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.initial_checks">
<span class="sig-name descname"><span class="pre">initial_checks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#AveragedPowerspectrum.initial_checks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.AveragedPowerspectrum.initial_checks" title="Link to this definition">¶</a></dt>
<dd><p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev1</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev2</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac</span> <span class="o">=</span> <span class="n">AveragedCrossspectrum</span><span class="p">()</span>
</pre></div>
</div>
<p>If AveragedCrossspectrum, you need <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>
&gt;&gt;&gt; AveragedCrossspectrum.initial_checks(ac, data1=ev1, data2=ev2, dt=1)
Traceback (most recent call last):
…
ValueError: segment_size must be specified…</p>
<p>And it needs to be finite!
&gt;&gt;&gt; AveragedCrossspectrum.initial_checks(ac, data1=ev1, data2=ev2, dt=1., segment_size=np.nan)
Traceback (most recent call last):
…
ValueError: segment_size must be finite!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.internal_array_attrs">
<span class="sig-name descname"><span class="pre">internal_array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.internal_array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the internal array attributes of the Stingray Object.</p>
<p>These are array attributes that can be set by properties, and are generally indicated
by an underscore followed by the name of the property that links to it (E.g.
<code class="docutils literal notranslate"><span class="pre">_counts</span></code> in <code class="docutils literal notranslate"><span class="pre">Lightcurve</span></code>).
By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of internal array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.meta_attrs">
<span class="sig-name descname"><span class="pre">meta_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.meta_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the meta attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with a different size and shape
than <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of meta attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.modulation_upper_limit">
<span class="sig-name descname"><span class="pre">modulation_upper_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.modulation_upper_limit" title="Link to this definition">¶</a></dt>
<dd><p>Upper limit on a sinusoidal modulation.</p>
<p>To understand the meaning of this amplitude: if the modulation is
described by:</p>
<p>..math:: p = overline{p} (1 + a * sin(x))</p>
<p>this function returns a.</p>
<p>If it is a sum of sinusoidal harmonics instead
..math:: p = overline{p} (1 + sum_l a_l * sin(lx))
a is equivalent to <span class="math notranslate nohighlight">\(\sqrt(\sum_l a_l^2)\)</span>.</p>
<p>See <a class="reference internal" href="#stingray.stats.power_upper_limit" title="stingray.stats.power_upper_limit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.stats.power_upper_limit</span></code></a>,
<a class="reference internal" href="#stingray.stats.amplitude_upper_limit" title="stingray.stats.amplitude_upper_limit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.stats.amplitude_upper_limit</span></code></a>
for more information.</p>
<p>The formula used to calculate the upper limit assumes the Leahy
normalization.
If the periodogram is in another normalization, we will internally
convert it to Leahy before calculating the upper limit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fmin: float</strong></dt><dd><p>The minimum frequency to search (defaults to the first nonzero bin)</p>
</dd>
<dt><strong>fmax: float</strong></dt><dd><p>The maximum frequency to search (defaults to the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>a: float</dt><dd><p>The modulation amplitude that could produce P&gt;pmeas with 1 - c
probability.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c: float</strong></dt><dd><p>The confidence value for the upper limit (e.g. 0.95 = 95%)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span> <span class="o">=</span> <span class="n">Powerspectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="s2">&quot;leahy&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note: this pds has 40 as maximum value between 2 and 5 Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">100000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span><span class="o">.</span><span class="n">nphots</span> <span class="o">=</span> <span class="mi">30000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pds</span><span class="o">.</span><span class="n">modulation_upper_limit</span><span class="p">(</span><span class="n">fmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.99</span><span class="p">),</span>
<span class="gp">... </span>    <span class="mf">0.10164</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">atol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.phase_lag">
<span class="sig-name descname"><span class="pre">phase_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.phase_lag" title="Link to this definition">¶</a></dt>
<dd><p>Return the fourier phase lag of the cross spectrum.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the amplitude of the cross spectrum vs. the frequency using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier">iterable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A list of tuple with <code class="docutils literal notranslate"><span class="pre">xlabel</span></code> and <code class="docutils literal notranslate"><span class="pre">ylabel</span></code> as strings.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for the``matplotlib.pyplot.axis()`` method.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The title of the plot.</p>
</dd>
<dt><strong>marker</strong><span class="classifier">str, default ‘-’</span></dt><dd><p>Line style and color of the plot. Line styles and colors are
combined in a single format string, as in <code class="docutils literal notranslate"><span class="pre">'bo'</span></code> for blue
circles. See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> for more options.</p>
</dd>
<dt><strong>save</strong><span class="classifier">boolean, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.Axes</span></code> object</span></dt><dd><p>An axes object to fill with the cross correlation plot.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.pretty_print">
<span class="sig-name descname"><span class="pre">pretty_print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.pretty_print" title="Link to this definition">¶</a></dt>
<dd><p>Return a pretty-printed string representation of the object.</p>
<p>This is useful for debugging, and for interactive use.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func_to_apply</strong><span class="classifier">function</span></dt><dd><p>A function that modifies the attributes listed in <code class="docutils literal notranslate"><span class="pre">attrs_to_apply</span></code>.
It must return the modified attributes and a label to be printed.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no function is applied.</p>
</dd>
<dt><strong>attrs_to_apply</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be modified by <code class="docutils literal notranslate"><span class="pre">func_to_apply</span></code>.</p>
</dd>
<dt><strong>attrs_to_discard</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be discarded from the output.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.read">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.read" title="Link to this definition">¶</a></dt>
<dd><p>Generic reader for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>Files that need the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> interface MUST contain
at least a column named like the <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The default ascii format is enhanced CSV (ECSV). Data formats
supporting the serialization of metadata (such as ECSV and HDF5) can
contain all attributes such as <code class="docutils literal notranslate"><span class="pre">mission</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc with
no significant loss of information. Other file formats might lose part
of the metadata, so must be used with care.</p>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values should be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Path and file name for the file to be read.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>Available options are ‘pickle’, ‘hea’, and any <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code>-supported
format such as ‘hdf5’, ‘ascii.ecsv’, etc.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>obj: <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object</dt><dd><p>The object reconstructed from file</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.rebin">
<span class="sig-name descname"><span class="pre">rebin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.rebin" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the power spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: float</strong></dt><dd><p>The new frequency resolution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>bin_cs = <a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Powerspectrum</span></code></a> object</dt><dd><p>The newly binned power spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float</strong></dt><dd><p>The rebin factor. If specified, it substitutes <code class="docutils literal notranslate"><span class="pre">df</span></code> with
<code class="docutils literal notranslate"><span class="pre">f*self.df</span></code>, so <code class="docutils literal notranslate"><span class="pre">f&gt;1</span></code> is recommended.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.rebin_log">
<span class="sig-name descname"><span class="pre">rebin_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.rebin_log" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic rebin of the periodogram.
The new frequency depends on the previous frequency
modified by a factor f:</p>
<div class="math notranslate nohighlight">
\[d\nu_j = d\nu_{j-1} (1+f)\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float, optional, default ``0.01``</strong></dt><dd><p>parameter that steers the frequency resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>new_spec</strong><span class="classifier"><a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> (or one of its subclasses) object</span></dt><dd><p>The newly binned cross spectrum or power spectrum.
Note: this object will be of the same type as the object
that called this method. For example, if this method is called
from <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, it will return an object of class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.sub" title="Link to this definition">¶</a></dt>
<dd><p>Subtract <em>all the array attrs</em> of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.time_lag">
<span class="sig-name descname"><span class="pre">time_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.time_lag" title="Link to this definition">¶</a></dt>
<dd><p>Calculate time lag and uncertainty.</p>
<p>Equation from Bendat &amp; Piersol, 2011 [bendat-2011]__.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lag</strong><span class="classifier">np.ndarray</span></dt><dd><p>The time lag</p>
</dd>
<dt><strong>lag_err</strong><span class="classifier">np.ndarray</span></dt><dd><p>The uncertainty in the time lag</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.to_astropy_table">
<span class="sig-name descname"><span class="pre">to_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">no_longdouble</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><span class="pre">Table</span></a></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.to_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create an Astropy Table from a <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code></p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">meta</span></code> dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>no_longdouble</strong><span class="classifier">bool</span></dt><dd><p>If True, reduce the precision of longdouble arrays to double precision.
This needs to be done in some cases, e.g. when the table is to be saved
in an architecture not supporting extended precision (e.g. ARM), but can
also be useful when an extended precision is not needed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.to_norm">
<span class="sig-name descname"><span class="pre">to_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AveragedPowerspectrum.to_norm" title="Link to this definition">¶</a></dt>
<dd><p>Convert Cross spectrum to new normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">str</span></dt><dd><p>The new normalization of the spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_spec</strong><span class="classifier">object, same class as input</span></dt><dd><p>The new, normalized, spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace: bool, default False</strong></dt><dd><p>If True, change the current instance. Otherwise, return a new one</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.to_pandas">
<span class="sig-name descname"><span class="pre">to_pandas</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.to_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays are
converted into columns before the conversion, with names <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_nd_into_arrays</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.to_xarray">
<span class="sig-name descname"><span class="pre">to_xarray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dataset</span></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.to_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create an <code class="docutils literal notranslate"><span class="pre">xarray</span></code> Dataset from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.type">
<span class="sig-name descname"><span class="pre">type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'powerspectrum'</span></em><a class="headerlink" href="#stingray.AveragedPowerspectrum.type" title="Link to this definition">¶</a></dt>
<dd><p>Make an averaged periodogram from a light curve by segmenting the light
curve, Fourier-transforming each segment and then averaging the
resulting periodograms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data: :class:`stingray.Lightcurve`object OR iterable of :class:`stingray.Lightcurve` objects OR :class:`stingray.EventList` object</strong></dt><dd><p>The light curve data to be Fourier-transformed.</p>
</dd>
<dt><strong>segment_size: float</strong></dt><dd><p>The size of each segment to average. Note that if the total
duration of each <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object in lc is not an integer
multiple of the <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>, then any fraction left-over at the
end of the time series will be lost.</p>
</dd>
<dt><strong>norm: {“leahy” | “frac” | “abs” | “none” }, optional, default “frac”</strong></dt><dd><p>The normalization of the periodogram to be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>norm: {``leahy`` | ``frac`` | ``abs`` | ``none`` }</strong></dt><dd><p>The normalization of the periodogram.</p>
</dd>
<dt><strong>freq: numpy.ndarray</strong></dt><dd><p>The array of mid-bin frequencies that the Fourier transform samples.</p>
</dd>
<dt><strong>power: numpy.ndarray</strong></dt><dd><p>The array of normalized powers</p>
</dd>
<dt><strong>power_err: numpy.ndarray</strong></dt><dd><p>The uncertainties of <code class="docutils literal notranslate"><span class="pre">power</span></code>.
An approximation for each bin given by <code class="docutils literal notranslate"><span class="pre">power_err=</span> <span class="pre">power/sqrt(m)</span></code>.
Where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the number of power averaged in each bin (by frequency
binning, or averaging power spectra of segments of a light curve).
Note that for a single realization (<code class="docutils literal notranslate"><span class="pre">m=1</span></code>) the error is equal to the
power.</p>
</dd>
<dt><strong>unnorm_power: numpy.ndarray</strong></dt><dd><p>The array of unnormalized powers</p>
</dd>
<dt><strong>unnorm_power_err: numpy.ndarray</strong></dt><dd><p>The uncertainties of <code class="docutils literal notranslate"><span class="pre">unnorm_power</span></code>.</p>
</dd>
<dt><strong>df: float</strong></dt><dd><p>The frequency resolution.</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>The number of averaged periodograms.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>The number of data points in the light curve.</p>
</dd>
<dt><strong>nphots: float</strong></dt><dd><p>The total number of photons in the light curve.</p>
</dd>
<dt><strong>cs_all: list of :class:`Powerspectrum` objects</strong></dt><dd><p>The list of all periodograms used to calculate the average periodogram.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti: 2-d float array</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code> – Good Time intervals.
This choice overrides the GTIs in the single light curves. Use with
care, especially if these GTIs have overlaps with the input
object GTIs! If you’re getting errors regarding your GTIs, don’t
use this and only give GTIs to the input object before making
the power spectrum.</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Do not show a progress bar when generating an averaged cross spectrum.
Useful for the batch execution of many spectra.</p>
</dd>
<dt><strong>dt: float</strong></dt><dd><p>The time resolution of the light curve. Only needed when constructing
light curves in the case where data is of :class:EventList.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>Save all intermediate PDSs used for the final average. Use with care.
This is likely to fill up your RAM on medium-sized datasets, and to
slow down the computation when rebinning.</p>
</dd>
<dt><strong>skip_checks: bool</strong></dt><dd><p>Skip initial checks, for speed or other reasons (you need to trust your
inputs!).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AveragedPowerspectrum.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span></span><a class="headerlink" href="#stingray.AveragedPowerspectrum.write" title="Link to this definition">¶</a></dt>
<dd><p>Generic writer for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values will be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Name and path of the file to save the object list to.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>The file format to store the data in.
Available options are <code class="docutils literal notranslate"><span class="pre">pickle</span></code>, <code class="docutils literal notranslate"><span class="pre">hdf5</span></code>, <code class="docutils literal notranslate"><span class="pre">ascii</span></code>, <code class="docutils literal notranslate"><span class="pre">fits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="dynamical-powerspectrum">
<h3>Dynamical Powerspectrum<a class="headerlink" href="#dynamical-powerspectrum" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">DynamicalPowerspectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#DynamicalPowerspectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.DynamicalPowerspectrum" title="Link to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.add" title="Link to this definition">¶</a></dt>
<dd><p>Add two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances.</p>
<p>Add the array values of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming
the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.apply_mask">
<span class="sig-name descname"><span class="pre">apply_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">npt.ArrayLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtered_attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.apply_mask" title="Link to this definition">¶</a></dt>
<dd><p>Apply a mask to all array attributes of the object</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>mask</strong><span class="classifier">array of <code class="docutils literal notranslate"><span class="pre">bool</span></code></span></dt><dd><p>The mask. Has to be of the same length as <code class="docutils literal notranslate"><span class="pre">self.time</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ts_new</strong><span class="classifier">StingrayObject object</span></dt><dd><p>The new object with the mask applied if <code class="docutils literal notranslate"><span class="pre">inplace</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, otherwise the
same object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current object. Otherwise, return a new one.</p>
</dd>
<dt><strong>filtered_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be filtered. Defaults to all array attributes if <code class="docutils literal notranslate"><span class="pre">None</span></code>.
The other array attributes will be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>. The main array attr is always
included.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.array_attrs">
<span class="sig-name descname"><span class="pre">array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the array attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.classical_significances">
<span class="sig-name descname"><span class="pre">classical_significances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.classical_significances" title="Link to this definition">¶</a></dt>
<dd><p>Compute the classical significances for the powers in the power
spectrum, assuming an underlying noise distribution that follows a
chi-square distributions with 2M degrees of freedom, where M is the
number of powers averaged in each bin.</p>
<p>Note that this function will <em>only</em> produce correct results when the
following underlying assumptions are fulfilled:</p>
<ol class="arabic simple">
<li><p>The power spectrum is Leahy-normalized</p></li>
<li><p>There is no source of variability in the data other than the
periodic signal to be determined with this method. This is important!
If there are other sources of (aperiodic) variability in the data, this
method will <em>not</em> produce correct results, but instead produce a large
number of spurious false positive detections!</p></li>
<li><p>There are no significant instrumental effects changing the
statistical distribution of the powers (e.g. pile-up or dead time)</p></li>
</ol>
<p>By default, the method produces <code class="docutils literal notranslate"><span class="pre">(index,p-values)</span></code> for all powers in
the power spectrum, where index is the numerical index of the power in
question. If a <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is set, then only powers with p-values
<em>below</em> that threshold with their respective indices. If
<code class="docutils literal notranslate"><span class="pre">trial_correction</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the threshold will be corrected
for the number of trials (frequencies) in the power spectrum before
being used.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>threshold</strong><span class="classifier">float, optional, default <code class="docutils literal notranslate"><span class="pre">1</span></code></span></dt><dd><p>The threshold to be used when reporting p-values of potentially
significant powers. Must be between 0 and 1.
Default is <code class="docutils literal notranslate"><span class="pre">1</span></code> (all p-values will be reported).</p>
</dd>
<dt><strong>trial_correction</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>A Boolean flag that sets whether the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> will be corrected
by the number of frequencies before being applied. This decreases
the <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (p-values need to be lower to count as significant).
Default is <code class="docutils literal notranslate"><span class="pre">False</span></code> (report all powers) though for any application
where <code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold`</span></code> is set to something meaningful, this should also
be applied!</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pvals</strong><span class="classifier">iterable</span></dt><dd><p>A list of <code class="docutils literal notranslate"><span class="pre">(index,</span> <span class="pre">p-value)</span></code> tuples for all powers that have p-values
lower than the threshold specified in <code class="docutils literal notranslate"><span class="pre">threshold</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.coherence">
<span class="sig-name descname"><span class="pre">coherence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.coherence" title="Link to this definition">¶</a></dt>
<dd><p>Averaged Coherence function.</p>
<p>Coherence is defined in Vaughan and Nowak, 1996 <a class="footnote-reference brackets" href="#id12" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.
It is a Fourier frequency dependent measure of the linear correlation
between time series measured simultaneously in two energy channels.</p>
<p>Compute an averaged Coherence function of cross spectrum by computing
coherence function of each segment and averaging them. The return type
is a tuple with first element as the coherence function and the second
element as the corresponding uncertainty associated with it.</p>
<p>Note : The uncertainty in coherence function is strictly valid for Gaussian                statistics only.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>(coh, uncertainty)</strong><span class="classifier">tuple of np.ndarray</span></dt><dd><p>Tuple comprising the coherence function and uncertainty.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://iopscience.iop.org/article/10.1086/310430">https://iopscience.iop.org/article/10.1086/310430</a></p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.compute_rms">
<span class="sig-name descname"><span class="pre">compute_rms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poisson_noise_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.compute_rms" title="Link to this definition">¶</a></dt>
<dd><p>Compute the fractional rms amplitude in the power spectrum
between two frequencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_freq: float</strong></dt><dd><p>The lower frequency bound for the calculation.</p>
</dd>
<dt><strong>max_freq: float</strong></dt><dd><p>The upper frequency bound for the calculation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>rms: float</dt><dd><p>The fractional rms amplitude contained between <code class="docutils literal notranslate"><span class="pre">min_freq</span></code> and
<code class="docutils literal notranslate"><span class="pre">max_freq</span></code>.</p>
</dd>
<dt>rms_err: float</dt><dd><p>The error on the fractional rms amplitude.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poisson_noise_level</strong><span class="classifier">float, default is None</span></dt><dd><p>This is the Poisson noise level of the PDS with same
normalization as the PDS.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.data_attributes">
<span class="sig-name descname"><span class="pre">data_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.data_attributes" title="Link to this definition">¶</a></dt>
<dd><p>Clean up the list of attributes, only giving out those pointing to data.</p>
<p>List all the attributes that point directly to valid data. This method goes through all the
attributes of the class, eliminating methods, properties, and attributes that are complicated
to serialize such as other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code>, or arrays of objects.</p>
<p>This function does not make difference between array-like data and scalar data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data_attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of attributes pointing to data that are not methods, properties,
or other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code> instances.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.deadtime_correct">
<span class="sig-name descname"><span class="pre">deadtime_correct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dead_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paralyzable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.deadtime_correct" title="Link to this definition">¶</a></dt>
<dd><p>Correct the power spectrum for dead time effects.</p>
<p>This correction is based on the formula given in Zhang et al. 2015, assuming
a constant dead time for all events.
For more advanced dead time corrections, see the FAD method from <a class="reference internal" href="#module-stingray.deadtime.fad" title="stingray.deadtime.fad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.deadtime.fad</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dead_time: float</strong></dt><dd><p>The dead time of the detector.</p>
</dd>
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>Detected source count rate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>spectrum: <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> or derivative.</dt><dd><p>The dead-time corrected spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>background_rate</strong><span class="classifier">float, default 0</span></dt><dd><p>Detected background count rate. This is important to estimate when deadtime is given by the
combination of the source counts and background counts (e.g. in an imaging X-ray detector).</p>
</dd>
<dt><strong>paralyzable: bool, default False</strong></dt><dd><p>If True, the dead time correction is done assuming a paralyzable
dead time. If False, the correction is done assuming a non-paralyzable
(more common) dead time.</p>
</dd>
<dt><strong>limit_k</strong><span class="classifier">int, default 200</span></dt><dd><p>Limit to this value the number of terms in the inner loops of
calculations. Check the plots returned by  the <code class="xref py py-obj docutils literal notranslate"><span class="pre">check_B</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">check_A</span></code> functions to test that this number is adequate.</p>
</dd>
<dt><strong>n_approx</strong><span class="classifier">int, default None</span></dt><dd><p>Number of bins to calculate the model power spectrum. If None, it will use the size of
the input frequency array. Relatively simple models (e.g., low count rates compared to
dead time) can use a smaller number of bins to speed up the calculation, and the final
power values will be interpolated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.dict">
<span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.dict" title="Link to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.from_astropy_table">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Table</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.from_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create a Stingray Object object from data in an Astropy Table.</p>
<p>The table MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.from_events">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">events2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.from_events" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two event lists</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.EventList</span></code></span></dt><dd><p>Events from channel 1</p>
</dd>
<dt><strong>events2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.EventList</span></code></span></dt><dd><p>Events from channel 2</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.from_lc_iterable">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lc_iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iter_lc1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_lc2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.from_lc_iterable" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two light curves</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>iter_lc1</strong><span class="classifier">iterable of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects or <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Light curves from channel 1. If arrays, use them as counts</p>
</dd>
<dt><strong>iter_lc1</strong><span class="classifier">iterable of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects or <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Light curves from channel 2. If arrays, use them as counts</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
<dt><strong>save_all</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, save the cross spectrum of each segment in the <code class="docutils literal notranslate"><span class="pre">cs_all</span></code>
attribute of the output <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.from_lightcurve">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lightcurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.from_lightcurve" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two light curves</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lc1</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a></span></dt><dd><p>Light curve from channel 1</p>
</dd>
<dt><strong>lc2</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a></span></dt><dd><p>Light curve from channel 2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.from_pandas">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">DataFrame</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.from_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create an <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object from data in a pandas DataFrame.</p>
<p>The dataframe MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays can be
specified as <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_1d_arrays_into_nd</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.from_stingray_timeseries">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_stingray_timeseries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux_attr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_flux_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.from_stingray_timeseries" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two light curves</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ts1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Timeseries</span></code></span></dt><dd><p>Time series from channel 1</p>
</dd>
<dt><strong>ts2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Timeseries</span></code></span></dt><dd><p>Time series from channel 2</p>
</dd>
<dt><strong>flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>error_flux_attr</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>What attribute of the time series will be used as error bar.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be averaged.
Only relevant (and required) for AveragedCrossspectrum</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
<dt><strong>gti: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</strong></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t  use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.from_time_array">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_time_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fullspec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_common_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.from_time_array" title="Link to this definition">¶</a></dt>
<dd><p>Calculate AveragedCrossspectrum from two arrays of event times.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>times1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Event arrival times of channel 1</p>
</dd>
<dt><strong>times2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Event arrival times of channel 2</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the intermediate light curves
(sets the Nyquist frequency)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length, in seconds, of the light curve segments that will be
averaged. Only relevant (and required) for <a class="reference internal" href="#stingray.AveragedCrossspectrum" title="stingray.AveragedCrossspectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AveragedCrossspectrum</span></code></a>.</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti0, gti1], …]</span></dt><dd><p>Good Time intervals. Defaults to the common GTIs from the two input
objects. Could throw errors if these GTIs have overlaps with the
input object GTIs! If you’re getting errors regarding your GTIs,
don’t use this and only give GTIs to the input objects before
making the cross spectrum.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str, default “frac”</span></dt><dd><p>The normalization of the periodogram. “abs” is absolute rms, “frac” is
fractional rms, “leahy” is Leahy+83 normalization, and “none” is the
unnormalized periodogram</p>
</dd>
<dt><strong>use_common_mean</strong><span class="classifier">bool, default True</span></dt><dd><p>The mean of the light curve can be estimated in each interval, or on
the full light curve. This gives different results (Alston+2013).
Here we assume the mean is calculated on the full light curve, but
the user can set <code class="docutils literal notranslate"><span class="pre">use_common_mean</span></code> to False to calculate it on a
per-segment basis.</p>
</dd>
<dt><strong>fullspec</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the full periodogram, including negative frequencies</p>
</dd>
<dt><strong>silent</strong><span class="classifier">bool, default False</span></dt><dd><p>Silence the progress bars</p>
</dd>
<dt><strong>power_type</strong><span class="classifier">str, default ‘all’</span></dt><dd><p>If ‘all’, give complex powers. If ‘abs’, the absolute value; if ‘real’,
the real part</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.from_xarray">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_xarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dataset</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.from_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> from data in an xarray Dataset.</p>
<p>The dataset MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.get_meta_dict">
<span class="sig-name descname"><span class="pre">get_meta_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.get_meta_dict" title="Link to this definition">¶</a></dt>
<dd><p>Give a dictionary with all non-None meta attrs of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.initial_checks">
<span class="sig-name descname"><span class="pre">initial_checks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.initial_checks" title="Link to this definition">¶</a></dt>
<dd><p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev1</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ev2</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ac</span> <span class="o">=</span> <span class="n">AveragedCrossspectrum</span><span class="p">()</span>
</pre></div>
</div>
<p>If AveragedCrossspectrum, you need <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>
&gt;&gt;&gt; AveragedCrossspectrum.initial_checks(ac, data1=ev1, data2=ev2, dt=1)
Traceback (most recent call last):
…
ValueError: segment_size must be specified…</p>
<p>And it needs to be finite!
&gt;&gt;&gt; AveragedCrossspectrum.initial_checks(ac, data1=ev1, data2=ev2, dt=1., segment_size=np.nan)
Traceback (most recent call last):
…
ValueError: segment_size must be finite!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.internal_array_attrs">
<span class="sig-name descname"><span class="pre">internal_array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.internal_array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the internal array attributes of the Stingray Object.</p>
<p>These are array attributes that can be set by properties, and are generally indicated
by an underscore followed by the name of the property that links to it (E.g.
<code class="docutils literal notranslate"><span class="pre">_counts</span></code> in <code class="docutils literal notranslate"><span class="pre">Lightcurve</span></code>).
By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of internal array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.meta_attrs">
<span class="sig-name descname"><span class="pre">meta_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.meta_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the meta attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with a different size and shape
than <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of meta attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.phase_lag">
<span class="sig-name descname"><span class="pre">phase_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.phase_lag" title="Link to this definition">¶</a></dt>
<dd><p>Return the fourier phase lag of the cross spectrum.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the amplitude of the cross spectrum vs. the frequency using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier">iterable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A list of tuple with <code class="docutils literal notranslate"><span class="pre">xlabel</span></code> and <code class="docutils literal notranslate"><span class="pre">ylabel</span></code> as strings.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for the``matplotlib.pyplot.axis()`` method.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The title of the plot.</p>
</dd>
<dt><strong>marker</strong><span class="classifier">str, default ‘-’</span></dt><dd><p>Line style and color of the plot. Line styles and colors are
combined in a single format string, as in <code class="docutils literal notranslate"><span class="pre">'bo'</span></code> for blue
circles. See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> for more options.</p>
</dd>
<dt><strong>save</strong><span class="classifier">boolean, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.Axes</span></code> object</span></dt><dd><p>An axes object to fill with the cross correlation plot.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.power_colors">
<span class="sig-name descname"><span class="pre">power_colors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freq_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.00390625,</span> <span class="pre">0.03125,</span> <span class="pre">0.25,</span> <span class="pre">2.0,</span> <span class="pre">16.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freqs_to_exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poisson_power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#DynamicalPowerspectrum.power_colors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.DynamicalPowerspectrum.power_colors" title="Link to this definition">¶</a></dt>
<dd><p>Return the power colors of the dynamical power spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freq_edges: iterable</strong></dt><dd><p>The edges of the frequency bins to be used for the power colors.</p>
</dd>
<dt><strong>freqs_to_exclude</strong><span class="classifier">1-d or 2-d iterable, optional, default None</span></dt><dd><p>The ranges of frequencies to exclude from the calculation of the power color.
For example, the frequencies containing strong QPOs.
A 1-d iterable should contain two values for the edges of a single range. (E.g.
<code class="docutils literal notranslate"><span class="pre">[0.1,</span> <span class="pre">0.2]</span></code>). <code class="docutils literal notranslate"><span class="pre">[[0.1,</span> <span class="pre">0.2],</span> <span class="pre">[3,</span> <span class="pre">4]]</span></code> will exclude the ranges 0.1-0.2 Hz and
3-4 Hz.</p>
</dd>
<dt><strong>poisson_level</strong><span class="classifier">float or iterable, optional</span></dt><dd><p>Defaults to the theoretical Poisson noise level (e.g. 2 for Leahy normalization).
The Poisson noise level of the power spectrum. If iterable, it should have the same
length as <code class="docutils literal notranslate"><span class="pre">frequency</span></code>. (This might apply to the case of a power spectrum with a
strong dead time distortion)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>pc0: np.ndarray</dt><dd></dd>
<dt>pc0_err: np.ndarray</dt><dd></dd>
<dt>pc1: np.ndarray</dt><dd></dd>
<dt>pc1_err: np.ndarray</dt><dd><p>The power colors for each spectrum and their respective errors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.pretty_print">
<span class="sig-name descname"><span class="pre">pretty_print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.pretty_print" title="Link to this definition">¶</a></dt>
<dd><p>Return a pretty-printed string representation of the object.</p>
<p>This is useful for debugging, and for interactive use.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func_to_apply</strong><span class="classifier">function</span></dt><dd><p>A function that modifies the attributes listed in <code class="docutils literal notranslate"><span class="pre">attrs_to_apply</span></code>.
It must return the modified attributes and a label to be printed.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no function is applied.</p>
</dd>
<dt><strong>attrs_to_apply</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be modified by <code class="docutils literal notranslate"><span class="pre">func_to_apply</span></code>.</p>
</dd>
<dt><strong>attrs_to_discard</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be discarded from the output.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.read">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.read" title="Link to this definition">¶</a></dt>
<dd><p>Generic reader for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>Files that need the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> interface MUST contain
at least a column named like the <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The default ascii format is enhanced CSV (ECSV). Data formats
supporting the serialization of metadata (such as ECSV and HDF5) can
contain all attributes such as <code class="docutils literal notranslate"><span class="pre">mission</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc with
no significant loss of information. Other file formats might lose part
of the metadata, so must be used with care.</p>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values should be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Path and file name for the file to be read.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>Available options are ‘pickle’, ‘hea’, and any <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code>-supported
format such as ‘hdf5’, ‘ascii.ecsv’, etc.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>obj: <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> object</dt><dd><p>The object reconstructed from file</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.rebin">
<span class="sig-name descname"><span class="pre">rebin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.rebin" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the cross spectrum to a new frequency resolution <code class="docutils literal notranslate"><span class="pre">df</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: float</strong></dt><dd><p>The new frequency resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>bin_cs = <a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> (or one of its subclasses) object</dt><dd><p>The newly binned cross spectrum or power spectrum.
Note: this object will be of the same type as the object
that called this method. For example, if this method is called
from <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, it will return an object of class
<a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, too.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float</strong></dt><dd><p>the rebin factor. If specified, it substitutes df with <code class="docutils literal notranslate"><span class="pre">f*self.df</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.rebin_by_n_intervals">
<span class="sig-name descname"><span class="pre">rebin_by_n_intervals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'average'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.rebin_by_n_intervals" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the Dynamic Power Spectrum to a new time resolution, by summing contiguous intervals.</p>
<p>This is different from meth:<a class="reference internal" href="#stingray.DynamicalPowerspectrum.rebin_time" title="stingray.DynamicalPowerspectrum.rebin_time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.rebin_time</span></code></a> in that it averages <code class="docutils literal notranslate"><span class="pre">n</span></code>
consecutive intervals regardless of their distance in time. <code class="docutils literal notranslate"><span class="pre">rebin_time</span></code> will instead
average intervals that are separated at most by a time <code class="docutils literal notranslate"><span class="pre">dt_new</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n: int</strong></dt><dd><p>The number of intervals to be combined into one.</p>
</dd>
<dt><strong>method: {“sum” | “mean” | “average”}, optional, default “average”</strong></dt><dd><p>This keyword argument sets whether the powers in the new bins
should be summed or averaged.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>time_new: numpy.ndarray</dt><dd><p>Time axis with new rebinned time resolution.</p>
</dd>
<dt>dynspec_new: numpy.ndarray</dt><dd><p>New rebinned Dynamical Cross Spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.rebin_frequency">
<span class="sig-name descname"><span class="pre">rebin_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'average'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.rebin_frequency" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the Dynamic Power Spectrum to a new frequency resolution.
Rebinning is an in-place operation, i.e. will replace the existing
<code class="docutils literal notranslate"><span class="pre">dyn_ps</span></code> attribute.</p>
<p>While the new resolution does not need to be an integer of the previous frequency
resolution, be aware that if this is the case, the last frequency bin will be cut
off by the fraction left over by the integer division</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df_new: float</strong></dt><dd><p>The new frequency resolution of the dynamical power spectrum.
Must be larger than the frequency resolution of the old dynamical
power spectrum!</p>
</dd>
<dt><strong>method: {“sum” | “mean” | “average”}, optional, default “average”</strong></dt><dd><p>This keyword argument sets whether the powers in the new bins
should be summed or averaged.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.rebin_log">
<span class="sig-name descname"><span class="pre">rebin_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.rebin_log" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic rebin of the periodogram.
The new frequency depends on the previous frequency
modified by a factor f:</p>
<div class="math notranslate nohighlight">
\[d\nu_j = d\nu_{j-1} (1+f)\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f: float, optional, default ``0.01``</strong></dt><dd><p>parameter that steers the frequency resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>new_spec</strong><span class="classifier"><a class="reference internal" href="#stingray.Crossspectrum" title="stingray.Crossspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a> (or one of its subclasses) object</span></dt><dd><p>The newly binned cross spectrum or power spectrum.
Note: this object will be of the same type as the object
that called this method. For example, if this method is called
from <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a>, it will return an object of class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.rebin_time">
<span class="sig-name descname"><span class="pre">rebin_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'average'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.rebin_time" title="Link to this definition">¶</a></dt>
<dd><p>Rebin the Dynamic Power Spectrum to a new time resolution.</p>
<p>Note: this is <em>not</em> changing the time resolution of the input light
curve! <code class="docutils literal notranslate"><span class="pre">dt</span></code> is the integration time of each line of the dynamical power
spectrum (typically, an integer multiple of <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>).</p>
<p>While the new resolution does not need to be an integer of the previous time
resolution, be aware that if this is the case, the last time bin will be cut
off by the fraction left over by the integer division</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt_new: float</strong></dt><dd><p>The new time resolution of the dynamical power spectrum.
Must be larger than the time resolution of the old dynamical power
spectrum!</p>
</dd>
<dt><strong>method: {“sum” | “mean” | “average”}, optional, default “average”</strong></dt><dd><p>This keyword argument sets whether the powers in the new bins
should be summed or averaged.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>time_new: numpy.ndarray</dt><dd><p>Time axis with new rebinned time resolution.</p>
</dd>
<dt>dynspec_new: numpy.ndarray</dt><dd><p>New rebinned Dynamical Cross Spectrum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.shift_and_add">
<span class="sig-name descname"><span class="pre">shift_and_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f0_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rebin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/powerspectrum.html#DynamicalPowerspectrum.shift_and_add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.DynamicalPowerspectrum.shift_and_add" title="Link to this definition">¶</a></dt>
<dd><p>Shift-and-add the dynamical power spectrum.</p>
<p>This is the basic operation for the shift-and-add operation used to track
kHz QPOs in X-ray binaries (e.g. Méndez et al. 1998, ApJ, 494, 65).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freqs</strong><span class="classifier">np.array</span></dt><dd><p>Array of frequencies, the same for all powers. Must be sorted and on a uniform
grid.</p>
</dd>
<dt><strong>power_list</strong><span class="classifier">list of np.array</span></dt><dd><p>List of power spectra. Each power spectrum must have the same length
as the frequency array.</p>
</dd>
<dt><strong>f0_list</strong><span class="classifier">list of float</span></dt><dd><p>List of central frequencies</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a></dt><dd><p>The final averaged power spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbins</strong><span class="classifier">int, default 100</span></dt><dd><p>Number of bins to extract</p>
</dd>
<dt><strong>rebin</strong><span class="classifier">int, default None</span></dt><dd><p>Rebin the final spectrum by this factor. At the moment, the rebinning
is linear.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">power_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">power_list</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f0_list</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dps</span> <span class="o">=</span> <span class="n">DynamicalPowerspectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dps</span><span class="o">.</span><span class="n">dyn_ps</span> <span class="o">=</span> <span class="n">power_list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dps</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">freqs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dps</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dps</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span> <span class="o">=</span> <span class="n">dps</span><span class="o">.</span><span class="n">shift_and_add</span><span class="p">(</span><span class="n">f0_list</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">AveragedPowerspectrum</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.</span> <span class="p">,</span> <span class="mf">2.</span> <span class="p">,</span> <span class="mf">5.</span> <span class="p">,</span> <span class="mf">2.</span> <span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.45</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.sub" title="Link to this definition">¶</a></dt>
<dd><p>Subtract <em>all the array attrs</em> of two <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a> instances element by element, assuming the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#stingray.StingrayTimeseries" title="stingray.StingrayTimeseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.time_lag">
<span class="sig-name descname"><span class="pre">time_lag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.time_lag" title="Link to this definition">¶</a></dt>
<dd><p>Calculate time lag and uncertainty.</p>
<p>Equation from Bendat &amp; Piersol, 2011 [bendat-2011]__.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lag</strong><span class="classifier">np.ndarray</span></dt><dd><p>The time lag</p>
</dd>
<dt><strong>lag_err</strong><span class="classifier">np.ndarray</span></dt><dd><p>The uncertainty in the time lag</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.to_astropy_table">
<span class="sig-name descname"><span class="pre">to_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">no_longdouble</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><span class="pre">Table</span></a></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.to_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create an Astropy Table from a <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code></p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">meta</span></code> dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>no_longdouble</strong><span class="classifier">bool</span></dt><dd><p>If True, reduce the precision of longdouble arrays to double precision.
This needs to be done in some cases, e.g. when the table is to be saved
in an architecture not supporting extended precision (e.g. ARM), but can
also be useful when an extended precision is not needed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.to_norm">
<span class="sig-name descname"><span class="pre">to_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.to_norm" title="Link to this definition">¶</a></dt>
<dd><p>Convert Cross spectrum to new normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">str</span></dt><dd><p>The new normalization of the spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_spec</strong><span class="classifier">object, same class as input</span></dt><dd><p>The new, normalized, spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace: bool, default False</strong></dt><dd><p>If True, change the current instance. Otherwise, return a new one</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.to_pandas">
<span class="sig-name descname"><span class="pre">to_pandas</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.to_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays are
converted into columns before the conversion, with names <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_nd_into_arrays</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.to_xarray">
<span class="sig-name descname"><span class="pre">to_xarray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dataset</span></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.to_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create an <code class="docutils literal notranslate"><span class="pre">xarray</span></code> Dataset from a <a class="reference internal" href="#stingray.StingrayObject" title="stingray.StingrayObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code></a>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.trace_maximum">
<span class="sig-name descname"><span class="pre">trace_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.trace_maximum" title="Link to this definition">¶</a></dt>
<dd><p>Return the indices of the maximum powers in each segment
<a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Powerspectrum</span></code></a> between specified frequencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_freq: float, default ``None``</strong></dt><dd><p>The lower frequency bound.</p>
</dd>
<dt><strong>max_freq: float, default ``None``</strong></dt><dd><p>The upper frequency bound.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_positions</strong><span class="classifier">np.array</span></dt><dd><p>The array of indices of the maximum power in each segment having
frequency between <code class="docutils literal notranslate"><span class="pre">min_freq</span></code> and <code class="docutils literal notranslate"><span class="pre">max_freq</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.type">
<span class="sig-name descname"><span class="pre">type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'powerspectrum'</span></em><a class="headerlink" href="#stingray.DynamicalPowerspectrum.type" title="Link to this definition">¶</a></dt>
<dd><p>Create a dynamical power spectrum, also often called a <em>spectrogram</em>.</p>
<p>This class will divide a <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code></a> object into segments of
length <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>, create a power spectrum for each segment and store
all powers in a matrix as a function of both time (using the mid-point of
each segment) and frequency.</p>
<p>This is often used to trace changes in period of a (quasi-)periodic signal
over time.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lc</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.EventList</span></code> object</span></dt><dd><p>The time series or event list of which the dynamical power spectrum is
to be calculated. If <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.EventList</span></code>, <code class="docutils literal notranslate"><span class="pre">dt</span></code> must be specified as well.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float, default 1</span></dt><dd><p>Length of the segment of light curve, default value is 1 (in whatever
units the <code class="docutils literal notranslate"><span class="pre">time</span></code> array in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve`</span></code> object uses).</p>
</dd>
<dt><strong>norm: {“leahy” | “frac” | “abs” | “none” }, optional, default “frac”</strong></dt><dd><p>The normaliation of the periodogram to be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segment_size: float</strong></dt><dd><p>The size of each segment to average. Note that if the total
duration of each input object in lc is not an integer multiple
of the <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>, then any fraction left-over at the end of the
time series will be lost.</p>
</dd>
<dt><strong>dyn_ps</strong><span class="classifier">np.ndarray</span></dt><dd><p>The matrix of normalized squared absolute values of Fourier
amplitudes. The axis are given by the <code class="docutils literal notranslate"><span class="pre">freq</span></code>
and <code class="docutils literal notranslate"><span class="pre">time</span></code> attributes.</p>
</dd>
<dt><strong>norm: {``leahy`` | ``frac`` | ``abs`` | ``none``}</strong></dt><dd><p>The normalization of the periodogram.</p>
</dd>
<dt><strong>freq: numpy.ndarray</strong></dt><dd><p>The array of mid-bin frequencies that the Fourier transform samples.</p>
</dd>
<dt><strong>time: numpy.ndarray</strong></dt><dd><p>The array of mid-point times of each interval used for the dynamical
power spectrum.</p>
</dd>
<dt><strong>df: float</strong></dt><dd><p>The frequency resolution.</p>
</dd>
<dt><strong>dt: float</strong></dt><dd><p>The time resolution of the dynamical spectrum. It is <strong>not</strong> the time resolution of the
input light curve. It is the integration time of each line of the dynamical power
spectrum (typically, an integer multiple of <code class="docutils literal notranslate"><span class="pre">segment_size</span></code>).</p>
</dd>
<dt><strong>m: int</strong></dt><dd><p>The number of averaged cross spectra.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti: 2-d float array</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code> – Good Time intervals.
This choice overrides the GTIs in the single light curves. Use with
care, especially if these GTIs have overlaps with the input
object GTIs! If you’re getting errors regarding your GTIs, don’t
use this and only give GTIs to the input object before making
the power spectrum.</p>
</dd>
<dt><strong>sample_time: float</strong></dt><dd><p>Compulsory for input <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.EventList</span></code> data. The time resolution of the
lightcurve that is created internally from the input event lists. Drives the
Nyquist frequency.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.DynamicalPowerspectrum.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span></span><a class="headerlink" href="#stingray.DynamicalPowerspectrum.write" title="Link to this definition">¶</a></dt>
<dd><p>Generic writer for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values will be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Name and path of the file to save the object list to.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>The file format to store the data in.
Available options are <code class="docutils literal notranslate"><span class="pre">pickle</span></code>, <code class="docutils literal notranslate"><span class="pre">hdf5</span></code>, <code class="docutils literal notranslate"><span class="pre">ascii</span></code>, <code class="docutils literal notranslate"><span class="pre">fits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="crosscorrelation">
<h3>CrossCorrelation<a class="headerlink" href="#crosscorrelation" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.CrossCorrelation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">CrossCorrelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'same'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crosscorrelation.html#CrossCorrelation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.CrossCorrelation" title="Link to this definition">¶</a></dt>
<dd><p>Make a cross-correlation from light curves or a cross spectrum.</p>
<p>You can also make an empty <code class="xref py py-class docutils literal notranslate"><span class="pre">Crosscorrelation</span></code> object to populate
with your own cross-correlation data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lc1: :class:`stingray.Lightcurve` object, optional, default ``None``</strong></dt><dd><p>The first light curve data for correlation calculations.</p>
</dd>
<dt><strong>lc2: :class:`stingray.Lightcurve` object, optional, default ``None``</strong></dt><dd><p>The light curve data for the correlation calculations.</p>
</dd>
<dt><strong>cross: :class: `stingray.Crossspectrum` object, default ``None``</strong></dt><dd><p>The cross spectrum data for the correlation calculations.</p>
</dd>
<dt><strong>mode: {``full``, ``valid``, ``same``}, optional, default ``same``</strong></dt><dd><p>A string indicating the size of the correlation output.
See the relevant <code class="docutils literal notranslate"><span class="pre">scipy</span></code> documentation <a class="reference internal" href="#rea136657f880-scipy-docs" id="id13">[scipy-docs]</a>
for more details.</p>
</dd>
<dt><strong>norm: {``none``, ``variance``}</strong></dt><dd><p>if “variance”, the cross correlation is normalized so that perfect
correlation gives 1, and perfect anticorrelation gives -1. See
Gaskell &amp; Peterson 1987, Gardner &amp; Done 2017</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lc1: :class:`stingray.Lightcurve`</strong></dt><dd><p>The first light curve data for correlation calculations.</p>
</dd>
<dt><strong>lc2: :class:`stingray.Lightcurve`</strong></dt><dd><p>The light curve data for the correlation calculations.</p>
</dd>
<dt><strong>cross: :class: `stingray.Crossspectrum`</strong></dt><dd><p>The cross spectrum data for the correlation calculations.</p>
</dd>
<dt><strong>corr: numpy.ndarray</strong></dt><dd><p>An array of correlation data calculated from two light curves</p>
</dd>
<dt><strong>time_lags: numpy.ndarray</strong></dt><dd><p>An array of all possible time lags against which each point in corr is calculated</p>
</dd>
<dt><strong>dt: float</strong></dt><dd><p>The time resolution of each light curve (used in <code class="docutils literal notranslate"><span class="pre">time_lag</span></code> calculations)</p>
</dd>
<dt><strong>time_shift: float</strong></dt><dd><p>Time lag that gives maximum value of correlation between two light curves.
There will be maximum correlation between light curves if one of the light curve
is shifted by <code class="docutils literal notranslate"><span class="pre">time_shift</span></code>.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>Number of points in <code class="docutils literal notranslate"><span class="pre">self.corr</span></code> (length of cross-correlation data)</p>
</dd>
<dt><strong>auto: bool</strong></dt><dd><p>An internal flag to indicate whether this is a cross-correlation or an auto-correlation.</p>
</dd>
<dt><strong>norm: {``none``, ``variance``}</strong></dt><dd><p>The normalization specified in input</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rea136657f880-scipy-docs" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">scipy-docs</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.signal.correlate.html">https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.signal.correlate.html</a></p>
</div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.CrossCorrelation.cal_timeshift">
<span class="sig-name descname"><span class="pre">cal_timeshift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crosscorrelation.html#CrossCorrelation.cal_timeshift"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.CrossCorrelation.cal_timeshift" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the cross correlation against all possible time lags, both positive and negative.</p>
<p>The method signal.correlation_lags() uses SciPy versions &gt;= 1.6.1 (<a class="reference internal" href="#rca3968c368ff-scipy-docs-lag" id="id15">[scipy-docs-lag]</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt: float, optional, default ``1.0``</strong></dt><dd><p>Time resolution of the light curve, should be passed when object is populated with
correlation data and no information about light curve can be extracted. Used to
calculate <code class="docutils literal notranslate"><span class="pre">time_lags</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>self.time_shift: float</dt><dd><p>Value of the time lag that gives maximum value of correlation between two light curves.</p>
</dd>
<dt>self.time_lags: numpy.ndarray</dt><dd><p>An array of <code class="docutils literal notranslate"><span class="pre">time_lags</span></code> calculated from correlation data</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rca3968c368ff-scipy-docs-lag" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">scipy-docs-lag</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.correlation_lags.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.correlation_lags.html</a></p>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.CrossCorrelation.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crosscorrelation.html#CrossCorrelation.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.CrossCorrelation.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the <code class="xref py py-class docutils literal notranslate"><span class="pre">Crosscorrelation</span></code> as function using Matplotlib.
Plot the Crosscorrelation object on a graph <code class="docutils literal notranslate"><span class="pre">self.time_lags</span></code> on x-axis and
<code class="docutils literal notranslate"><span class="pre">self.corr</span></code> on y-axis</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier">iterable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A list of tuple with <code class="docutils literal notranslate"><span class="pre">xlabel</span></code> and <code class="docutils literal notranslate"><span class="pre">ylabel</span></code> as strings.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis()</span></code> function.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The title of the plot.</p>
</dd>
<dt><strong>marker</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">-</span></code></span></dt><dd><p>Line style and color of the plot. Line styles and colors are
combined in a single format string, as in <code class="docutils literal notranslate"><span class="pre">'bo'</span></code> for blue
circles. See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> for more options.</p>
</dd>
<dt><strong>save</strong><span class="classifier">boolean, optional (default=False)</span></dt><dd><p>If True, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.Axes</span></code> object</span></dt><dd><p>An axes object to fill with the cross correlation plot.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="autocorrelation">
<h3>AutoCorrelation<a class="headerlink" href="#autocorrelation" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.AutoCorrelation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">AutoCorrelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'same'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/crosscorrelation.html#AutoCorrelation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.AutoCorrelation" title="Link to this definition">¶</a></dt>
<dd><p>Make an auto-correlation from a light curve.
You can also make an empty Autocorrelation object to populate with your
own auto-correlation data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lc: :class:`stingray.Lightcurve` object, optional, default ``None``</strong></dt><dd><p>The light curve data for correlation calculations.</p>
</dd>
<dt><strong>mode: {``full``, ``valid``, ``same``}, optional, default ``same``</strong></dt><dd><p>A string indicating the size of the correlation output.
See the relevant <code class="docutils literal notranslate"><span class="pre">scipy</span></code> documentation [scipy-docs]
for more details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lc1, lc2::class:`stingray.Lightcurve`</strong></dt><dd><p>The light curve data for correlation calculations.</p>
</dd>
<dt><strong>corr: numpy.ndarray</strong></dt><dd><p>An array of correlation data calculated from lightcurve data</p>
</dd>
<dt><strong>time_lags: numpy.ndarray</strong></dt><dd><p>An array of all possible time lags against which each point in corr is calculated</p>
</dd>
<dt><strong>dt: float</strong></dt><dd><p>The time resolution of each lightcurve (used in time_lag calculations)</p>
</dd>
<dt><strong>time_shift: float, zero</strong></dt><dd><p>Max. Value of AutoCorrelation is always at zero lag.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>Number of points in self.corr(Length of auto-correlation data)</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.AutoCorrelation.cal_timeshift">
<span class="sig-name descname"><span class="pre">cal_timeshift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AutoCorrelation.cal_timeshift" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the cross correlation against all possible time lags, both positive and negative.</p>
<p>The method signal.correlation_lags() uses SciPy versions &gt;= 1.6.1 (<a class="reference internal" href="#r705d3882f4c8-scipy-docs-lag" id="id17">[scipy-docs-lag]</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt: float, optional, default ``1.0``</strong></dt><dd><p>Time resolution of the light curve, should be passed when object is populated with
correlation data and no information about light curve can be extracted. Used to
calculate <code class="docutils literal notranslate"><span class="pre">time_lags</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>self.time_shift: float</dt><dd><p>Value of the time lag that gives maximum value of correlation between two light curves.</p>
</dd>
<dt>self.time_lags: numpy.ndarray</dt><dd><p>An array of <code class="docutils literal notranslate"><span class="pre">time_lags</span></code> calculated from correlation data</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r705d3882f4c8-scipy-docs-lag" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">scipy-docs-lag</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.correlation_lags.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.correlation_lags.html</a></p>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.AutoCorrelation.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.AutoCorrelation.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot the <code class="xref py py-class docutils literal notranslate"><span class="pre">Crosscorrelation</span></code> as function using Matplotlib.
Plot the Crosscorrelation object on a graph <code class="docutils literal notranslate"><span class="pre">self.time_lags</span></code> on x-axis and
<code class="docutils literal notranslate"><span class="pre">self.corr</span></code> on y-axis</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier">iterable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A list of tuple with <code class="docutils literal notranslate"><span class="pre">xlabel</span></code> and <code class="docutils literal notranslate"><span class="pre">ylabel</span></code> as strings.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis()</span></code> function.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The title of the plot.</p>
</dd>
<dt><strong>marker</strong><span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">-</span></code></span></dt><dd><p>Line style and color of the plot. Line styles and colors are
combined in a single format string, as in <code class="docutils literal notranslate"><span class="pre">'bo'</span></code> for blue
circles. See <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot</span></code> for more options.</p>
</dd>
<dt><strong>save</strong><span class="classifier">boolean, optional (default=False)</span></dt><dd><p>If True, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.Axes</span></code> object</span></dt><dd><p>An axes object to fill with the cross correlation plot.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="module-stingray.deadtime.fad">
<span id="dead-time-corrections"></span><h3>Dead-Time Corrections<a class="headerlink" href="#module-stingray.deadtime.fad" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="stingray.deadtime.fad.FAD">
<span class="sig-prename descclassname"><span class="pre">stingray.deadtime.fad.</span></span><span class="sig-name descname"><span class="pre">FAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_objects</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/deadtime/fad.html#FAD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.deadtime.fad.FAD" title="Link to this definition">¶</a></dt>
<dd><p>Calculate Frequency Amplitude Difference-corrected (cross)power spectra.</p>
<p>Reference: Bachetti &amp; Huppenkothen, 2018, ApJ, 853L, 21</p>
<p>The two input light curve must be strictly simultaneous, and recorded by
two independent detectors with similar responses, so that the count rates
are similar and dead time is independent.
The method does not apply to different energy channels of the same
instrument, or to the signal observed by two instruments with very
different responses. See the paper for caveats.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>data1</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lightcurve</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">EventList</span></code></span></dt><dd><p>Input data for channel 1</p>
</dd>
<dt><strong>data2</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lightcurve</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">EventList</span></code></span></dt><dd><p>Input data for channel 2. Must be strictly simultaneous to <code class="docutils literal notranslate"><span class="pre">data1</span></code>
and, if a light curve, have the same binning time. Also, it must be
strictly independent, e.g. from a different detector. There must be
no dead time cross-talk between the two time series.</p>
</dd>
<dt><strong>segment_size: float</strong></dt><dd><p>The final Fourier products are averaged over many segments of the
input light curves. This is the length of each segment being averaged.
Note that the light curve must be long enough to have at least 30
segments, as the result gets better as one averages more and more
segments.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>Time resolution of the light curves used to produce periodograms</p>
</dd>
<dt><strong>norm: {``frac``, ``abs``, ``leahy``, ``none``}, default ``none``</strong></dt><dd><p>The normalization of the (real part of the) cross spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier">class:<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> object or <code class="docutils literal notranslate"><span class="pre">dict</span></code> or <code class="docutils literal notranslate"><span class="pre">str</span></code></span></dt><dd><p>The content of <code class="docutils literal notranslate"><span class="pre">results</span></code> depends on whether <code class="docutils literal notranslate"><span class="pre">return_objects</span></code> is
True or False.
If <code class="docutils literal notranslate"><span class="pre">return_objects==False</span></code>,
<code class="docutils literal notranslate"><span class="pre">results</span></code> is a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code> with the following columns:</p>
<ul class="simple">
<li><p>pds1: the corrected PDS of <code class="docutils literal notranslate"><span class="pre">lc1</span></code></p></li>
<li><p>pds2: the corrected PDS of <code class="docutils literal notranslate"><span class="pre">lc2</span></code></p></li>
<li><p>cs: the corrected cospectrum</p></li>
<li><p>ptot: the corrected PDS of lc1 + lc2</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">return_objects</span></code> is True, <code class="docutils literal notranslate"><span class="pre">results</span></code> is a <code class="docutils literal notranslate"><span class="pre">dict</span></code>, with keys
named like the columns
listed above but with <code class="xref py py-obj docutils literal notranslate"><span class="pre">AveragePowerspectrum</span></code> or
<code class="xref py py-obj docutils literal notranslate"><span class="pre">AverageCrossspectrum</span></code> objects instead of arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>plot</strong><span class="classifier">bool, default False</span></dt><dd><p>Plot diagnostics: check if the smoothed Fourier difference scatter is
a good approximation of the data scatter.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.axes</span></code> object</span></dt><dd><dl class="simple">
<dt>If not None and <code class="docutils literal notranslate"><span class="pre">plot</span></code> is True, use this axis object to produce</dt><dd><p>the diagnostic plot. Otherwise, create a new figure.</p>
</dd>
</dl>
</dd>
<dt><strong>smoothing_alg</strong><span class="classifier">{‘gauss’, …}</span></dt><dd><p>Smoothing algorithm. For now, the only smoothing algorithm allowed is
<code class="docutils literal notranslate"><span class="pre">gauss</span></code>, which applies a Gaussian Filter from <a class="reference external" href="https://docs.scipy.org/doc/scipy/index.html#module-scipy" title="(in SciPy v1.14.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy</span></code></a>.</p>
</dd>
<dt><strong>smoothing_length</strong><span class="classifier">int, default <code class="docutils literal notranslate"><span class="pre">segment_size</span> <span class="pre">*</span> <span class="pre">3</span></code></span></dt><dd><p>Number of bins to smooth in gaussian window smoothing</p>
</dd>
<dt><strong>verbose: bool, default False</strong></dt><dd><p>Print out information on the outcome of the algorithm (recommended)</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, default 0.05</span></dt><dd><p>Accepted relative error on the FAD-corrected Fourier amplitude, to be
used as success diagnostics.
Should be
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">stdtheor</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">/</span> <span class="pre">np.sqrt(n)</span>
<span class="pre">std</span> <span class="pre">=</span> <span class="pre">(average_corrected_fourier_diff</span> <span class="pre">/</span> <span class="pre">n).std()</span>
<span class="pre">np.abs((std</span> <span class="pre">-</span> <span class="pre">stdtheor)</span> <span class="pre">/</span> <span class="pre">stdtheor)</span> <span class="pre">&lt;</span> <span class="pre">tolerance</span>
<span class="pre">`</span></code></p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool, default False</span></dt><dd><p>Decide what to do if the condition on tolerance is not met. If True,
raise a <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code>. If False, just throw a warning.</p>
</dd>
<dt><strong>output_file</strong><span class="classifier">str, default None</span></dt><dd><p>Name of an output file (any extension automatically recognized by
Astropy is fine)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.deadtime.fad.calculate_FAD_correction">
<span class="sig-prename descclassname"><span class="pre">stingray.deadtime.fad.</span></span><span class="sig-name descname"><span class="pre">calculate_FAD_correction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'frac'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_objects</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/deadtime/fad.html#calculate_FAD_correction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.deadtime.fad.calculate_FAD_correction" title="Link to this definition">¶</a></dt>
<dd><p>Calculate Frequency Amplitude Difference-corrected (cross)power spectra.</p>
<p>Reference: Bachetti &amp; Huppenkothen, 2018, ApJ, 853L, 21</p>
<p>The two input light curve must be strictly simultaneous, and recorded by
two independent detectors with similar responses, so that the count rates
are similar and dead time is independent.
The method does not apply to different energy channels of the same
instrument, or to the signal observed by two instruments with very
different responses. See the paper for caveats.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lc1: class:`stingray.ligthtcurve.Lightcurve`</strong></dt><dd><p>Light curve from channel 1</p>
</dd>
<dt><strong>lc2: class:`stingray.ligthtcurve.Lightcurve`</strong></dt><dd><p>Light curve from channel 2. Must be strictly simultaneous to <code class="docutils literal notranslate"><span class="pre">lc1</span></code>
and have the same binning time. Also, it must be strictly independent,
e.g. from a different detector. There must be no dead time cross-talk
between the two light curves.</p>
</dd>
<dt><strong>segment_size: float</strong></dt><dd><p>The final Fourier products are averaged over many segments of the
input light curves. This is the length of each segment being averaged.
Note that the light curve must be long enough to have at least 30
segments, as the result gets better as one averages more and more
segments.</p>
</dd>
<dt><strong>norm: {``frac``, ``abs``, ``leahy``, ``none``}, default ``none``</strong></dt><dd><p>The normalization of the (real part of the) cross spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier">class:<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> object or <code class="docutils literal notranslate"><span class="pre">dict</span></code> or <code class="docutils literal notranslate"><span class="pre">str</span></code></span></dt><dd><p>The content of <code class="docutils literal notranslate"><span class="pre">results</span></code> depends on whether <code class="docutils literal notranslate"><span class="pre">return_objects</span></code> is
True or False.
If <code class="docutils literal notranslate"><span class="pre">return_objects==False</span></code>,
<code class="docutils literal notranslate"><span class="pre">results</span></code> is a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code> with the following columns:</p>
<ul class="simple">
<li><p>pds1: the corrected PDS of <code class="docutils literal notranslate"><span class="pre">lc1</span></code></p></li>
<li><p>pds2: the corrected PDS of <code class="docutils literal notranslate"><span class="pre">lc2</span></code></p></li>
<li><p>cs: the corrected cospectrum</p></li>
<li><p>ptot: the corrected PDS of lc1 + lc2</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">return_objects</span></code> is True, <code class="docutils literal notranslate"><span class="pre">results</span></code> is a <code class="docutils literal notranslate"><span class="pre">dict</span></code>, with keys
named like the columns
listed above but with <code class="xref py py-obj docutils literal notranslate"><span class="pre">AveragePowerspectrum</span></code> or
<code class="xref py py-obj docutils literal notranslate"><span class="pre">AverageCrossspectrum</span></code> objects instead of arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>plot</strong><span class="classifier">bool, default False</span></dt><dd><p>Plot diagnostics: check if the smoothed Fourier difference scatter is
a good approximation of the data scatter.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.axes</span></code> object</span></dt><dd><dl class="simple">
<dt>If not None and <code class="docutils literal notranslate"><span class="pre">plot</span></code> is True, use this axis object to produce</dt><dd><p>the diagnostic plot. Otherwise, create a new figure.</p>
</dd>
</dl>
</dd>
<dt><strong>smoothing_alg</strong><span class="classifier">{‘gauss’, …}</span></dt><dd><p>Smoothing algorithm. For now, the only smoothing algorithm allowed is
<code class="docutils literal notranslate"><span class="pre">gauss</span></code>, which applies a Gaussian Filter from <a class="reference external" href="https://docs.scipy.org/doc/scipy/index.html#module-scipy" title="(in SciPy v1.14.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy</span></code></a>.</p>
</dd>
<dt><strong>smoothing_length</strong><span class="classifier">int, default <code class="docutils literal notranslate"><span class="pre">segment_size</span> <span class="pre">*</span> <span class="pre">3</span></code></span></dt><dd><p>Number of bins to smooth in gaussian window smoothing</p>
</dd>
<dt><strong>verbose: bool, default False</strong></dt><dd><p>Print out information on the outcome of the algorithm (recommended)</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, default 0.05</span></dt><dd><p>Accepted relative error on the FAD-corrected Fourier amplitude, to be
used as success diagnostics.
Should be
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">stdtheor</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">/</span> <span class="pre">np.sqrt(n)</span>
<span class="pre">std</span> <span class="pre">=</span> <span class="pre">(average_corrected_fourier_diff</span> <span class="pre">/</span> <span class="pre">n).std()</span>
<span class="pre">np.abs((std</span> <span class="pre">-</span> <span class="pre">stdtheor)</span> <span class="pre">/</span> <span class="pre">stdtheor)</span> <span class="pre">&lt;</span> <span class="pre">tolerance</span>
<span class="pre">`</span></code></p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool, default False</span></dt><dd><p>Decide what to do if the condition on tolerance is not met. If True,
raise a <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code>. If False, just throw a warning.</p>
</dd>
<dt><strong>output_file</strong><span class="classifier">str, default None</span></dt><dd><p>Name of an output file (any extension automatically recognized by
Astropy is fine)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.deadtime.fad.get_periodograms_from_FAD_results">
<span class="sig-prename descclassname"><span class="pre">stingray.deadtime.fad.</span></span><span class="sig-name descname"><span class="pre">get_periodograms_from_FAD_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">FAD_results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ptot'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/deadtime/fad.html#get_periodograms_from_FAD_results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.deadtime.fad.get_periodograms_from_FAD_results" title="Link to this definition">¶</a></dt>
<dd><p>Get Stingray periodograms from FAD results.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>FAD_results</strong><span class="classifier"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> object or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></span></dt><dd><p>Results from <a class="reference internal" href="#stingray.deadtime.fad.calculate_FAD_correction" title="stingray.deadtime.fad.calculate_FAD_correction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_FAD_correction</span></code></a>, either as a Table or an output
file name</p>
</dd>
<dt><strong>kind</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, one of [‘ptot’, ‘pds1’, ‘pds2’, ‘cs’]</span></dt><dd><p>Kind of periodogram to get (E.g., ‘ptot’ -&gt; PDS from the sum of the two
light curves, ‘cs’ -&gt; cospectrum, etc.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AveragedCrossspectrum</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Averagedpowerspectrum</span></code> object</span></dt><dd><p>The periodogram.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-stingray.deadtime.model"></span><dl class="py function">
<dt class="sig sig-object py" id="stingray.deadtime.model.check_A">
<span class="sig-prename descclassname"><span class="pre">stingray.deadtime.model.</span></span><span class="sig-name descname"><span class="pre">check_A</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">td</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linthresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate_is_incident</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/deadtime/model.html#check_A"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.deadtime.model.check_A" title="Link to this definition">¶</a></dt>
<dd><p>Test that A is well-behaved.</p>
<p>This function produces a plot of <span class="math notranslate nohighlight">\(A_k - r_0^2 t_b^2\)</span> vs <span class="math notranslate nohighlight">\(k\)</span>, to visually check that
<span class="math notranslate nohighlight">\(A_k \rightarrow r_0^2 t_b^2\)</span> for <span class="math notranslate nohighlight">\(k\rightarrow\infty\)</span>, as per Eq. 43 in Zhang+95.</p>
<p>With this function is possible to determine how many inner loops <code class="xref py py-obj docutils literal notranslate"><span class="pre">k</span></code> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">limit_k</span></code> in function
pds_model_zhang) are necessary for a correct approximation of the dead time model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>Count rate, either incident or detected (use the <code class="xref py py-obj docutils literal notranslate"><span class="pre">rate_is_incident</span></code> bool to specify)</p>
</dd>
<dt><strong>td</strong><span class="classifier">float</span></dt><dd><p>Dead time</p>
</dd>
<dt><strong>tb</strong><span class="classifier">float</span></dt><dd><p>Bin time of the light curve</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_k</strong><span class="classifier">int</span></dt><dd><p>Maximum k to plot</p>
</dd>
<dt><strong>save_to</strong><span class="classifier">str, default None</span></dt><dd><p>If not None, save the plot to this file</p>
</dd>
<dt><strong>linthresh</strong><span class="classifier">float, default 0.000001</span></dt><dd><p>Linear threshold for the “symlog” scale of the plot</p>
</dd>
<dt><strong>rate_is_incident</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, the input rate is the incident count rate. If False, it is the detected one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.deadtime.model.check_B">
<span class="sig-prename descclassname"><span class="pre">stingray.deadtime.model.</span></span><span class="sig-name descname"><span class="pre">check_B</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">td</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linthresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate_is_incident</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/deadtime/model.html#check_B"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.deadtime.model.check_B" title="Link to this definition">¶</a></dt>
<dd><p>Check that <span class="math notranslate nohighlight">\(B\rightarrow 0\)</span> for <span class="math notranslate nohighlight">\(k\rightarrow \infty\)</span>.</p>
<p>This function produces a plot of <span class="math notranslate nohighlight">\(B_k\)</span> vs <span class="math notranslate nohighlight">\(k\)</span>, to visually check that
<span class="math notranslate nohighlight">\(B_k \rightarrow 0\)</span> for <span class="math notranslate nohighlight">\(k\rightarrow\infty\)</span>, as per Eq. 43 in Zhang+95.</p>
<p>With this function is possible to determine how many inner loops <code class="xref py py-obj docutils literal notranslate"><span class="pre">k</span></code> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">limit_k</span></code> in function
pds_model_zhang) are necessary for a correct approximation of the dead time model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>Count rate, either incident or detected (use the <code class="xref py py-obj docutils literal notranslate"><span class="pre">rate_is_incident</span></code> bool to specify)</p>
</dd>
<dt><strong>td</strong><span class="classifier">float</span></dt><dd><p>Dead time</p>
</dd>
<dt><strong>tb</strong><span class="classifier">float</span></dt><dd><p>Bin time of the light curve</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_k</strong><span class="classifier">int</span></dt><dd><p>Maximum k to plot</p>
</dd>
<dt><strong>save_to</strong><span class="classifier">str, default None</span></dt><dd><p>If not None, save the plot to this file</p>
</dd>
<dt><strong>linthresh</strong><span class="classifier">float, default 0.000001</span></dt><dd><p>Linear threshold for the “symlog” scale of the plot</p>
</dd>
<dt><strong>rate_is_incident</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, the input rate is the incident count rate. If False, it is the detected one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.deadtime.model.non_paralyzable_dead_time_model">
<span class="sig-prename descclassname"><span class="pre">stingray.deadtime.model.</span></span><span class="sig-name descname"><span class="pre">non_paralyzable_dead_time_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dead_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/deadtime/model.html#non_paralyzable_dead_time_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.deadtime.model.non_paralyzable_dead_time_model" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the dead-time-modified power spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freqs</strong><span class="classifier">array of floats</span></dt><dd><p>Frequency array</p>
</dd>
<dt><strong>dead_time</strong><span class="classifier">float</span></dt><dd><p>Dead time</p>
</dd>
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>Detected source count rate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>power</strong><span class="classifier">array of floats</span></dt><dd><p>Power spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bin_time</strong><span class="classifier">float</span></dt><dd><p>Bin time of the light curve</p>
</dd>
<dt><strong>limit_k</strong><span class="classifier">int, default 200</span></dt><dd><p>Limit to this value the number of terms in the inner loops of
calculations. Check the plots returned by  the <a class="reference internal" href="#stingray.deadtime.model.check_B" title="stingray.deadtime.model.check_B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_B</span></code></a> and
<a class="reference internal" href="#stingray.deadtime.model.check_A" title="stingray.deadtime.model.check_A"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_A</span></code></a> functions to test that this number is adequate.</p>
</dd>
<dt><strong>background_rate</strong><span class="classifier">float, default 0</span></dt><dd><p>Detected background count rate. This is important to estimate when deadtime is given by the
combination of the source counts and background counts (e.g. in an imaging X-ray detector).</p>
</dd>
<dt><strong>n_approx</strong><span class="classifier">int, default None</span></dt><dd><p>Number of bins to calculate the model power spectrum. If None, it will use the size of
the input frequency array. Relatively simple models (e.g., low count rates compared to
dead time) can use a smaller number of bins to speed up the calculation, and the final
power values will be interpolated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.deadtime.model.pds_model_zhang">
<span class="sig-prename descclassname"><span class="pre">stingray.deadtime.model.</span></span><span class="sig-name descname"><span class="pre">pds_model_zhang</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">td</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rate_is_incident</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/deadtime/model.html#pds_model_zhang"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.deadtime.model.pds_model_zhang" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the dead-time-modified power spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>The number of spectral bins</p>
</dd>
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>Incident count rate</p>
</dd>
<dt><strong>td</strong><span class="classifier">float</span></dt><dd><p>Dead time</p>
</dd>
<dt><strong>tb</strong><span class="classifier">float</span></dt><dd><p>Bin time of the light curve</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>freqs</strong><span class="classifier">array of floats</span></dt><dd><p>Frequency array</p>
</dd>
<dt><strong>power</strong><span class="classifier">array of floats</span></dt><dd><p>Power spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>limit_k</strong><span class="classifier">int</span></dt><dd><p>Limit to this value the number of terms in the inner loops of
calculations. Check the plots returned by  the <a class="reference internal" href="#stingray.deadtime.model.check_B" title="stingray.deadtime.model.check_B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_B</span></code></a> and
<a class="reference internal" href="#stingray.deadtime.model.check_A" title="stingray.deadtime.model.check_A"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_A</span></code></a> functions to test that this number is adequate.</p>
</dd>
<dt><strong>rate_is_incident</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, the input rate is the incident count rate. If False, it is the
detected count rate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.deadtime.model.r_det">
<span class="sig-prename descclassname"><span class="pre">stingray.deadtime.model.</span></span><span class="sig-name descname"><span class="pre">r_det</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">td</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/deadtime/model.html#r_det"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.deadtime.model.r_det" title="Link to this definition">¶</a></dt>
<dd><p>Calculate detected countrate given dead time and incident countrate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>td</strong><span class="classifier">float</span></dt><dd><p>Dead time</p>
</dd>
<dt><strong>r_i</strong><span class="classifier">float</span></dt><dd><p>Incident countrate</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.deadtime.model.r_in">
<span class="sig-prename descclassname"><span class="pre">stingray.deadtime.model.</span></span><span class="sig-name descname"><span class="pre">r_in</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">td</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/deadtime/model.html#r_in"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.deadtime.model.r_in" title="Link to this definition">¶</a></dt>
<dd><p>Calculate incident countrate given dead time and detected countrate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>td</strong><span class="classifier">float</span></dt><dd><p>Dead time</p>
</dd>
<dt><strong>r_0</strong><span class="classifier">float</span></dt><dd><p>Detected countrate</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<hr class="docutils" />
<section id="higher-order-fourier-and-spectral-timing-products">
<h2>Higher-Order Fourier and Spectral Timing Products<a class="headerlink" href="#higher-order-fourier-and-spectral-timing-products" title="Link to this heading">¶</a></h2>
<p>These classes implement higher-order Fourier analysis products (e.g. <code class="xref py py-class docutils literal notranslate"><span class="pre">Bispectrum</span></code>) and
Spectral Timing related methods taking advantage of both temporal and spectral information in
modern data sets.</p>
<section id="bispectrum">
<h3>Bispectrum<a class="headerlink" href="#bispectrum" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.bispectrum.Bispectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.bispectrum.</span></span><span class="sig-name descname"><span class="pre">Bispectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'biased'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/bispectrum.html#Bispectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.bispectrum.Bispectrum" title="Link to this definition">¶</a></dt>
<dd><p>Makes a <a class="reference internal" href="#stingray.bispectrum.Bispectrum" title="stingray.bispectrum.Bispectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bispectrum</span></code></a> object from a <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a>.</p>
<p><a class="reference internal" href="#stingray.bispectrum.Bispectrum" title="stingray.bispectrum.Bispectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bispectrum</span></code></a> is a higher order time series analysis method and is calculated by
indirect method as Fourier transform of triple auto-correlation function also called as
3rd order cumulant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lc</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object</span></dt><dd><p>The light curve data for bispectrum calculation.</p>
</dd>
<dt><strong>maxlag</strong><span class="classifier">int, optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Maximum lag on both positive and negative sides of
3rd order cumulant (Similar to lags in correlation).
if <code class="docutils literal notranslate"><span class="pre">None</span></code>, max lag is set to one-half of length of light curve.</p>
</dd>
<dt><strong>window</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">parzen</span></code>, <code class="docutils literal notranslate"><span class="pre">hamming</span></code>, <code class="docutils literal notranslate"><span class="pre">hanning</span></code>, <code class="docutils literal notranslate"><span class="pre">triangular</span></code>, <code class="docutils literal notranslate"><span class="pre">welch</span></code>, <code class="docutils literal notranslate"><span class="pre">blackman</span></code>, <code class="docutils literal notranslate"><span class="pre">flat-top</span></code>}, optional, default ‘uniform’</span></dt><dd><p>Type of window function to apply to the data.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">biased</span></code>, <code class="docutils literal notranslate"><span class="pre">unbiased</span></code>}, optional, default <code class="docutils literal notranslate"><span class="pre">biased</span></code></span></dt><dd><p>Flag to decide biased or unbiased normalization for 3rd order cumulant function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>lc</strong><span class="classifier"><a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object</span></dt><dd><p>The light curve data to compute the <a class="reference internal" href="#stingray.bispectrum.Bispectrum" title="stingray.bispectrum.Bispectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bispectrum</span></code></a>.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float</span></dt><dd><p>Sampling frequencies</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Total Number of samples of light curve observations.</p>
</dd>
<dt><strong>maxlag</strong><span class="classifier">int</span></dt><dd><p>Maximum lag on both positive and negative sides of
3rd order cumulant (similar to lags in correlation)</p>
</dd>
<dt><strong>signal</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Row vector of light curve counts for matrix operations</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">biased</span></code>, <code class="docutils literal notranslate"><span class="pre">unbiased</span></code>}</span></dt><dd><p>Flag to decide biased or unbiased normalization for 3rd order cumulant function.</p>
</dd>
<dt><strong>lags</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of time lags for which 3rd order cumulant is calculated</p>
</dd>
<dt><strong>freq</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of freq values for <a class="reference internal" href="#stingray.bispectrum.Bispectrum" title="stingray.bispectrum.Bispectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bispectrum</span></code></a>.</p>
</dd>
<dt><strong>cum3</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">maxlag*2+1</span> <span class="pre">x</span> <span class="pre">maxlag*2+1</span></code> matrix containing 3rd order cumulant data for different lags.</p>
</dd>
<dt><strong>bispec</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>A`` maxlag*2+1 x maxlag*2+1`` matrix containing bispectrum data for different frequencies.</p>
</dd>
<dt><strong>bispec_mag</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Magnitude of the bispectrum</p>
</dd>
<dt><strong>bispec_phase</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Phase of the bispectrum</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>1) The biphase explained: understanding the asymmetries invcoupled Fourier components of astronomical timeseries
by Thomas J. Maccarone Department of Physics, Box 41051, Science Building, Texas Tech University, Lubbock TX 79409-1051
School of Physics and Astronomy, University of Southampton, SO16 4ES</p>
<p>2) T. S. Rao, M. M. Gabr, An Introduction to Bispectral Analysis and Bilinear Time
Series Models, Lecture Notes in Statistics, Volume 24, D. Brillinger, S. Fienberg,
J. Gani, J. Hartigan, K. Krickeberg, Editors, Springer-Verlag, New York, NY, 1984.</p>
<p>3) Matlab version of bispectrum under following link.
<a class="reference external" href="https://www.mathworks.com/matlabcentral/fileexchange/60-bisp3cum">https://www.mathworks.com/matlabcentral/fileexchange/60-bisp3cum</a></p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="kn">from</span> <span class="nn">stingray.lightcurve</span> <span class="kn">import</span> <span class="n">Lightcurve</span>
<span class="o">&gt;&gt;</span> <span class="kn">from</span> <span class="nn">stingray.bispectrum</span> <span class="kn">import</span> <span class="n">Bispectrum</span>
<span class="o">&gt;&gt;</span> <span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;</span> <span class="n">bs</span> <span class="o">=</span> <span class="n">Bispectrum</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span><span class="n">maxlag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="n">bs</span><span class="o">.</span><span class="n">lags</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">])</span>
<span class="o">&gt;&gt;</span> <span class="n">bs</span><span class="o">.</span><span class="n">freq</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.5</span><span class="p">])</span>
<span class="o">&gt;&gt;</span> <span class="n">bs</span><span class="o">.</span><span class="n">cum3</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.2976</span><span class="p">,</span>  <span class="mf">0.1024</span><span class="p">,</span>  <span class="mf">0.1408</span><span class="p">],</span>
    <span class="p">[</span> <span class="mf">0.1024</span><span class="p">,</span>  <span class="mf">0.144</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2976</span><span class="p">],</span>
    <span class="p">[</span> <span class="mf">0.1408</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2976</span><span class="p">,</span>  <span class="mf">0.1024</span><span class="p">]])</span>
<span class="o">&gt;&gt;</span> <span class="n">bs</span><span class="o">.</span><span class="n">bispec_mag</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.26336794</span><span class="p">,</span>  <span class="mf">0.0032</span>   <span class="p">,</span>  <span class="mf">0.0032</span>    <span class="p">],</span>
    <span class="p">[</span> <span class="mf">0.0032</span>   <span class="p">,</span>  <span class="mf">0.16</span>     <span class="p">,</span>  <span class="mf">0.0032</span>    <span class="p">],</span>
    <span class="p">[</span> <span class="mf">0.0032</span>   <span class="p">,</span>  <span class="mf">0.0032</span>   <span class="p">,</span>  <span class="mf">1.26336794</span><span class="p">]])</span>
<span class="o">&gt;&gt;</span> <span class="n">bs</span><span class="o">.</span><span class="n">bispec_phase</span>
<span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">9.65946229e-01</span><span class="p">,</span>   <span class="mf">2.25347190e-14</span><span class="p">,</span>   <span class="mf">3.46944695e-14</span><span class="p">],</span>
    <span class="p">[</span>  <span class="mf">0.00000000e+00</span><span class="p">,</span>   <span class="mf">3.14159265e+00</span><span class="p">,</span>   <span class="mf">0.00000000e+00</span><span class="p">],</span>
    <span class="p">[</span> <span class="o">-</span><span class="mf">3.46944695e-14</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.25347190e-14</span><span class="p">,</span>   <span class="mf">9.65946229e-01</span><span class="p">]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.bispectrum.Bispectrum.plot_cum3">
<span class="sig-name descname"><span class="pre">plot_cum3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/bispectrum.html#Bispectrum.plot_cum3"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.bispectrum.Bispectrum.plot_cum3" title="Link to this definition">¶</a></dt>
<dd><p>Plot the 3rd order cumulant as function of time lags using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.
Plot the <code class="docutils literal notranslate"><span class="pre">cum3</span></code> attribute on a graph with the <code class="docutils literal notranslate"><span class="pre">lags</span></code> attribute on x-axis and y-axis and
<code class="docutils literal notranslate"><span class="pre">cum3</span></code> on z-axis</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis()</span></code> method.</p>
</dd>
<dt><strong>save</strong><span class="classifier">bool, optionalm, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name and path of the image to save. Depends on the boolean <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>plt</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> object</span></dt><dd><p>Reference to plot, call <code class="docutils literal notranslate"><span class="pre">show()</span></code> to display it</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.bispectrum.Bispectrum.plot_mag">
<span class="sig-name descname"><span class="pre">plot_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/bispectrum.html#Bispectrum.plot_mag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.bispectrum.Bispectrum.plot_mag" title="Link to this definition">¶</a></dt>
<dd><p>Plot the magnitude of bispectrum as function of freq using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.
Plot the <code class="docutils literal notranslate"><span class="pre">bispec_mag</span></code> attribute on a graph with <code class="docutils literal notranslate"><span class="pre">freq</span></code> attribute on the x-axis and y-axis and
the <code class="docutils literal notranslate"><span class="pre">bispec_mag</span></code> attribute on the z-axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis()</span></code> method.</p>
</dd>
<dt><strong>save</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename and path.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name and path of the image to save. Depends on the bool <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>plt</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> object</span></dt><dd><p>Reference to plot, call <code class="docutils literal notranslate"><span class="pre">show()</span></code> to display it</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.bispectrum.Bispectrum.plot_phase">
<span class="sig-name descname"><span class="pre">plot_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/bispectrum.html#Bispectrum.plot_phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.bispectrum.Bispectrum.plot_phase" title="Link to this definition">¶</a></dt>
<dd><p>Plot the phase of bispectrum as function of freq using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.
Plot the <code class="docutils literal notranslate"><span class="pre">bispec_phase</span></code> attribute on a graph with <code class="docutils literal notranslate"><span class="pre">phase</span></code> attribute on the x-axis and
y-axis and the <code class="docutils literal notranslate"><span class="pre">bispec_phase</span></code> attribute on the z-axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">list, tuple, string, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Parameter to set axis properties of <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> figure. For example
it can be a list like <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code> or any other
acceptable argument for <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis()</span></code> function.</p>
</dd>
<dt><strong>save</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, save the figure with specified filename and path.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>File name and path of the image to save. Depends on the bool <code class="docutils literal notranslate"><span class="pre">save</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>plt</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> object</span></dt><dd><p>Reference to plot, call <code class="docutils literal notranslate"><span class="pre">show()</span></code> to display it</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="covariancespectrum">
<h3>Covariancespectrum<a class="headerlink" href="#covariancespectrum" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.Covariancespectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">Covariancespectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band_interest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_band_interest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/covariancespectrum.html#Covariancespectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.Covariancespectrum" title="Link to this definition">¶</a></dt>
<dd><p>Compute a covariance spectrum for the data. The input data can be
either in event data or pre-made light curves. Event data can either
be in the form of a <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> with <code class="docutils literal notranslate"><span class="pre">(time</span> <span class="pre">stamp,</span> <span class="pre">energy)</span></code> pairs or
a <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> object. If light curves are formed ahead
of time, then a list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects should be passed to the
object, ideally one light curve for each band of interest.</p>
<p>For the case where the data is input as a list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects,
the reference band(s) should either be</p>
<ol class="arabic simple">
<li><p>a single <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object,</p></li>
<li><p>a list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects with the reference band for each band
of interest pre-made, or</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case reference bands will
formed by combining all light curves <em>except</em> for the band of interest.</p></li>
</ol>
<p>In the case of event data, <code class="docutils literal notranslate"><span class="pre">band_interest</span></code> and <code class="docutils literal notranslate"><span class="pre">ref_band_interest</span></code> can
be (multiple) pairs of energies, and the light curves for the bands of
interest and reference bands will be produced dynamically.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> | <a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> object | list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects}</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">data</span></code> contains the time series data, either in the form of a
2-D array of <code class="docutils literal notranslate"><span class="pre">(time</span> <span class="pre">stamp,</span> <span class="pre">energy)</span></code> pairs for event data, or as a
list of light curves.
Note : The event list must be in sorted order with respect to the
times of arrivals.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> formed from the energy bin.
Only used if <code class="docutils literal notranslate"><span class="pre">data</span></code> is an event list.</p>
</dd>
<dt><strong>band_interest</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">None</span></code>, iterable of tuples}</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, all possible energy values will be assumed to be of
interest, and a covariance spectrum in the highest resolution
will be produced.
Note: if the input is a list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects, then the user may
supply their energy values here, for construction of a
reference band.</p>
</dd>
<dt><strong>ref_band_interest</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">None</span></code>, tuple, <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a>, list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects}</span></dt><dd><p>Defines the reference band to be used for comparison with the
bands of interest. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, all bands <em>except</em> the band of
interest will be used for each band of interest, respectively.
Alternatively, a tuple can be given for event list data, which will
extract the reference band (always excluding the band of interest),
or one may put in a single <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object to be used (the same
for each band of interest) or a list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects, one for
each band of interest.</p>
</dd>
<dt><strong>std</strong><span class="classifier">float or np.array or list of numbers</span></dt><dd><p>The term <code class="docutils literal notranslate"><span class="pre">std</span></code> is used to calculate the excess variance of a band.
If <code class="docutils literal notranslate"><span class="pre">std</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, default Poisson case is taken and the
std is calculated as <code class="docutils literal notranslate"><span class="pre">mean(lc)**0.5</span></code>. In the case of a single
float as input, the same is used as the standard deviation which
is also used as the std. And if the std is an iterable of
numbers, their mean is used for the same purpose.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>unnorm_covar</strong><span class="classifier">np.ndarray</span></dt><dd><p>An array of arrays with mid point <code class="docutils literal notranslate"><span class="pre">band_interest</span></code> and their
covariance. It is the array-form of the dictionary <code class="docutils literal notranslate"><span class="pre">energy_covar</span></code>.
The covariance values are unnormalized.</p>
</dd>
<dt><strong>covar</strong><span class="classifier">np.ndarray</span></dt><dd><p>Normalized covariance spectrum.</p>
</dd>
<dt><strong>covar_error</strong><span class="classifier">np.ndarray</span></dt><dd><p>Errors of the normalized covariance spectrum.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Wilkinson, T. and Uttley, P. (2009), Accretion disc variability              in the hard state of black hole X-ray binaries. Monthly Notices              of the Royal Astronomical Society, 397: 666–676.              doi: 10.1111/j.1365-2966.2009.15008.x</p>
<p class="rubric">Examples</p>
<p>See the <a class="reference external" href="https://github.com/StingraySoftware/notebooks">notebooks repository</a> for
detailed notebooks on the code.</p>
</dd></dl>

</section>
<hr class="docutils" />
<section id="averagedcovariancespectrum">
<h3>AveragedCovariancespectrum<a class="headerlink" href="#averagedcovariancespectrum" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.AveragedCovariancespectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.</span></span><span class="sig-name descname"><span class="pre">AveragedCovariancespectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band_interest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_band_interest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/covariancespectrum.html#AveragedCovariancespectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.AveragedCovariancespectrum" title="Link to this definition">¶</a></dt>
<dd><p>Compute a covariance spectrum for the data, defined in [covar spectrum]_ Equation 15.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">{numpy.ndarray | list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects}</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">data</span></code> contains the time series data, either in the form of a
2-D array of <code class="docutils literal notranslate"><span class="pre">(time</span> <span class="pre">stamp,</span> <span class="pre">energy)</span></code> pairs for event data, or as a
list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects.
Note : The event list must be in sorted order with respect to the
times of arrivals.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>The length of each segment in the averaged covariance spectrum.
The number of segments will be calculated automatically using the
total length of the data set and the segment_size defined here.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The time resolution of the <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> formed
from the energy bin. Only used if <code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code> is an event list.</p>
</dd>
<dt><strong>band_interest</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">None</span></code>, iterable of tuples}</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, all possible energy values will be assumed to be of
interest, and a covariance spectrum in the highest resolution
will be produced.
Note: if the input is a list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects,
then the user may supply their energy values here, for construction of a
reference band.</p>
</dd>
<dt><strong>ref_band_interest</strong><span class="classifier">{None, tuple, <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a>, list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects}</span></dt><dd><p>Defines the reference band to be used for comparison with the
bands of interest. If None, all bands <em>except</em> the band of
interest will be used for each band of interest, respectively.
Alternatively, a tuple can be given for event list data, which will
extract the reference band (always excluding the band of interest),
or one may put in a single <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object to be used (the same
for each band of interest) or a list of <a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> objects, one for
each band of interest.</p>
</dd>
<dt><strong>std</strong><span class="classifier">float or np.array or list of numbers</span></dt><dd><p>The term <code class="docutils literal notranslate"><span class="pre">std</span></code> is used to calculate the excess variance of a band.
If <code class="docutils literal notranslate"><span class="pre">std</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, default Poisson case is taken and the
<code class="docutils literal notranslate"><span class="pre">std</span></code> is calculated as <code class="docutils literal notranslate"><span class="pre">mean(lc)**0.5</span></code>. In the case of a single
float as input, the same is used as the standard deviation which
is also used as the std. And if the std is an iterable of
numbers, their mean is used for the same purpose.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>unnorm_covar</strong><span class="classifier">np.ndarray</span></dt><dd><p>An array of arrays with mid point band_interest and their
covariance. It is the array-form of the dictionary <code class="docutils literal notranslate"><span class="pre">energy_covar</span></code>.
The covariance values are unnormalized.</p>
</dd>
<dt><strong>covar</strong><span class="classifier">np.ndarray</span></dt><dd><p>Normalized covariance spectrum.</p>
</dd>
<dt><strong>covar_error</strong><span class="classifier">np.ndarray</span></dt><dd><p>Errors of the normalized covariance spectrum.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

</section>
<hr class="docutils" />
<section id="varenergyspectrum">
<h3>VarEnergySpectrum<a class="headerlink" href="#varenergyspectrum" title="Link to this heading">¶</a></h3>
<p>Abstract base class for spectral timing products including
both variability and spectral information.</p>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.VarEnergySpectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.varenergyspectrum.</span></span><span class="sig-name descname"><span class="pre">VarEnergySpectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy_spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_pi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">events2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_complex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/varenergyspectrum.html#VarEnergySpectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.varenergyspectrum.VarEnergySpectrum" title="Link to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.VarEnergySpectrum.energy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">energy</span></span><a class="headerlink" href="#stingray.varenergyspectrum.VarEnergySpectrum.energy" title="Link to this definition">¶</a></dt>
<dd><p>Give the centers of the energy intervals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.VarEnergySpectrum.from_astropy_table">
<span class="sig-name descname"><span class="pre">from_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/varenergyspectrum.html#VarEnergySpectrum.from_astropy_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.varenergyspectrum.VarEnergySpectrum.from_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create a Stingray Object object from data in an Astropy Table.</p>
<p>The table MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.VarEnergySpectrum.from_pandas">
<span class="sig-name descname"><span class="pre">from_pandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/varenergyspectrum.html#VarEnergySpectrum.from_pandas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.varenergyspectrum.VarEnergySpectrum.from_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create an <code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code> object from data in a pandas DataFrame.</p>
<p>The dataframe MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays can be
specified as <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_1d_arrays_into_nd</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.VarEnergySpectrum.from_xarray">
<span class="sig-name descname"><span class="pre">from_xarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/varenergyspectrum.html#VarEnergySpectrum.from_xarray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.varenergyspectrum.VarEnergySpectrum.from_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create a <code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code> from data in an xarray Dataset.</p>
<p>The dataset MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.VarEnergySpectrum.main_array_attr">
<span class="sig-name descname"><span class="pre">main_array_attr</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'energy'</span></em><a class="headerlink" href="#stingray.varenergyspectrum.VarEnergySpectrum.main_array_attr" title="Link to this definition">¶</a></dt>
<dd><p>Base class for variability-energy spectrum.</p>
<p>This class is only a base for the various variability spectra, and it’s
not to be instantiated by itself.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events</strong><span class="classifier"><a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> object</span></dt><dd><p>event list</p>
</dd>
<dt><strong>freq_interval</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[f0,</span> <span class="pre">f1]</span></code>, floats</span></dt><dd><p>the frequency range over which calculating the variability quantity</p>
</dd>
<dt><strong>energy_spec</strong><span class="classifier">list or tuple <code class="docutils literal notranslate"><span class="pre">(emin,</span> <span class="pre">emax,</span> <span class="pre">N,</span> <span class="pre">type)</span></code></span></dt><dd><p>if a <code class="docutils literal notranslate"><span class="pre">list</span></code> is specified, this is interpreted as a list of bin edges;
if a <code class="docutils literal notranslate"><span class="pre">tuple</span></code> is provided, this will encode the minimum and maximum
energies, the number of intervals, and <code class="docutils literal notranslate"><span class="pre">lin</span></code> or <code class="docutils literal notranslate"><span class="pre">log</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>events1</strong><span class="classifier">array-like</span></dt><dd><p>list of events used to produce the spectrum</p>
</dd>
<dt><strong>events2</strong><span class="classifier">array-like</span></dt><dd><p>if the spectrum requires it, second list of events</p>
</dd>
<dt><strong>freq_interval</strong><span class="classifier">array-like</span></dt><dd><p>interval of frequencies used to calculate the spectrum</p>
</dd>
<dt><strong>energy_intervals</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[[e00,</span> <span class="pre">e01],</span> <span class="pre">[e10,</span> <span class="pre">e11],</span> <span class="pre">...]</span></code></span></dt><dd><p>energy intervals used for the spectrum</p>
</dd>
<dt><strong>spectrum</strong><span class="classifier">array-like</span></dt><dd><p>the spectral values, corresponding to each energy interval</p>
</dd>
<dt><strong>spectrum_error</strong><span class="classifier">array-like</span></dt><dd><p>the error bars corresponding to spectrum</p>
</dd>
<dt><strong>energy</strong><span class="classifier">array-like</span></dt><dd><p>The centers of energy intervals</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ref_band</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[emin,</span> <span class="pre">emax</span></code>], floats; default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>minimum and maximum energy of the reference band. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
full band is used.</p>
</dd>
<dt><strong>use_pi</strong><span class="classifier">bool, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>Use channel instead of energy</p>
</dd>
<dt><strong>events2</strong><span class="classifier"><a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> object</span></dt><dd><p>event list for the second channel, if not the same. Useful if the
reference band has to be taken from another detector.</p>
</dd>
<dt><strong>return_complex: bool, default False</strong></dt><dd><p>In spectra that produce complex values, return the whole spectrum.
Otherwise, the absolute value will be returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="rmsenergyspectrum">
<h3>RmsEnergySpectrum<a class="headerlink" href="#rmsenergyspectrum" title="Link to this heading">¶</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.RmsEnergySpectrum">
<span class="sig-prename descclassname"><span class="pre">stingray.varenergyspectrum.</span></span><span class="sig-name descname"><span class="pre">RmsEnergySpectrum</span></span><a class="headerlink" href="#stingray.varenergyspectrum.RmsEnergySpectrum" title="Link to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">RmsSpectrum</span></code></p>
</dd></dl>

</section>
<hr class="docutils" />
<section id="lagenergyspectrum">
<h3>LagEnergySpectrum<a class="headerlink" href="#lagenergyspectrum" title="Link to this heading">¶</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.LagEnergySpectrum">
<span class="sig-prename descclassname"><span class="pre">stingray.varenergyspectrum.</span></span><span class="sig-name descname"><span class="pre">LagEnergySpectrum</span></span><a class="headerlink" href="#stingray.varenergyspectrum.LagEnergySpectrum" title="Link to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">LagSpectrum</span></code></p>
</dd></dl>

</section>
<hr class="docutils" />
<section id="excessvariancespectrum">
<h3>ExcessVarianceSpectrum<a class="headerlink" href="#excessvariancespectrum" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.varenergyspectrum.</span></span><span class="sig-name descname"><span class="pre">ExcessVarianceSpectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy_spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_pi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fvar'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/varenergyspectrum.html#ExcessVarianceSpectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the Excess Variance spectrum.</p>
<p>For each energy interval, calculate the excess variance in the specified
frequency range.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events</strong><span class="classifier"><a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> object</span></dt><dd><p>event list</p>
</dd>
<dt><strong>freq_interval</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[f0,</span> <span class="pre">f1]</span></code>, list of float</span></dt><dd><p>the frequency range over which calculating the variability quantity</p>
</dd>
<dt><strong>energy_spec</strong><span class="classifier">list or tuple <code class="docutils literal notranslate"><span class="pre">(emin,</span> <span class="pre">emax,</span> <span class="pre">N,</span> <span class="pre">type)</span></code></span></dt><dd><p>if a list is specified, this is interpreted as a list of bin edges;
if a tuple is provided, this will encode the minimum and maximum
energies, the number of intervals, and <code class="docutils literal notranslate"><span class="pre">lin</span></code> or <code class="docutils literal notranslate"><span class="pre">log</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>events1</strong><span class="classifier">array-like</span></dt><dd><p>list of events used to produce the spectrum</p>
</dd>
<dt><strong>freq_interval</strong><span class="classifier">array-like</span></dt><dd><p>interval of frequencies used to calculate the spectrum</p>
</dd>
<dt><strong>energy_intervals</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[[e00,</span> <span class="pre">e01],</span> <span class="pre">[e10,</span> <span class="pre">e11],</span> <span class="pre">...]</span></code></span></dt><dd><p>energy intervals used for the spectrum</p>
</dd>
<dt><strong>spectrum</strong><span class="classifier">array-like</span></dt><dd><p>the spectral values, corresponding to each energy interval</p>
</dd>
<dt><strong>spectrum_error</strong><span class="classifier">array-like</span></dt><dd><p>the errorbars corresponding to spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ref_band</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[emin,</span> <span class="pre">emax]</span></code>, floats; default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>minimum and maximum energy of the reference band. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
full band is used.</p>
</dd>
<dt><strong>use_pi</strong><span class="classifier">bool, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>Use channel instead of energy</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.add" title="Link to this definition">¶</a></dt>
<dd><p>Add two <code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code> instances.</p>
<p>Add the array values of two <code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code> instances element by element, assuming
the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.apply_mask">
<span class="sig-name descname"><span class="pre">apply_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">npt.ArrayLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtered_attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.apply_mask" title="Link to this definition">¶</a></dt>
<dd><p>Apply a mask to all array attributes of the object</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>mask</strong><span class="classifier">array of <code class="docutils literal notranslate"><span class="pre">bool</span></code></span></dt><dd><p>The mask. Has to be of the same length as <code class="docutils literal notranslate"><span class="pre">self.time</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ts_new</strong><span class="classifier">StingrayObject object</span></dt><dd><p>The new object with the mask applied if <code class="docutils literal notranslate"><span class="pre">inplace</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, otherwise the
same object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current object. Otherwise, return a new one.</p>
</dd>
<dt><strong>filtered_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be filtered. Defaults to all array attributes if <code class="docutils literal notranslate"><span class="pre">None</span></code>.
The other array attributes will be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>. The main array attr is always
included.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.array_attrs">
<span class="sig-name descname"><span class="pre">array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the array attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.data_attributes">
<span class="sig-name descname"><span class="pre">data_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.data_attributes" title="Link to this definition">¶</a></dt>
<dd><p>Clean up the list of attributes, only giving out those pointing to data.</p>
<p>List all the attributes that point directly to valid data. This method goes through all the
attributes of the class, eliminating methods, properties, and attributes that are complicated
to serialize such as other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code>, or arrays of objects.</p>
<p>This function does not make difference between array-like data and scalar data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data_attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of attributes pointing to data that are not methods, properties,
or other <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code> instances.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.dict">
<span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.dict" title="Link to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.energy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">energy</span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.energy" title="Link to this definition">¶</a></dt>
<dd><p>Give the centers of the energy intervals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.from_astropy_table">
<span class="sig-name descname"><span class="pre">from_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.from_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create a Stingray Object object from data in an Astropy Table.</p>
<p>The table MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.from_pandas">
<span class="sig-name descname"><span class="pre">from_pandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.from_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create an <code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code> object from data in a pandas DataFrame.</p>
<p>The dataframe MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays can be
specified as <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_1d_arrays_into_nd</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.from_xarray">
<span class="sig-name descname"><span class="pre">from_xarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.from_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create a <code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code> from data in an xarray Dataset.</p>
<p>The dataset MUST contain at least a column named like the
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The rest of columns will form the array attributes of the
new object, while the attributes in ds.attrs will
form the new meta attributes of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.get_meta_dict">
<span class="sig-name descname"><span class="pre">get_meta_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><span class="pre">dict</span></a></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.get_meta_dict" title="Link to this definition">¶</a></dt>
<dd><p>Give a dictionary with all non-None meta attrs of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.internal_array_attrs">
<span class="sig-name descname"><span class="pre">internal_array_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.internal_array_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the internal array attributes of the Stingray Object.</p>
<p>These are array attributes that can be set by properties, and are generally indicated
by an underscore followed by the name of the property that links to it (E.g.
<code class="docutils literal notranslate"><span class="pre">_counts</span></code> in <code class="docutils literal notranslate"><span class="pre">Lightcurve</span></code>).
By array attributes, we mean the ones with the same size and shape as
<code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of internal array attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.main_array_attr">
<span class="sig-name descname"><span class="pre">main_array_attr</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'energy'</span></em><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.main_array_attr" title="Link to this definition">¶</a></dt>
<dd><p>Base class for variability-energy spectrum.</p>
<p>This class is only a base for the various variability spectra, and it’s
not to be instantiated by itself.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>events</strong><span class="classifier"><a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> object</span></dt><dd><p>event list</p>
</dd>
<dt><strong>freq_interval</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[f0,</span> <span class="pre">f1]</span></code>, floats</span></dt><dd><p>the frequency range over which calculating the variability quantity</p>
</dd>
<dt><strong>energy_spec</strong><span class="classifier">list or tuple <code class="docutils literal notranslate"><span class="pre">(emin,</span> <span class="pre">emax,</span> <span class="pre">N,</span> <span class="pre">type)</span></code></span></dt><dd><p>if a <code class="docutils literal notranslate"><span class="pre">list</span></code> is specified, this is interpreted as a list of bin edges;
if a <code class="docutils literal notranslate"><span class="pre">tuple</span></code> is provided, this will encode the minimum and maximum
energies, the number of intervals, and <code class="docutils literal notranslate"><span class="pre">lin</span></code> or <code class="docutils literal notranslate"><span class="pre">log</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>events1</strong><span class="classifier">array-like</span></dt><dd><p>list of events used to produce the spectrum</p>
</dd>
<dt><strong>events2</strong><span class="classifier">array-like</span></dt><dd><p>if the spectrum requires it, second list of events</p>
</dd>
<dt><strong>freq_interval</strong><span class="classifier">array-like</span></dt><dd><p>interval of frequencies used to calculate the spectrum</p>
</dd>
<dt><strong>energy_intervals</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[[e00,</span> <span class="pre">e01],</span> <span class="pre">[e10,</span> <span class="pre">e11],</span> <span class="pre">...]</span></code></span></dt><dd><p>energy intervals used for the spectrum</p>
</dd>
<dt><strong>spectrum</strong><span class="classifier">array-like</span></dt><dd><p>the spectral values, corresponding to each energy interval</p>
</dd>
<dt><strong>spectrum_error</strong><span class="classifier">array-like</span></dt><dd><p>the error bars corresponding to spectrum</p>
</dd>
<dt><strong>energy</strong><span class="classifier">array-like</span></dt><dd><p>The centers of energy intervals</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ref_band</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[emin,</span> <span class="pre">emax</span></code>], floats; default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>minimum and maximum energy of the reference band. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
full band is used.</p>
</dd>
<dt><strong>use_pi</strong><span class="classifier">bool, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>Use channel instead of energy</p>
</dd>
<dt><strong>events2</strong><span class="classifier"><a class="reference internal" href="#stingray.events.EventList" title="stingray.events.EventList"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.events.EventList</span></code></a> object</span></dt><dd><p>event list for the second channel, if not the same. Useful if the
reference band has to be taken from another detector.</p>
</dd>
<dt><strong>return_complex: bool, default False</strong></dt><dd><p>In spectra that produce complex values, return the whole spectrum.
Otherwise, the absolute value will be returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.meta_attrs">
<span class="sig-name descname"><span class="pre">meta_attrs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.meta_attrs" title="Link to this definition">¶</a></dt>
<dd><p>List the names of the meta attributes of the Stingray Object.</p>
<p>By array attributes, we mean the ones with a different size and shape
than <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code> in <code class="docutils literal notranslate"><span class="pre">EventList</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attributes</strong><span class="classifier">list of str</span></dt><dd><p>List of meta attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.pretty_print">
<span class="sig-name descname"><span class="pre">pretty_print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_apply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs_to_discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.pretty_print" title="Link to this definition">¶</a></dt>
<dd><p>Return a pretty-printed string representation of the object.</p>
<p>This is useful for debugging, and for interactive use.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func_to_apply</strong><span class="classifier">function</span></dt><dd><p>A function that modifies the attributes listed in <code class="docutils literal notranslate"><span class="pre">attrs_to_apply</span></code>.
It must return the modified attributes and a label to be printed.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, no function is applied.</p>
</dd>
<dt><strong>attrs_to_apply</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be modified by <code class="docutils literal notranslate"><span class="pre">func_to_apply</span></code>.</p>
</dd>
<dt><strong>attrs_to_discard</strong><span class="classifier">list of str</span></dt><dd><p>Attributes to be discarded from the output.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.read">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tso</span></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.read" title="Link to this definition">¶</a></dt>
<dd><p>Generic reader for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>Files that need the <a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> interface MUST contain
at least a column named like the <code class="docutils literal notranslate"><span class="pre">main_array_attr</span></code>.
The default ascii format is enhanced CSV (ECSV). Data formats
supporting the serialization of metadata (such as ECSV and HDF5) can
contain all attributes such as <code class="docutils literal notranslate"><span class="pre">mission</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc with
no significant loss of information. Other file formats might lose part
of the metadata, so must be used with care.</p>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values should be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Path and file name for the file to be read.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>Available options are ‘pickle’, ‘hea’, and any <code class="xref py py-obj docutils literal notranslate"><span class="pre">Table</span></code>-supported
format such as ‘hdf5’, ‘ascii.ecsv’, etc.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>obj: <code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code> object</dt><dd><p>The object reconstructed from file</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operated_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_attrs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_operation=&lt;function</span> <span class="pre">sqsum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.sub" title="Link to this definition">¶</a></dt>
<dd><p>Subtract <em>all the array attrs</em> of two <code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code> instances element by element, assuming the main array attributes of the instances match exactly.</p>
<p>All array attrs ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code> are treated as error bars and propagated with the
sum of squares.</p>
<p>GTIs are crossed, so that only common intervals are saved.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code> object</span></dt><dd><p>A second time series object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>operated_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on. Defaults to all array attributes not ending in
<code class="docutils literal notranslate"><span class="pre">_err</span></code>.
The other array attributes will be discarded from the time series to avoid
inconsistencies.</p>
</dd>
<dt><strong>error_attrs</strong><span class="classifier">list of str or None</span></dt><dd><p>Array attributes to be operated on with <code class="docutils literal notranslate"><span class="pre">error_operation</span></code>. Defaults to all array
attributes ending with <code class="docutils literal notranslate"><span class="pre">_err</span></code>.</p>
</dd>
<dt><strong>error_operation</strong><span class="classifier">function</span></dt><dd><p>Function to be called to propagate the errors</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>If True, overwrite the current time series. Otherwise, return a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.to_astropy_table">
<span class="sig-name descname"><span class="pre">to_astropy_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">no_longdouble</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><span class="pre">Table</span></a></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.to_astropy_table" title="Link to this definition">¶</a></dt>
<dd><p>Create an Astropy Table from a <code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code></p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">meta</span></code> dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>no_longdouble</strong><span class="classifier">bool</span></dt><dd><p>If True, reduce the precision of longdouble arrays to double precision.
This needs to be done in some cases, e.g. when the table is to be saved
in an architecture not supporting extended precision (e.g. ARM), but can
also be useful when an extended precision is not needed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.to_pandas">
<span class="sig-name descname"><span class="pre">to_pandas</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.to_pandas" title="Link to this definition">¶</a></dt>
<dd><p>Create a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> from a <code class="xref py py-class docutils literal notranslate"><span class="pre">StingrayObject</span></code>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
<p>Since pandas does not support n-D data, multi-dimensional arrays are
converted into columns before the conversion, with names <code class="docutils literal notranslate"><span class="pre">&lt;colname&gt;_dimN_M_K</span></code> etc.</p>
<p>See documentation of <code class="xref py py-obj docutils literal notranslate"><span class="pre">make_nd_into_arrays</span></code> for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.to_xarray">
<span class="sig-name descname"><span class="pre">to_xarray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dataset</span></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.to_xarray" title="Link to this definition">¶</a></dt>
<dd><p>Create an <code class="docutils literal notranslate"><span class="pre">xarray</span></code> Dataset from a <code class="xref py py-obj docutils literal notranslate"><span class="pre">StingrayObject</span></code>.</p>
<p>Array attributes (e.g. <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>, <code class="docutils literal notranslate"><span class="pre">energy</span></code>, etc. for
<code class="docutils literal notranslate"><span class="pre">EventList</span></code>) are converted into columns, while meta attributes
(<code class="docutils literal notranslate"><span class="pre">mjdref</span></code>, <code class="docutils literal notranslate"><span class="pre">gti</span></code>, etc.) are saved into the <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> dictionary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.varenergyspectrum.ExcessVarianceSpectrum.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><span class="pre">str</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><span class="pre">None</span></a></span></span><a class="headerlink" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.write" title="Link to this definition">¶</a></dt>
<dd><p>Generic writer for :class`StingrayObject`</p>
<p>Currently supported formats are</p>
<ul class="simple">
<li><p>pickle (not recommended for long-term storage)</p></li>
<li><p>any other formats compatible with the writers in
<a class="reference external" href="https://docs.astropy.org/en/stable/api/astropy.table.Table.html#astropy.table.Table" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.table.Table</span></code></a> (ascii.ecsv, hdf5, etc.)</p></li>
</ul>
<p>..note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Complex values can be dealt with out-of-the-box in some formats
like HDF5 or FITS, not in others (e.g. all ASCII formats).
With these formats, and in any case when fmt is ``None``, complex
values will be stored as two columns of real numbers, whose names
are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename: str</strong></dt><dd><p>Name and path of the file to save the object list to.</p>
</dd>
<dt><strong>fmt: str</strong></dt><dd><p>The file format to store the data in.
Available options are <code class="docutils literal notranslate"><span class="pre">pickle</span></code>, <code class="docutils literal notranslate"><span class="pre">hdf5</span></code>, <code class="docutils literal notranslate"><span class="pre">ascii</span></code>, <code class="docutils literal notranslate"><span class="pre">fits</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<hr class="docutils" />
<section id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Link to this heading">¶</a></h2>
<p>Commonly used utility functionality, including Good Time Interval operations and input/output
helper methods.</p>
<section id="module-stingray.stats">
<span id="statistical-functions"></span><h3>Statistical Functions<a class="headerlink" href="#module-stingray.stats" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.a_from_pf">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">a_from_pf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#a_from_pf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.a_from_pf" title="Link to this definition">¶</a></dt>
<dd><p>Fractional amplitude of modulation from pulsed fraction</p>
<p>If the pulsed profile is defined as
p = mean * (1 + a * sin(phase)),</p>
<p>we define “pulsed fraction” as 2a/b, where b = mean + a is the maximum and
a is the amplitude of the modulation.</p>
<p>Hence, a = pf / (2 - pf)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_from_pf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_from_pf</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.a_from_ssig">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">a_from_ssig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ssig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncounts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#a_from_ssig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.a_from_ssig" title="Link to this definition">¶</a></dt>
<dd><p>Amplitude of a sinusoid corresponding to a given Z/PDS value</p>
<p>From Leahy et al. 1983, given a pulse profile
p = lambda * (1 + a * sin(phase)),
The theoretical value of Z^2_n is Ncounts / 2 * a^2</p>
<p>Note that if there are multiple sinusoidal components, one can use
a = sqrt(sum(a_l))
(Bachetti+2021b)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">a_from_ssig</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">30000</span><span class="p">),</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.amplitude_upper_limit">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">amplitude_upper_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fft_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nyq_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#amplitude_upper_limit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.amplitude_upper_limit" title="Link to this definition">¶</a></dt>
<dd><p>Upper limit on a sinusoidal modulation, given a measured power in the PDS/Z search.</p>
<p>Eq. 10 in Vaughan+94 and <a class="reference internal" href="#stingray.stats.a_from_ssig" title="stingray.stats.a_from_ssig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a_from_ssig</span></code></a>: they are equivalent but Vaughan+94
corrects further for the response inside an FFT bin and at frequencies close
to Nyquist. These two corrections are added by using fft_corr=True and
nyq_ratio to the correct <span class="math notranslate nohighlight">\(f / f_{Nyq}\)</span> of the FFT peak</p>
<p>To understand the meaning of this amplitude: if the modulation is described by:</p>
<p>..math:: p = overline{p} (1 + a * sin(x))</p>
<p>this function returns a.</p>
<p>If it is a sum of sinusoidal harmonics instead
..math:: p = overline{p} (1 + sum_l a_l * sin(lx))
a is equivalent to <span class="math notranslate nohighlight">\(\sqrt(\sum_l a_l^2)\)</span>.</p>
<p>See <a class="reference internal" href="#stingray.stats.power_upper_limit" title="stingray.stats.power_upper_limit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">power_upper_limit</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pmeas: float</strong></dt><dd><p>The measured value of power</p>
</dd>
<dt><strong>counts: int</strong></dt><dd><p>The number of counts in the light curve used to calculate the spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>a: float</dt><dd><p>The modulation amplitude that could produce P&gt;pmeas with 1 - c probability</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n: int</strong></dt><dd><p>The number of summed powers to obtain pmeas. It can be multiple
harmonics of the PDS, adjacent bins in a PDS summed to collect all the
power in a QPO, or the n in Z^2_n</p>
</dd>
<dt><strong>c: float</strong></dt><dd><p>The confidence value for the probability (e.g. 0.95 = 95%)</p>
</dd>
<dt><strong>fft_corr: bool</strong></dt><dd><p>Apply a correction for the expected power concentrated in an FFT bin,
which is about 0.773 on average (it’s 1 at the center of the bin, 2/pi
at the bin edge.</p>
</dd>
<dt><strong>nyq_ratio: float</strong></dt><dd><p>Ratio of the frequency of this feature with respect to the Nyquist
frequency. Important to know when dealing with FFTs, because the FFT
response decays between 0 and f_Nyq similarly to the response inside
a frequency bin: from 1 at 0 Hz to ~2/pi at f_Nyq</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aup</span> <span class="o">=</span> <span class="n">amplitude_upper_limit</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">30000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aup_nyq</span> <span class="o">=</span> <span class="n">amplitude_upper_limit</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">30000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="n">nyq_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">aup_nyq</span><span class="p">,</span> <span class="n">aup</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aup_corr</span> <span class="o">=</span> <span class="n">amplitude_upper_limit</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">30000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="n">fft_corr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">aup_corr</span><span class="p">,</span> <span class="n">aup</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.773</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.classical_pvalue">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">classical_pvalue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">power</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nspec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#classical_pvalue"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.classical_pvalue" title="Link to this definition">¶</a></dt>
<dd><p>Note:
This is stingray’s original implementation of the probability
distribution for the power spectrum. It is superseded by the
implementation in pds_probability for practical purposes, but
remains here for backwards compatibility and for its educational
value as a clear, explicit implementation of the correct
probability distribution.</p>
<p>Compute the probability of detecting the current power under
the assumption that there is no periodic oscillation in the data.</p>
<p>This computes the single-trial p-value that the power was
observed under the null hypothesis that there is no signal in
the data.</p>
<p>Important: the underlying assumptions that make this calculation valid
are:</p>
<ol class="arabic simple">
<li><p>the powers in the power spectrum follow a chi-square distribution</p></li>
<li><p>the power spectrum is normalized according to [Leahy 1983]_, such
that the powers have a mean of 2 and a variance of 4</p></li>
<li><p>there is only white noise in the light curve. That is, there is no
aperiodic variability that would change the overall shape of the power
spectrum.</p></li>
</ol>
<p>Also note that the p-value is for a <em>single trial</em>, i.e. the power
currently being tested. If more than one power or more than one power
spectrum are being tested, the resulting p-value must be corrected for the
number of trials (Bonferroni correction).</p>
<p>Mathematical formulation in [Groth 1975]_.
Original implementation in IDL by Anna L. Watts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>power</strong><span class="classifier">float</span></dt><dd><p>The squared Fourier amplitude of a spectrum to be evaluated</p>
</dd>
<dt><strong>nspec</strong><span class="classifier">int</span></dt><dd><p>The number of spectra or frequency bins averaged in <code class="docutils literal notranslate"><span class="pre">power</span></code>.
This matters because averaging spectra or frequency bins increases
the signal-to-noise ratio, i.e. makes the statistical distributions
of the noise narrower, such that a smaller power might be very
significant in averaged spectra even though it would not be in a single
power spectrum.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pval</strong><span class="classifier">float</span></dt><dd><p>The classical p-value of the observed power being consistent with
the null hypothesis of white noise</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li></li>
<li></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.equivalent_gaussian_Nsigma">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">equivalent_gaussian_Nsigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#equivalent_gaussian_Nsigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.equivalent_gaussian_Nsigma" title="Link to this definition">¶</a></dt>
<dd><p>Number of Gaussian sigmas corresponding to tail probability.</p>
<p>This function computes the value of the characteristic function of a
standard Gaussian distribution for the tail probability equivalent to the
provided p-value, and turns this value into units of standard deviations
away from the Gaussian mean. This allows the user to make a statement
about the signal such as “I detected this pulsation at 4.1 sigma</p>
<p>The example values below are obtained by brute-force integrating the
Gaussian probability density function using the mpmath library
between Nsigma and +inf.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">equivalent_gaussian_Nsigma</span><span class="p">(</span><span class="mf">0.15865525393145707</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">equivalent_gaussian_Nsigma</span><span class="p">(</span><span class="mf">0.0013498980316301035</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">equivalent_gaussian_Nsigma</span><span class="p">(</span><span class="mf">9.865877e-10</span><span class="p">),</span> <span class="mi">6</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">equivalent_gaussian_Nsigma</span><span class="p">(</span><span class="mf">6.22096e-16</span><span class="p">),</span> <span class="mi">8</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">equivalent_gaussian_Nsigma</span><span class="p">(</span><span class="mf">3.0567e-138</span><span class="p">),</span> <span class="mi">25</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.fold_detection_level">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">fold_detection_level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#fold_detection_level"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.fold_detection_level" title="Link to this definition">¶</a></dt>
<dd><p>Return the detection level for a folded profile.</p>
<p>See Leahy et al. (1983).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbin</strong><span class="classifier">int</span></dt><dd><p>The number of bins in the profile</p>
</dd>
<dt><strong>epsilon</strong><span class="classifier">float, default 0.01</span></dt><dd><p>The fractional probability that the signal has been produced
by noise</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>detlev</strong><span class="classifier">float</span></dt><dd><p>The epoch folding statistics corresponding to a probability
epsilon * 100 % that the signal has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of trials executed to find this profile</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.fold_profile_logprobability">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">fold_profile_logprobability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#fold_profile_logprobability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.fold_profile_logprobability" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the probability of a certain folded profile, due to noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stat</strong><span class="classifier">float</span></dt><dd><p>The epoch folding statistics</p>
</dd>
<dt><strong>nbin</strong><span class="classifier">int</span></dt><dd><p>The number of bins in the profile</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>logp</strong><span class="classifier">float</span></dt><dd><p>The log-probability that the profile has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of trials executed to find this profile</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.fold_profile_probability">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">fold_profile_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#fold_profile_probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.fold_profile_probability" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the probability of a certain folded profile, due to noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stat</strong><span class="classifier">float</span></dt><dd><p>The epoch folding statistics</p>
</dd>
<dt><strong>nbin</strong><span class="classifier">int</span></dt><dd><p>The number of bins in the profile</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p</strong><span class="classifier">float</span></dt><dd><p>The probability that the profile has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of trials executed to find this profile</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.p_multitrial_from_single_trial">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">p_multitrial_from_single_trial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#p_multitrial_from_single_trial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.p_multitrial_from_single_trial" title="Link to this definition">¶</a></dt>
<dd><p>Calculate a multi-trial p-value from a single-trial one.</p>
<p>Calling <em>p</em> the probability of a single success, the Binomial
distributions says that the probability <em>at least</em> one outcome
in n trials is</p>
<div class="math notranslate nohighlight">
\[P(k\geq 1) = \sum_{k\geq 1} \binom{n}{k} p^k (1-p)^{(n-k)}\]</div>
<p>or more simply, using P(k ≥ 0) = 1</p>
<div class="math notranslate nohighlight">
\[P(k\geq 1) = 1 - \binom{n}{0} (1-p)^n = 1 - (1-p)^n\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p1</strong><span class="classifier">float</span></dt><dd><p>The significance at which we reject the null hypothesis on
each single trial.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of trials</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pn</strong><span class="classifier">float</span></dt><dd><p>The significance at which we reject the null hypothesis
after multiple trials</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.p_single_trial_from_p_multitrial">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">p_single_trial_from_p_multitrial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#p_single_trial_from_p_multitrial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.p_single_trial_from_p_multitrial" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the single-trial p-value from a total p-value</p>
<p>Let us say that we want to reject a null hypothesis at the
<code class="docutils literal notranslate"><span class="pre">pn</span></code> level, after executing <code class="docutils literal notranslate"><span class="pre">n</span></code> different measurements.
This might be the case because, e.g., we
want to have a 1% probability of detecting a signal in an
entire power spectrum, and we need to correct the detection
level accordingly.</p>
<p>The typical procedure is dividing the initial probability
(often called _epsilon_) by the number of trials. This is
called the Bonferroni correction and it is often a good
approximation, when <code class="docutils literal notranslate"><span class="pre">pn</span></code> is low: <code class="docutils literal notranslate"><span class="pre">p1</span> <span class="pre">=</span> <span class="pre">pn</span> <span class="pre">/</span> <span class="pre">n</span></code>.</p>
<p>However, if <code class="docutils literal notranslate"><span class="pre">pn</span></code> is close to 1, this approximation gives
incorrect results.</p>
<p>Here we calculate this probability by inverting the Binomial
problem. Given that (see <code class="docutils literal notranslate"><span class="pre">p_multitrial_from_single_trial</span></code>)
the probability of getting more than one hit in n trials,
given the single-trial probability <em>p</em>, is</p>
<div class="math notranslate nohighlight">
\[P (k \geq 1) =  1 - (1 - p)^n,\]</div>
<p>we get the single trial probability from the multi-trial one
from</p>
<div class="math notranslate nohighlight">
\[p = 1 - (1 - P)^{(1/n)}\]</div>
<p>This is also known as Šidák correction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pn</strong><span class="classifier">float</span></dt><dd><p>The significance at which we want to reject the null
hypothesis after multiple trials</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of trials</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p1</strong><span class="classifier">float</span></dt><dd><p>The significance at which we reject the null hypothesis on
each single trial.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.pds_detection_level">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">pds_detection_level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_summed_spectra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_rebin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#pds_detection_level"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.pds_detection_level" title="Link to this definition">¶</a></dt>
<dd><p>Detection level for a PDS.</p>
<p>Return the detection level (with probability 1 - epsilon) for a Power
Density Spectrum of nbins bins, normalized a la Leahy (1983), based on
the 2-dof <span class="math notranslate nohighlight">\({\chi}^2\)</span> statistics, corrected for rebinning (n_rebin)
and multiple PDS averaging (n_summed_spectra)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>epsilon</strong><span class="classifier">float</span></dt><dd><p>The single-trial probability value(s)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of <em>independent</em> trials (the independent bins of the PDS)</p>
</dd>
<dt><strong>n_summed_spectra</strong><span class="classifier">int</span></dt><dd><p>The number of power density spectra that have been averaged to obtain
this power level</p>
</dd>
<dt><strong>n_rebin</strong><span class="classifier">int</span></dt><dd><p>The number of power density bins that have been averaged to obtain
this power level</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pds_detection_level</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span> <span class="mf">4.6</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">pds_detection_level</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">n_rebin</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="mf">4.6</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.pds_probability">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">pds_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_summed_spectra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_rebin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#pds_probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.pds_probability" title="Link to this definition">¶</a></dt>
<dd><p>Give the probability of a given power level in PDS.</p>
<p>Return the probability of a certain power level in a Power Density
Spectrum of nbins bins, normalized a la Leahy (1983), based on
the 2-dof <span class="math notranslate nohighlight">\({\chi}^2\)</span> statistics, corrected for rebinning (n_rebin)
and multiple PDS averaging (n_summed_spectra)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">float or array of floats</span></dt><dd><p>The power level for which we are calculating the probability</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>epsilon</strong><span class="classifier">float</span></dt><dd><p>The probability value(s)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of <em>independent</em> trials (the independent bins of the PDS)</p>
</dd>
<dt><strong>n_summed_spectra</strong><span class="classifier">int</span></dt><dd><p>The number of power density spectra that have been averaged to obtain
this power level</p>
</dd>
<dt><strong>n_rebin</strong><span class="classifier">int</span></dt><dd><p>The number of power density bins that have been averaged to obtain
this power level</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.pf_from_a">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">pf_from_a</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#pf_from_a"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.pf_from_a" title="Link to this definition">¶</a></dt>
<dd><p>Pulsed fraction from fractional amplitude of modulation.</p>
<p>If the pulsed profile is defined as
p = mean * (1 + a * sin(phase)),</p>
<p>we define “pulsed fraction” as 2a/b, where b = mean + a is the maximum and
a is the amplitude of the modulation.</p>
<p>Hence, pulsed fraction = 2a/(1+a)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pf_from_a</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pf_from_a</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.pf_from_ssig">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">pf_from_ssig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ssig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncounts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#pf_from_ssig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.pf_from_ssig" title="Link to this definition">¶</a></dt>
<dd><p>Estimate pulsed fraction for a sinusoid from a given Z or PDS power.</p>
<p>See <a class="reference internal" href="#stingray.stats.a_from_ssig" title="stingray.stats.a_from_ssig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a_from_ssig</span></code></a> and <a class="reference internal" href="#stingray.stats.pf_from_a" title="stingray.stats.pf_from_a"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pf_from_a</span></code></a> for more details</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">a_from_pf</span><span class="p">(</span><span class="n">pf_from_ssig</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">30000</span><span class="p">)),</span> <span class="mi">1</span><span class="p">),</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.pf_upper_limit">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">pf_upper_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#pf_upper_limit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.pf_upper_limit" title="Link to this definition">¶</a></dt>
<dd><p>Upper limit on pulsed fraction, given a measured power in the PDS/Z search.</p>
<p>See <a class="reference internal" href="#stingray.stats.power_upper_limit" title="stingray.stats.power_upper_limit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">power_upper_limit</span></code></a> and <a class="reference internal" href="#stingray.stats.pf_from_ssig" title="stingray.stats.pf_from_ssig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pf_from_ssig</span></code></a>.
All arguments are the same as <a class="reference internal" href="#stingray.stats.amplitude_upper_limit" title="stingray.stats.amplitude_upper_limit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">amplitude_upper_limit</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pmeas: float</strong></dt><dd><p>The measured value of power</p>
</dd>
<dt><strong>counts: int</strong></dt><dd><p>The number of counts in the light curve used to calculate the spectrum</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>pf: float</dt><dd><p>The pulsed fraction that could produce P&gt;pmeas with 1 - c probability</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n: int</strong></dt><dd><p>The number of summed powers to obtain pmeas. It can be multiple
harmonics of the PDS, adjacent bins in a PDS summed to collect all the
power in a QPO, or the n in Z^2_n</p>
</dd>
<dt><strong>c: float</strong></dt><dd><p>The confidence value for the probability (e.g. 0.95 = 95%)</p>
</dd>
<dt><strong>fft_corr: bool</strong></dt><dd><p>Apply a correction for the expected power concentrated in an FFT bin,
which is about 0.773 on average (it’s 1 at the center of the bin, 2/pi
at the bin edge.</p>
</dd>
<dt><strong>nyq_ratio: float</strong></dt><dd><p>Ratio of the frequency of this feature with respect to the Nyquist
frequency. Important to know when dealing with FFTs, because the FFT
response decays between 0 and f_Nyq similarly to the response inside
a frequency bin: from 1 at 0 Hz to ~2/pi at f_Nyq</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pfup</span> <span class="o">=</span> <span class="n">pf_upper_limit</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">30000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pfup</span><span class="p">,</span> <span class="mf">0.13</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.phase_dispersion_detection_level">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">phase_dispersion_detection_level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsamples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#phase_dispersion_detection_level"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.phase_dispersion_detection_level" title="Link to this definition">¶</a></dt>
<dd><p>Return the detection level for a phase dispersion minimization
periodogram..</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nsamples</strong><span class="classifier">int</span></dt><dd><p>The number of time bins in the light curve</p>
</dd>
<dt><strong>nbin</strong><span class="classifier">int</span></dt><dd><p>The number of bins in the profile</p>
</dd>
<dt><strong>epsilon</strong><span class="classifier">float, default 0.01</span></dt><dd><p>The fractional probability that the signal has been produced
by noise</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>detlev</strong><span class="classifier">float</span></dt><dd><p>The epoch folding statistics corresponding to a probability
epsilon * 100 % that the signal has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of trials executed to find this profile</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.phase_dispersion_logprobability">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">phase_dispersion_logprobability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsamples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#phase_dispersion_logprobability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.phase_dispersion_logprobability" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the log-probability of a peak in a phase dispersion
minimization periodogram, due to noise.</p>
<p>Uses the beta-distribution from Czerny-Schwarzendorf (1997).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stat</strong><span class="classifier">float</span></dt><dd><p>The value of the PDM inverse peak</p>
</dd>
<dt><strong>nsamples</strong><span class="classifier">int</span></dt><dd><p>The number of samples in the time series</p>
</dd>
<dt><strong>nbin</strong><span class="classifier">int</span></dt><dd><p>The number of bins in the profile</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>logp</strong><span class="classifier">float</span></dt><dd><p>The log-probability that the profile has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of trials executed to find this profile</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.phase_dispersion_probability">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">phase_dispersion_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsamples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#phase_dispersion_probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.phase_dispersion_probability" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the probability of a peak in a phase dispersion
minimization periodogram, due to noise.</p>
<p>Uses the beta-distribution from Czerny-Schwarzendorf (1997).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stat</strong><span class="classifier">float</span></dt><dd><p>The value of the PDM inverse peak</p>
</dd>
<dt><strong>nsamples</strong><span class="classifier">int</span></dt><dd><p>The number of samples in the time series</p>
</dd>
<dt><strong>nbin</strong><span class="classifier">int</span></dt><dd><p>The number of bins in the profile</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p</strong><span class="classifier">float</span></dt><dd><p>The probability that the profile has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of trials executed to find this profile</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.power_confidence_limits">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">power_confidence_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#power_confidence_limits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.power_confidence_limits" title="Link to this definition">¶</a></dt>
<dd><p>Confidence limits on power, given a (theoretical) signal power.</p>
<p>This is to be used when we <em>expect</em> a given power (e.g. from the pulsed
fraction measured in previous observations) and we want to know the
range of values the measured power could take to a given confidence level.
Adapted from Vaughan et al. 1994, noting that, after appropriate
normalization of the spectral stats, the distribution of powers in the PDS
and the Z^2_n searches is always described by a noncentral chi squared
distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>preal: float</strong></dt><dd><p>The theoretical signal-generated value of power</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>pmeas: [float, float]</dt><dd><p>The upper and lower confidence interval (a, 1-a) on the measured power</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n: int</strong></dt><dd><p>The number of summed powers to obtain the result. It can be multiple
harmonics of the PDS, adjacent bins in a PDS summed to collect all the
power in a QPO, or the n in Z^2_n</p>
</dd>
<dt><strong>c: float</strong></dt><dd><p>The confidence level (e.g. 0.95=95%)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cl</span> <span class="o">=</span> <span class="n">power_confidence_limits</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.84</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="p">[</span><span class="mi">127</span><span class="p">,</span> <span class="mi">176</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.power_upper_limit">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">power_upper_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pmeas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#power_upper_limit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.power_upper_limit" title="Link to this definition">¶</a></dt>
<dd><p>Upper limit on signal power, given a measured power in the PDS/Z search.</p>
<p>Adapted from Vaughan et al. 1994, noting that, after appropriate
normalization of the spectral stats, the distribution of powers in the PDS
and the Z^2_n searches is always described by a noncentral chi squared
distribution.</p>
<p>Note that Vaughan+94 gives p(pmeas | preal), while we are interested in
p(real | pmeas), which is not described by the NCX2 stat. Rather than
integrating the CDF of this probability distribution, we start from a
reasonable approximation and fit to find the preal that gives pmeas as
a (e.g.95%) confidence limit.</p>
<p>As Vaughan+94 shows, this power is always larger than the observed one.
This is because we are looking for the maximum signal power that,
combined with noise powers, would give the observed power. This involves
the possibility that noise powers partially cancel out some signal power.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pmeas: float</strong></dt><dd><p>The measured value of power</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>psig: float</dt><dd><p>The signal power that could produce P&gt;pmeas with 1 - c probability</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n: int</strong></dt><dd><p>The number of summed powers to obtain pmeas. It can be multiple
harmonics of the PDS, adjacent bins in a PDS summed to collect all the
power in a QPO, or the n in Z^2_n</p>
</dd>
<dt><strong>c: float</strong></dt><dd><p>The confidence value for the probability (e.g. 0.95 = 95%)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pup</span> <span class="o">=</span> <span class="n">power_upper_limit</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pup</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.ssig_from_a">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">ssig_from_a</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncounts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#ssig_from_a"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.ssig_from_a" title="Link to this definition">¶</a></dt>
<dd><p>Theoretical power in the Z or PDS search for a sinusoid of amplitude a.</p>
<p>From Leahy et al. 1983, given a pulse profile
p = lambda * (1 + a * sin(phase)),
The theoretical value of Z^2_n is Ncounts / 2 * a^2</p>
<p>Note that if there are multiple sinusoidal components, one can use
a = sqrt(sum(a_l))
(Bachetti+2021b)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">ssig_from_a</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">30000</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">150.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.ssig_from_pf">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">ssig_from_pf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncounts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#ssig_from_pf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.ssig_from_pf" title="Link to this definition">¶</a></dt>
<dd><p>Theoretical power in the Z or PDS for a sinusoid of pulsed fraction pf.</p>
<p>See <a class="reference internal" href="#stingray.stats.ssig_from_a" title="stingray.stats.ssig_from_a"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ssig_from_a</span></code></a> and <a class="reference internal" href="#stingray.stats.a_from_pf" title="stingray.stats.a_from_pf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a_from_pf</span></code></a> for more details</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">round</span><span class="p">(</span><span class="n">ssig_from_pf</span><span class="p">(</span><span class="n">pf_from_a</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span> <span class="mi">30000</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mf">150.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.z2_n_detection_level">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">z2_n_detection_level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_summed_spectra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#z2_n_detection_level"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.z2_n_detection_level" title="Link to this definition">¶</a></dt>
<dd><p>Return the detection level for the Z^2_n statistics.</p>
<p>See Buccheri et al. (1983), Bendat and Piersol (1971).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int, default 2</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">n</span></code> in $Z^2_n$ (number of harmonics, including the fundamental)</p>
</dd>
<dt><strong>epsilon</strong><span class="classifier">float, default 0.01</span></dt><dd><p>The fractional probability that the signal has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>detlev</strong><span class="classifier">float</span></dt><dd><p>The epoch folding statistics corresponding to a probability
epsilon * 100 % that the signal has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of trials executed to find this profile</p>
</dd>
<dt><strong>n_summed_spectra</strong><span class="classifier">int</span></dt><dd><p>Number of Z_2^n periodograms that are being averaged</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.z2_n_logprobability">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">z2_n_logprobability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_summed_spectra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#z2_n_logprobability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.z2_n_logprobability" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the probability of a certain folded profile, due to noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z2</strong><span class="classifier">float</span></dt><dd><p>A Z^2_n statistics value</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, default 2</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">n</span></code> in $Z^2_n$ (number of harmonics, including the fundamental)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p</strong><span class="classifier">float</span></dt><dd><p>The probability that the Z^2_n value has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of trials executed to find this profile</p>
</dd>
<dt><strong>n_summed_spectra</strong><span class="classifier">int</span></dt><dd><p>Number of Z_2^n periodograms that were averaged to obtain z2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.stats.z2_n_probability">
<span class="sig-prename descclassname"><span class="pre">stingray.stats.</span></span><span class="sig-name descname"><span class="pre">z2_n_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_summed_spectra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/stats.html#z2_n_probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.stats.z2_n_probability" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the probability of a certain folded profile, due to noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z2</strong><span class="classifier">float</span></dt><dd><p>A Z^2_n statistics value</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, default 2</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">n</span></code> in $Z^2_n$ (number of harmonics, including the fundamental)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p</strong><span class="classifier">float</span></dt><dd><p>The probability that the Z^2_n value has been produced by noise</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntrial</strong><span class="classifier">int</span></dt><dd><p>The number of trials executed to find this profile</p>
</dd>
<dt><strong>n_summed_spectra</strong><span class="classifier">int</span></dt><dd><p>Number of Z_2^n periodograms that were averaged to obtain z2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-stingray.gti">
<span id="gti-functionality"></span><h3>GTI Functionality<a class="headerlink" href="#module-stingray.gti" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.append_gtis">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">append_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gti0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#append_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.append_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Union of two non-overlapping GTIs.</p>
<p>If the two GTIs “touch”, this is tolerated and the touching GTIs are
joined in a single one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti0: 2-d float array</strong></dt><dd><p>List of GTIs of the form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>.</p>
</dd>
<dt><strong>gti1: 2-d float array</strong></dt><dd><p>List of GTIs of the form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>gti: 2-d float array</dt><dd><p>The newly created GTI array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">append_gtis</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]),</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">append_gtis</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]),</span>
<span class="gp">... </span>            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">append_gtis</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]),</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.bin_intervals_from_gtis">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">bin_intervals_from_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#bin_intervals_from_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.bin_intervals_from_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Compute start/stop times of equal time intervals, compatible with GTIs,
and map them to the indices of an array of time stamps.</p>
<p>Used to start each FFT/PDS/cospectrum from the start of a GTI,
and stop before the next gap in data (end of GTI).
In this case, it is necessary to specify the time array containing the
times of the light curve bins.
Returns start and stop bins of the intervals to use for the PDS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtis</strong><span class="classifier">2-d float array</span></dt><dd><p>List of GTIs of the form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>Length of each time segment.</p>
</dd>
<dt><strong>time</strong><span class="classifier">array-like</span></dt><dd><p>Array of time stamps.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum_start_bins</strong><span class="classifier">array-like</span></dt><dd><p>List of starting bins in the original time array to use in spectral
calculations.</p>
</dd>
<dt><strong>spectrum_stop_bins</strong><span class="classifier">array-like</span></dt><dd><p>List of end bins to use in the spectral calculations.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">float, default median(diff(time))</span></dt><dd><p>Time resolution of the light curve.</p>
</dd>
<dt><strong>epsilon</strong><span class="classifier">float, default 0.001</span></dt><dd><p>The tolerance, in fraction of <code class="docutils literal notranslate"><span class="pre">dt</span></code>, for the comparisons at the
borders.</p>
</dd>
<dt><strong>fraction_step</strong><span class="classifier">float</span></dt><dd><p>If the step is not a full <code class="docutils literal notranslate"><span class="pre">segment_size</span></code> but less (e.g. a moving
window), this indicates the ratio between step step and
<code class="docutils literal notranslate"><span class="pre">segment_size</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">0.5</span></code> means that the window shifts by half
<code class="docutils literal notranslate"><span class="pre">segment_size</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">13.5</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gtis</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">segment_size</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start_bins</span><span class="p">,</span> <span class="n">stop_bins</span> <span class="o">=</span> <span class="n">bin_intervals_from_gtis</span><span class="p">(</span><span class="n">gtis</span><span class="p">,</span><span class="n">segment_size</span><span class="p">,</span><span class="n">time</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">start_bins</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">stop_bins</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">start_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">stop_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">start_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">stop_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.check_gtis">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">check_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gti</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#check_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.check_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Check if GTIs are well-behaved.</p>
<p>Check that:</p>
<ol class="arabic simple">
<li><p>the shape of the GTI array is correct;</p></li>
<li><p>no start &gt; end</p></li>
<li><p>no overlaps.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti</strong><span class="classifier">list</span></dt><dd><p>A list of GTI <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">stop)</span></code> pairs extracted from the FITS file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>If GTIs are of the wrong shape</p>
</dd>
<dt>ValueError</dt><dd><p>If GTIs have overlapping or displaced values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.check_separate">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">check_separate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gti0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#check_separate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.check_separate" title="Link to this definition">¶</a></dt>
<dd><p>Check if two GTIs do not overlap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti0: 2-d float array</strong></dt><dd><p>List of GTIs of form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>.</p>
</dd>
<dt><strong>gti1: 2-d float array</strong></dt><dd><p>List of GTIs of form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>separate: bool</dt><dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if GTIs are mutually exclusive, <code class="docutils literal notranslate"><span class="pre">False</span></code> if not.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gti0</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">check_separate</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti0</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_separate</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti0</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">check_separate</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti0</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_separate</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti0</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_separate</span><span class="p">(</span><span class="n">gti1</span><span class="p">,</span> <span class="n">gti0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti0</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">28</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">check_separate</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.create_gti_from_condition">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">create_gti_from_condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#create_gti_from_condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.create_gti_from_condition" title="Link to this definition">¶</a></dt>
<dd><p>Create a GTI list from a time array and a boolean mask (<code class="docutils literal notranslate"><span class="pre">condition</span></code>).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>time</strong><span class="classifier">array-like</span></dt><dd><p>Array containing time stamps.</p>
</dd>
<dt><strong>condition</strong><span class="classifier">array-like</span></dt><dd><p>An array of bools, of the same length of time.
A possible condition can be, e.g., the result of <code class="docutils literal notranslate"><span class="pre">lc</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>gtis</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code></span></dt><dd><p>The newly created GTIs.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>safe_interval</strong><span class="classifier">float or <code class="docutils literal notranslate"><span class="pre">[float,</span> <span class="pre">float]</span></code></span></dt><dd><p>A safe interval to exclude at both ends (if single float) or the start
and the end (if pair of values) of GTIs.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The width (in sec) of each bin of the time array. Can be irregular.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.create_gti_mask">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">create_gti_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_new_gtis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#create_gti_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.create_gti_mask" title="Link to this definition">¶</a></dt>
<dd><p>Create GTI mask.</p>
<p>Assumes that no overlaps are present between GTIs</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>time</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of time stamps</p>
</dd>
<dt><strong>gtis</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[[g0_0,</span> <span class="pre">g0_1],</span> <span class="pre">[g1_0,</span> <span class="pre">g1_1],</span> <span class="pre">...]</span></code>, float array-like</span></dt><dd><p>The list of GTIs</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>mask</strong><span class="classifier">bool array</span></dt><dd><p>A mask labelling all time stamps that are included in the GTIs versus
those that are not.</p>
</dd>
<dt><strong>new_gtis</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">Nx2</span></code> array</span></dt><dd><p>An array of new GTIs created by this function.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>safe_interval</strong><span class="classifier">float or <code class="docutils literal notranslate"><span class="pre">[float,</span> <span class="pre">float]</span></code>, default None</span></dt><dd><p>A safe interval to exclude at both ends (if single float) or the start
and the end (if pair of values) of GTIs. If None, no safe interval
is applied to data.</p>
</dd>
<dt><strong>min_length</strong><span class="classifier">float</span></dt><dd><p>An optional minimum length for the GTIs to be applied. Only GTIs longer
than <code class="docutils literal notranslate"><span class="pre">min_length</span></code> will be considered when creating the mask.</p>
</dd>
<dt><strong>return_new_gtis</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True`</span></code>, return the list of new GTIs (if <code class="docutils literal notranslate"><span class="pre">min_length</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>)</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>Time resolution of the data, i.e. the interval between time stamps.</p>
</dd>
<dt><strong>epsilon</strong><span class="classifier">float</span></dt><dd><p>Fraction of <code class="docutils literal notranslate"><span class="pre">dt</span></code> that is tolerated at the borders of a GTI.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.create_gti_mask_complete">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">create_gti_mask_complete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_new_gtis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#create_gti_mask_complete"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.create_gti_mask_complete" title="Link to this definition">¶</a></dt>
<dd><p>Create GTI mask, allowing for non-constant <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
<p>Assumes that no overlaps are present between GTIs.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>time</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of time stamps.</p>
</dd>
<dt><strong>gtis</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[[g0_0,</span> <span class="pre">g0_1],</span> <span class="pre">[g1_0,</span> <span class="pre">g1_1],</span> <span class="pre">...]</span></code>, float array-like</span></dt><dd><p>The list of GTIs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">bool array</span></dt><dd><p>A mask labelling all time stamps that are included in the GTIs versus
those that are not.</p>
</dd>
<dt><strong>new_gtis</strong><span class="classifier">Nx2 array</span></dt><dd><p>An array of new GTIs created by this function.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>safe_interval</strong><span class="classifier">float or [float, float]</span></dt><dd><p>A safe interval to exclude at both ends (if single float) or the start
and the end (if pair of values) of GTIs.</p>
</dd>
<dt><strong>min_length</strong><span class="classifier">float</span></dt><dd><p>An optional minimum length for the GTIs to be applied. Only GTIs longer
than <code class="docutils literal notranslate"><span class="pre">min_length</span></code> will be considered when creating the mask.</p>
</dd>
<dt><strong>return_new_gtis</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the list of new GTIs (if <code class="docutils literal notranslate"><span class="pre">min_length</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>).</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>Time resolution of the data, i.e. the interval between time stamps.</p>
</dd>
<dt><strong>epsilon</strong><span class="classifier">float</span></dt><dd><p>Fraction of <code class="docutils literal notranslate"><span class="pre">dt</span></code> that is tolerated at the borders of a GTI.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.create_gti_mask_jit">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">create_gti_mask_jit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#create_gti_mask_jit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.create_gti_mask_jit" title="Link to this definition">¶</a></dt>
<dd><p>Compiled and fast function to create GTI mask.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>time</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of time stamps</p>
</dd>
<dt><strong>gtis</strong><span class="classifier">iterable of <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">stop)</span></code> pairs</span></dt><dd><p>The list of GTIs.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>A pre-assigned array of zeros of the same shape as <code class="docutils literal notranslate"><span class="pre">time</span></code>
Records whether a time stamp is part of the GTIs.</p>
</dd>
<dt><strong>gti_mask</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>A pre-assigned array zeros in the same shape as <code class="docutils literal notranslate"><span class="pre">time</span></code>; records
start/stop of GTIs.</p>
</dd>
<dt><strong>min_length</strong><span class="classifier">float</span></dt><dd><p>An optional minimum length for the GTIs to be applied. Only GTIs longer
than <code class="docutils literal notranslate"><span class="pre">min_length</span></code> will be considered when creating the mask.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.cross_gtis">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">cross_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gti_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#cross_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.cross_gtis" title="Link to this definition">¶</a></dt>
<dd><p>From multiple GTI lists, extract the common intervals <em>EXACTLY</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti_list</strong><span class="classifier">array-like</span></dt><dd><p>List of GTI arrays, each one in the usual format
<code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>gti0: 2-d float array</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>
The newly created GTIs.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#stingray.gti.cross_two_gtis" title="stingray.gti.cross_two_gtis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cross_two_gtis</span></code></a></dt><dd><p>Extract the common intervals from two GTI lists <em>EXACTLY</em></p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newgti</span> <span class="o">=</span> <span class="n">cross_gtis</span><span class="p">([</span><span class="n">gti1</span><span class="p">,</span> <span class="n">gti2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">newgti</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newgti</span> <span class="o">=</span> <span class="n">cross_gtis</span><span class="p">([</span><span class="n">gti1</span><span class="p">,</span> <span class="n">gti2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">newgti</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.cross_two_gtis">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">cross_two_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gti0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#cross_two_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.cross_two_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Extract the common intervals from two GTI lists <em>EXACTLY</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>gti0</strong><span class="classifier">iterable of the form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code></span></dt><dd></dd>
<dt><strong>gti1</strong><span class="classifier">iterable of the form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code></span></dt><dd><p>The two lists of GTIs to be crossed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>gtis</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code></span></dt><dd><p>The newly created GTIs.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#stingray.gti.cross_gtis" title="stingray.gti.cross_gtis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cross_gtis</span></code></a></dt><dd><p>From multiple GTI lists, extract common intervals <em>EXACTLY</em></p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newgti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="n">gti1</span><span class="p">,</span> <span class="n">gti2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">newgti</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newgti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="n">gti1</span><span class="p">,</span> <span class="n">gti2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">newgti</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newgti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="n">gti1</span><span class="p">,</span> <span class="n">gti2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">newgti</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.generate_indices_of_gti_boundaries">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">generate_indices_of_gti_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#generate_indices_of_gti_boundaries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.generate_indices_of_gti_boundaries" title="Link to this definition">¶</a></dt>
<dd><p>Get the indices of events from different GTIs of the observation.</p>
<p>This is a generator, yielding the boundaries of each GTI and the
corresponding indices in the time array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>times</strong><span class="classifier">float <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Array of times.</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti00, gti01], [gti10, gti11], …]</span></dt><dd><p>Good time intervals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>g0: float</dt><dd><p>Start time of current GTI.</p>
</dd>
<dt>g1: float</dt><dd><p>End time of current GTI.</p>
</dd>
<dt>startidx: int</dt><dd><p>Start index of the current GTI in the time array.</p>
</dd>
<dt>stopidx: int</dt><dd><p>End index of the current GTI in the time array. Note that this is
larger by one, so that <code class="xref py py-obj docutils literal notranslate"><span class="pre">time[startidx:stopidx]</span></code> returns the correct
time interval.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>If times are uniformly binned, this is the binning time.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gtis</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.55</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">generate_indices_of_gti_boundaries</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gtis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v0</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v0</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">gtis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v0</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.generate_indices_of_segment_boundaries_binned">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">generate_indices_of_segment_boundaries_binned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#generate_indices_of_segment_boundaries_binned"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.generate_indices_of_segment_boundaries_binned" title="Link to this definition">¶</a></dt>
<dd><p>Get the indices of binned times from different segments of the observation.</p>
<p>This is a generator, yielding the boundaries of each segment and the
corresponding indices in the time array</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>times</strong><span class="classifier">float <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Array of times, uniformly sampled</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti00, gti01], [gti10, gti11], …]</span></dt><dd><p>good time intervals</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>length of segments</p>
</dd>
</dl>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>t0: float</dt><dd><p>First time value, from the time array, in the current segment</p>
</dd>
<dt>t1: float</dt><dd><p>Last time value, from the time array, in the current segment</p>
</dd>
<dt>startidx: int</dt><dd><p>Start index of the current segment in the time array</p>
</dd>
<dt>stopidx: int</dt><dd><p>End index of the current segment in the time array. Note that this is
larger by one, so that <code class="xref py py-obj docutils literal notranslate"><span class="pre">time[startidx:stopidx]</span></code> returns the correct
time interval.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gtis</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.55</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">generate_indices_of_segment_boundaries_binned</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gtis</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v0</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v0</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.55</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v0</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.generate_indices_of_segment_boundaries_unbinned">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">generate_indices_of_segment_boundaries_unbinned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_sorted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#generate_indices_of_segment_boundaries_unbinned"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.generate_indices_of_segment_boundaries_unbinned" title="Link to this definition">¶</a></dt>
<dd><p>Get the indices of events from different segments of the observation.</p>
<p>This is a generator, yielding the boundaries of each segment and the
corresponding indices in the time array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>times</strong><span class="classifier">float <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>Array of times.</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti00, gti01], [gti10, gti11], …]</span></dt><dd><p>Good time intervals.</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>Length of segments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>t0: float</dt><dd><p>Start time of current segment.</p>
</dd>
<dt>t1: float</dt><dd><p>End time of current segment.</p>
</dd>
<dt>startidx: int</dt><dd><p>Start index of the current segment in the time array.</p>
</dd>
<dt>stopidx: int</dt><dd><p>End index of the current segment in the time array. Note that this is
larger by one, so that <code class="xref py py-obj docutils literal notranslate"><span class="pre">time[startidx:stopidx]</span></code> returns the correct
time interval.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>check_sorted</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, checks that the time array is sorted.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gtis</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.55</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">generate_indices_of_segment_boundaries_unbinned</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">times</span><span class="p">,</span> <span class="n">gtis</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v0</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v0</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note: 0.5 is not included in the interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v0</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v1</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Again: 1.1 is not included in the interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.get_btis">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">get_btis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#get_btis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.get_btis" title="Link to this definition">¶</a></dt>
<dd><p>From GTIs, obtain bad time intervals, i.e. the intervals <em>not</em> covered
by the GTIs.</p>
<p>GTIs have to be well-behaved, in the sense that they have to pass
<code class="docutils literal notranslate"><span class="pre">check_gtis</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtis</strong><span class="classifier">iterable</span></dt><dd><p>A list of GTIs.</p>
</dd>
<dt><strong>start_time</strong><span class="classifier">float</span></dt><dd><p>Optional start time of the overall observation (e.g. can be earlier
than the first time stamp in <code class="docutils literal notranslate"><span class="pre">gtis</span></code>).</p>
</dd>
<dt><strong>stop_time</strong><span class="classifier">float</span></dt><dd><p>Optional stop time of the overall observation (e.g. can be later than
the last time stamp in``gtis``).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>btis</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>A list of bad time intervals.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.get_gti_extensions_from_pattern">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">get_gti_extensions_from_pattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lchdulist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name_pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GTI'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#get_gti_extensions_from_pattern"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.get_gti_extensions_from_pattern" title="Link to this definition">¶</a></dt>
<dd><p>Gets the GTI extensions that match a given pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lchdulist: `:class:astropy.io.fits.HDUList` object</strong></dt><dd><p>The full content of a FITS file.</p>
</dd>
<dt><strong>name_pattern: str</strong></dt><dd><p>Pattern indicating all the GTI extensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ext_list: list</dt><dd><p>List of GTI extension numbers whose name matches the input pattern.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mf">50.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;START&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;STOP&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdu1</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">TableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">([</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;GTI005XX&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdu2</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">TableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">([</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;GTI00501&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lchdulist</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span><span class="n">hdu1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gtiextn</span> <span class="o">=</span> <span class="n">get_gti_extensions_from_pattern</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">lchdulist</span><span class="p">,</span> <span class="n">name_pattern</span><span class="o">=</span><span class="s1">&#39;GTI005[0-9]+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">gtiextn</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.get_gti_from_all_extensions">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">get_gti_from_all_extensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lchdulist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accepted_gtistrings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['GTI']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_numbers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#get_gti_from_all_extensions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.get_gti_from_all_extensions" title="Link to this definition">¶</a></dt>
<dd><p>Intersect the GTIs from the all accepted extensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lchdulist: `:class:astropy.io.fits.HDUList` object</strong></dt><dd><p>The full content of a FITS file.</p>
</dd>
<dt><strong>accepted_gtistrings: list of str</strong></dt><dd><p>Base strings of GTI extensions. For missions adding the detector number
to GTI extensions like, e.g., XMM and Chandra, this function
automatically adds the detector number and looks for all matching
GTI extensions (e.g. “STDGTI” will also retrieve “STDGTI05”; “GTI0”
will also retrieve “GTI00501”).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>gti_list: [[gti00, gti01], [gti10, gti11], …]</dt><dd><p>List of good time intervals, as the intersection of all matching GTIs.
If there are two matching extensions, with GTIs [[0, 50], [100, 200]]
and [[40, 70]] respectively, this function will return [[40, 50]].</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;START&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;STOP&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdu1</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">TableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">([</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;GTI00501&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;START&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;STOP&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">350</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdu2</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">TableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">([</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;STDGTI05&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lchdulist</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span><span class="n">hdu1</span><span class="p">,</span> <span class="n">hdu2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti</span> <span class="o">=</span> <span class="n">get_gti_from_all_extensions</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">lchdulist</span><span class="p">,</span> <span class="n">accepted_gtistrings</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GTI0&#39;</span><span class="p">,</span> <span class="s1">&#39;STDGTI&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">det_numbers</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="p">[[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">250</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.get_gti_from_hdu">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">get_gti_from_hdu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtihdu</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#get_gti_from_hdu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.get_gti_from_hdu" title="Link to this definition">¶</a></dt>
<dd><p>Get the GTIs from a given FITS extension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtihdu: `:class:astropy.io.fits.TableHDU` object</strong></dt><dd><p>The GTI HDU.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>gti_list: [[gti00, gti01], [gti10, gti11], …]</dt><dd><p>List of good time intervals.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mf">50.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;START&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;STOP&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdu1</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">TableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">([</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;GTI00501&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gti</span> <span class="o">=</span> <span class="n">get_gti_from_hdu</span><span class="p">(</span><span class="n">hdu1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">250</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.get_gti_lengths">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">get_gti_lengths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gti</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#get_gti_lengths"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.get_gti_lengths" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the length of each Good Time Interval.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti</strong><span class="classifier">[[gti00, gti01], [gti10, gti11], …]</span></dt><dd><p>The list of good time intervals.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>lengths</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.ndarray</span></code></span></dt><dd><p>List of GTI lengths.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gti</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">],</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1001</span><span class="p">],</span> <span class="p">[</span><span class="mi">3000</span><span class="p">,</span> <span class="mi">3020</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">get_gti_lengths</span><span class="p">(</span><span class="n">gti</span><span class="p">),</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.get_total_gti_length">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">get_total_gti_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gti</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#get_total_gti_length"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.get_total_gti_length" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the total exposure during Good Time Intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti</strong><span class="classifier">[[gti00, gti01], [gti10, gti11], …]</span></dt><dd><p>The list of good time intervals.</p>
</dd>
<dt><strong>minlen</strong><span class="classifier">float</span></dt><dd><p>Minimum GTI length to consider.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>length</strong><span class="classifier">float</span></dt><dd><p>The total exposure during GTIs.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gti</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">],</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1001</span><span class="p">],</span> <span class="p">[</span><span class="mi">3000</span><span class="p">,</span> <span class="mi">3020</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">get_total_gti_length</span><span class="p">(</span><span class="n">gti</span><span class="p">),</span> <span class="mi">1021</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">get_total_gti_length</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="n">minlen</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="mi">1020</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.gti_border_bins">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">gti_border_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#gti_border_bins"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.gti_border_bins" title="Link to this definition">¶</a></dt>
<dd><p>Find the indices in a time array corresponding to the borders of GTIs.</p>
<p>GTIs shorter than the bin time are not returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtis</strong><span class="classifier">2-d float array</span></dt><dd><p>List of GTIs of the form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code>.</p>
</dd>
<dt><strong>time</strong><span class="classifier">array-like</span></dt><dd><p>Array of time stamps.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum_start_bins</strong><span class="classifier">array-like</span></dt><dd><p>List of starting bins of each GTI</p>
</dd>
<dt><strong>spectrum_stop_bins</strong><span class="classifier">array-like</span></dt><dd><p>List of stop bins of each GTI. The elements corresponding to these bins
should <em>not</em> be included.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">float or array of floats. Default median(diff(time))</span></dt><dd><p>Time resolution of the light curve. Can be an array of the same dimension
as <code class="docutils literal notranslate"><span class="pre">time</span></code></p>
</dd>
<dt><strong>epsilon</strong><span class="classifier">float, default 0.001</span></dt><dd><p>The tolerance, in fraction of <code class="docutils literal notranslate"><span class="pre">dt</span></code>, for the comparisons at the
borders.</p>
</dd>
<dt><strong>fraction_step</strong><span class="classifier">float</span></dt><dd><p>If the step is not a full <code class="docutils literal notranslate"><span class="pre">segment_size</span></code> but less (e.g. a moving
window), this indicates the ratio between step step and
<code class="docutils literal notranslate"><span class="pre">segment_size</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">0.5</span></code> means that the window shifts by half
<code class="docutils literal notranslate"><span class="pre">segment_size</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">13.5</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gti_border_bins</span><span class="p">([[</span><span class="mf">16.</span><span class="p">,</span> <span class="mf">18.</span><span class="p">]],</span> <span class="n">times</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid time interval for the given GTIs</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start_bins</span><span class="p">,</span> <span class="n">stop_bins</span> <span class="o">=</span> <span class="n">gti_border_bins</span><span class="p">(</span>
<span class="gp">... </span>   <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]],</span> <span class="n">times</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">start_bins</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">stop_bins</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">start_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">stop_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">start_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">stop_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mf">6.5</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start_bins</span><span class="p">,</span> <span class="n">stop_bins</span> <span class="o">=</span> <span class="n">gti_border_bins</span><span class="p">(</span>
<span class="gp">... </span>   <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">]],</span> <span class="n">times</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">start_bins</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">stop_bins</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">13</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">start_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">stop_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">start_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">stop_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mf">6.5</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">,</span> <span class="mf">11.5</span><span class="p">,</span> <span class="mf">12.5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.join_gtis">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">join_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gti0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#join_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.join_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Union of two GTIs.</p>
<p>If GTIs are mutually exclusive, it calls <code class="docutils literal notranslate"><span class="pre">append_gtis</span></code>. Otherwise we put
the extremes of partially overlapping GTIs on an ideal line and look at the
number of opened and closed intervals. When the number of closed and opened
intervals is the same, the full GTI is complete and we close it.</p>
<p>In practice, we assign to each opening time of a GTI the value <code class="docutils literal notranslate"><span class="pre">-1</span></code>, and
the value <code class="docutils literal notranslate"><span class="pre">1</span></code> to each closing time; when the cumulative sum is zero, the
GTI has ended. The timestamp after each closed GTI is the start of a new
one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">g_all</span><span class="p">)</span>    <span class="mi">0</span>     <span class="mi">1</span>     <span class="mi">2</span>     <span class="mi">3</span>     <span class="mi">4</span>     <span class="mi">5</span>     <span class="mi">6</span>     <span class="mi">7</span>     <span class="mi">8</span>     <span class="mi">9</span>
<span class="p">(</span><span class="n">cumsum</span><span class="p">)</span>   <span class="o">-</span><span class="mi">1</span>   <span class="o">-</span><span class="mi">2</span>    <span class="o">-</span><span class="mi">1</span>     <span class="mi">0</span>    <span class="o">-</span><span class="mi">1</span>    <span class="o">-</span><span class="mi">2</span>     <span class="o">-</span><span class="mi">1</span>   <span class="o">-</span><span class="mi">2</span>    <span class="o">-</span><span class="mi">1</span>     <span class="mi">0</span>
<span class="n">GTI</span> <span class="n">A</span>      <span class="o">|-----</span><span class="p">:</span><span class="o">-----|</span>     <span class="p">:</span>     <span class="o">|-----</span><span class="p">:</span><span class="o">-----|</span>     <span class="o">|-----</span><span class="p">:</span><span class="o">-----|</span>
<span class="n">FINAL</span> <span class="n">GTI</span>  <span class="o">|-----</span><span class="p">:</span><span class="o">-----------|</span>     <span class="o">|-----</span><span class="p">:</span><span class="o">-----------------</span><span class="p">:</span><span class="o">-----|</span>
<span class="n">GTI</span> <span class="n">B</span>            <span class="o">|-----------|</span>           <span class="o">|-----------------|</span>
</pre></div>
</div>
<p>In case one GTI ends exactly where another one starts, the cumulative sum is 0
but we do not want to close. In this case, we make a check that the next element
of the sequence is not equal to the one where we would close.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">g_all</span><span class="p">)</span>    <span class="mi">0</span>    <span class="mi">1</span><span class="p">,</span><span class="mi">1</span>         <span class="mi">3</span><span class="p">,</span><span class="mi">3</span>          <span class="mi">5</span>
<span class="p">(</span><span class="n">cumsum</span><span class="p">)</span>   <span class="o">-</span><span class="mi">1</span>   <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span>       <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span>         <span class="mi">0</span>
<span class="n">GTI</span> <span class="n">A</span>      <span class="o">|-----|</span>           <span class="o">|-----------|</span>
<span class="n">FINAL</span> <span class="n">GTI</span>  <span class="o">|-----------------------------|</span>
<span class="n">GTI</span> <span class="n">B</span>            <span class="o">|-----------|</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gti0: 2-d float array</strong></dt><dd><p>List of GTIs of the form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code></p>
</dd>
<dt><strong>gti1: 2-d float array</strong></dt><dd><p>List of GTIs of the form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>gti: 2-d float array</dt><dd><p>The newly created GTI</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.load_gtis">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">load_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fits_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtistring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#load_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.load_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Load Good Time Intervals (GTIs) from <code class="docutils literal notranslate"><span class="pre">HDU</span> <span class="pre">EVENTS</span></code> of file <code class="docutils literal notranslate"><span class="pre">fits_file</span></code>.
File is expected to be in FITS format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fits_file</strong><span class="classifier">str</span></dt><dd><p>File name and path for the FITS file with the GTIs to be loaded.</p>
</dd>
<dt><strong>gtistring</strong><span class="classifier">str</span></dt><dd><p>If the name of the FITS extension with the GTIs is not <code class="docutils literal notranslate"><span class="pre">GTI</span></code>, the
alternative name can be set with this parameter.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gti_list</strong><span class="classifier">list</span></dt><dd><p>A list of GTI <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">stop)</span></code> pairs extracted from the FITS file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.gti.time_intervals_from_gtis">
<span class="sig-prename descclassname"><span class="pre">stingray.gti.</span></span><span class="sig-name descname"><span class="pre">time_intervals_from_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gtis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/gti.html#time_intervals_from_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.gti.time_intervals_from_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Compute start/stop times of equal time intervals, compatible with GTIs.</p>
<p>Used to start each FFT/PDS/cospectrum from the start of a GTI,
and stop before the next gap in data (end of GTI).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtis</strong><span class="classifier">2-d float array</span></dt><dd><p>List of GTIs of the form <code class="docutils literal notranslate"><span class="pre">[[gti0_0,</span> <span class="pre">gti0_1],</span> <span class="pre">[gti1_0,</span> <span class="pre">gti1_1],</span> <span class="pre">...]</span></code></p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>Length of the time segments</p>
</dd>
<dt><strong>fraction_step</strong><span class="classifier">float</span></dt><dd><p>If the step is not a full <code class="docutils literal notranslate"><span class="pre">segment_size</span></code> but less (e.g. a moving
window), this indicates the ratio between step step and
<code class="docutils literal notranslate"><span class="pre">segment_size</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">0.5</span></code> means that the window shifts by half
<code class="docutils literal notranslate"><span class="pre">segment_size</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum_start_times</strong><span class="classifier">array-like</span></dt><dd><p>List of starting times to use in the spectral calculations.</p>
</dd>
<dt><strong>spectrum_stop_times</strong><span class="classifier">array-like</span></dt><dd><p>List of end times to use in the spectral calculations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-stingray.io">
<span id="i-o-functionality"></span><h3>I/O Functionality<a class="headerlink" href="#module-stingray.io" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.common_name">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">common_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">str1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">str2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'common'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#common_name"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.common_name" title="Link to this definition">¶</a></dt>
<dd><p>Strip two strings of the letters not in common.</p>
<p>Filenames must be of same length and only differ by a few letters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>str1</strong><span class="classifier">str</span></dt><dd></dd>
<dt><strong>str2</strong><span class="classifier">str</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>common_str</strong><span class="classifier">str</span></dt><dd><p>A string containing the parts of the two names in common</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">str</span></dt><dd><p>The string to return if <code class="docutils literal notranslate"><span class="pre">common_str</span></code> is empty</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.get_file_extension">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">get_file_extension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#get_file_extension"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.get_file_extension" title="Link to this definition">¶</a></dt>
<dd><p>Get the extension from the file name.</p>
<p>If g-zipped, add ‘.gz’ to extension.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_file_extension</span><span class="p">(</span><span class="s1">&#39;ciao.tar&#39;</span><span class="p">)</span>
<span class="go">&#39;.tar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_file_extension</span><span class="p">(</span><span class="s1">&#39;ciao.tar.gz&#39;</span><span class="p">)</span>
<span class="go">&#39;.tar.gz&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_file_extension</span><span class="p">(</span><span class="s1">&#39;ciao.evt.gz&#39;</span><span class="p">)</span>
<span class="go">&#39;.evt.gz&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_file_extension</span><span class="p">(</span><span class="s1">&#39;ciao.a.tutti.evt.gz&#39;</span><span class="p">)</span>
<span class="go">&#39;.evt.gz&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.get_key_from_mission_info">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">get_key_from_mission_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inst</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#get_key_from_mission_info"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.get_key_from_mission_info" title="Link to this definition">¶</a></dt>
<dd><p>Get the name of a header key or table column from the mission database.</p>
<p>Many entries in the mission database have default values that can be
altered for specific instruments or observing modes. Here, if there is a
definition for a given instrument and mode, we take that, otherwise we use
the default).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>info</strong><span class="classifier">dict</span></dt><dd><p>Nested dictionary containing all the information for a given mission.
It can be nested, e.g. contain some info for a given instrument, and
for each observing mode of that instrument.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>The key to read from the info dictionary</p>
</dd>
<dt><strong>default</strong><span class="classifier">object</span></dt><dd><p>The default value. It can be of any type, depending on the expected
type for the entry.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>retval</strong><span class="classifier">object</span></dt><dd><p>The wanted entry from the info dictionary</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inst</strong><span class="classifier">str</span></dt><dd><p>Instrument</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>Observing mode</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ecol&#39;</span><span class="p">:</span> <span class="s1">&#39;PI&#39;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;ecol&quot;</span><span class="p">:</span> <span class="s2">&quot;BLA&quot;</span><span class="p">},</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;M1&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;ecol&quot;</span><span class="p">:</span> <span class="s2">&quot;X&quot;</span><span class="p">}}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_key_from_mission_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;ecol&quot;</span><span class="p">,</span> <span class="s2">&quot;BU&quot;</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">&#39;BLA&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_key_from_mission_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;ecol&quot;</span><span class="p">,</span> <span class="s2">&quot;BU&quot;</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">&#39;PI&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_key_from_mission_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;ecol&quot;</span><span class="p">,</span> <span class="s2">&quot;BU&quot;</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;M1&quot;</span><span class="p">)</span>
<span class="go">&#39;BLA&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_key_from_mission_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;ecol&quot;</span><span class="p">,</span> <span class="s2">&quot;BU&quot;</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;M1&quot;</span><span class="p">)</span>
<span class="go">&#39;X&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_key_from_mission_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;ghghg&quot;</span><span class="p">,</span> <span class="s2">&quot;BU&quot;</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;M1&quot;</span><span class="p">)</span>
<span class="go">&#39;BU&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.high_precision_keyword_read">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">high_precision_keyword_read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hdr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keyword</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#high_precision_keyword_read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.high_precision_keyword_read" title="Link to this definition">¶</a></dt>
<dd><p>Read FITS header keywords, also if split in two.</p>
<p>In the case where the keyword is split in two, like</p>
<blockquote>
<div><p>MJDREF = MJDREFI + MJDREFF</p>
</div></blockquote>
<p>in some missions, this function returns the summed value. Otherwise, the
content of the single keyword</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hdr</strong><span class="classifier">dict_like</span></dt><dd><p>The FITS header structure, or a dictionary</p>
</dd>
<dt><strong>keyword</strong><span class="classifier">str</span></dt><dd><p>The key to read in the header</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>value</strong><span class="classifier">long double</span></dt><dd><p>The value of the key, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if something went wrong</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.lcurve_from_fits">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">lcurve_from_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fits_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtistring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GTI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timecolumn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'TIME'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratecolumn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratehdu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fracexp_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noclobber</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#lcurve_from_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.lcurve_from_fits" title="Link to this definition">¶</a></dt>
<dd><p>Load a lightcurve from a fits file.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>FITS light curve handling is still under testing.
Absolute times might be incorrect depending on the light curve format.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fits_file</strong><span class="classifier">str</span></dt><dd><p>File name of the input light curve in FITS format</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">dict</span></dt><dd><p>Dictionary containing all information needed to create a
<a class="reference internal" href="#stingray.Lightcurve" title="stingray.Lightcurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Lightcurve</span></code></a> object</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gtistring</strong><span class="classifier">str</span></dt><dd><p>Name of the GTI extension in the FITS file</p>
</dd>
<dt><strong>timecolumn</strong><span class="classifier">str</span></dt><dd><p>Name of the column containing times in the FITS file</p>
</dd>
<dt><strong>ratecolumn</strong><span class="classifier">str</span></dt><dd><p>Name of the column containing rates in the FITS file</p>
</dd>
<dt><strong>ratehdu</strong><span class="classifier">str or int</span></dt><dd><p>Name or index of the FITS extension containing the light curve</p>
</dd>
<dt><strong>fracexp_limit</strong><span class="classifier">float</span></dt><dd><p>Minimum exposure fraction allowed</p>
</dd>
<dt><strong>noclobber</strong><span class="classifier">bool</span></dt><dd><p>If True, do not overwrite existing files</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.load_events_and_gtis">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">load_events_and_gtis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fits_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtistring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hduname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#load_events_and_gtis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.load_events_and_gtis" title="Link to this definition">¶</a></dt>
<dd><p>Load event lists and GTIs from one or more files.</p>
<p>Loads event list from HDU EVENTS of file fits_file, with Good Time
intervals. Optionally, returns additional columns of data from the same
HDU of the events.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fits_file</strong><span class="classifier">str</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>retvals</strong><span class="classifier">Object with the following attributes:</span></dt><dd><dl class="simple">
<dt>ev_list<span class="classifier">array-like</span></dt><dd><p>Event times in Mission Epoch Time</p>
</dd>
<dt>gti_list: [[gti0_0, gti0_1], [gti1_0, gti1_1], …]</dt><dd><p>GTIs in Mission Epoch Time</p>
</dd>
<dt>additional_data: dict</dt><dd><p>A dictionary, where each key is the one specified in additional_colums.
The data are an array with the values of the specified column in the
fits file.</p>
</dd>
<dt>t_start<span class="classifier">float</span></dt><dd><p>Start time in Mission Epoch Time</p>
</dd>
<dt>t_stop<span class="classifier">float</span></dt><dd><p>Stop time in Mission Epoch Time</p>
</dd>
<dt>pi_list<span class="classifier">array-like</span></dt><dd><p>Raw Instrument energy channels</p>
</dd>
<dt>cal_pi_list<span class="classifier">array-like</span></dt><dd><p>Calibrated PI channels (those that can be easily converted to energy
values, regardless of the instrument setup.)</p>
</dd>
<dt>energy_list<span class="classifier">array-like</span></dt><dd><p>Energy of each photon in keV (only for NuSTAR, NICER, XMM)</p>
</dd>
<dt>instr<span class="classifier">str</span></dt><dd><p>Name of the instrument (e.g. EPIC-pn or FPMA)</p>
</dd>
<dt>mission<span class="classifier">str</span></dt><dd><p>Name of the instrument (e.g. XMM or NuSTAR)</p>
</dd>
<dt>mjdref<span class="classifier">float</span></dt><dd><p>MJD reference time for the mission</p>
</dd>
<dt>header<span class="classifier">str</span></dt><dd><p>Full header of the FITS file, for debugging purposes</p>
</dd>
<dt>detector_id<span class="classifier">array-like, int</span></dt><dd><p>Detector id for each photon (e.g. each of the CCDs composing XMM’s or
Chandra’s instruments)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>additional_columns: list of str, optional</strong></dt><dd><p>A list of keys corresponding to the additional columns to extract from
the event HDU (ex.: [‘PI’, ‘X’])</p>
</dd>
<dt><strong>gtistring</strong><span class="classifier">str</span></dt><dd><p>Comma-separated list of accepted GTI extensions (default GTI,STDGTI),
with or without appended integer number denoting the detector</p>
</dd>
<dt><strong>gti_file</strong><span class="classifier">str, default None</span></dt><dd><p>External GTI file</p>
</dd>
<dt><strong>hduname</strong><span class="classifier">str or int, default 1</span></dt><dd><p>Name of the HDU containing the event list</p>
</dd>
<dt><strong>column</strong><span class="classifier">str, default None</span></dt><dd><p>The column containing the time values. If None, we use the name
specified in the mission database, and if there is nothing there,
“TIME”</p>
</dd>
<dt><strong>return_limits: bool, optional</strong></dt><dd><p>Return the TSTART and TSTOP keyword values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.mkdir_p">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">mkdir_p</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#mkdir_p"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.mkdir_p" title="Link to this definition">¶</a></dt>
<dd><p>Safe <code class="docutils literal notranslate"><span class="pre">mkdir</span></code> function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>The absolute path to the directory to be created</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.pi_to_energy">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">pi_to_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmf_file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#pi_to_energy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.pi_to_energy" title="Link to this definition">¶</a></dt>
<dd><p>Read the energy channels corresponding to the given PI channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pis</strong><span class="classifier">array-like</span></dt><dd><p>The channels to lookup in the rmf</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rmf_file</strong><span class="classifier">str</span></dt><dd><p>The rmf file used to read the calibration.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.read_header_key">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">read_header_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fits_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#read_header_key"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.read_header_key" title="Link to this definition">¶</a></dt>
<dd><p>Read the header key key from HDU hdu of the file <code class="docutils literal notranslate"><span class="pre">fits_file</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fits_file: str</strong></dt><dd><p>The file name and absolute path to the event file.</p>
</dd>
<dt><strong>key: str</strong></dt><dd><p>The keyword to be read</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>value</strong><span class="classifier">object</span></dt><dd><p>The value stored under <code class="docutils literal notranslate"><span class="pre">key</span></code> in <code class="docutils literal notranslate"><span class="pre">fits_file</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hdu</strong><span class="classifier">int</span></dt><dd><p>Index of the HDU extension from which the header key to be read.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.read_rmf">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">read_rmf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rmf_file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#read_rmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.read_rmf" title="Link to this definition">¶</a></dt>
<dd><p>Load RMF info.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Preliminary: only EBOUNDS are read.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rmf_file</strong><span class="classifier">str</span></dt><dd><p>The rmf file used to read the calibration.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pis</strong><span class="classifier">array-like</span></dt><dd><p>the PI channels</p>
</dd>
<dt><strong>e_mins</strong><span class="classifier">array-like</span></dt><dd><p>the lower energy bound of each PI channel</p>
</dd>
<dt><strong>e_maxs</strong><span class="classifier">array-like</span></dt><dd><p>the upper energy bound of each PI channel</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.ref_mjd">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">ref_mjd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fits_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#ref_mjd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.ref_mjd" title="Link to this definition">¶</a></dt>
<dd><p>Read <code class="docutils literal notranslate"><span class="pre">MJDREFF</span></code>, <code class="docutils literal notranslate"><span class="pre">MJDREFI</span></code> or, if failed, <code class="docutils literal notranslate"><span class="pre">MJDREF</span></code>, from the FITS header.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fits_file</strong><span class="classifier">str</span></dt><dd><p>The file name and absolute path to the event file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mjdref</strong><span class="classifier">numpy.longdouble</span></dt><dd><p>the reference MJD</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hdu</strong><span class="classifier">int</span></dt><dd><p>Index of the HDU extension from which the header key to be read.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.savefig">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">savefig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#savefig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.savefig" title="Link to this definition">¶</a></dt>
<dd><p>Save a figure plotted by <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<p>Note : This function is supposed to be used after the <code class="docutils literal notranslate"><span class="pre">plot</span></code>
function. Otherwise it will save a blank image with no plot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>The name of the image file. Extension must be specified in the
file name. For example filename with <code class="xref py py-obj docutils literal notranslate"><span class="pre">png</span></code> extension will give a
rasterized image while <code class="docutils literal notranslate"><span class="pre">.pdf</span></code> extension will give a vectorized
output.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>Keyword arguments to be passed to <code class="docutils literal notranslate"><span class="pre">savefig</span></code> function of
<code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code>. For example use <code class="xref py py-obj docutils literal notranslate"><span class="pre">bbox_inches='tight'</span></code> to
remove the undesirable whitespace around the image.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.io.split_numbers">
<span class="sig-prename descclassname"><span class="pre">stingray.io.</span></span><span class="sig-name descname"><span class="pre">split_numbers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/io.html#split_numbers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.io.split_numbers" title="Link to this definition">¶</a></dt>
<dd><p>Split high precision number(s) into doubles.</p>
<p>You can specify the number of shifts to move the decimal point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>number: long double</strong></dt><dd><p>The input high precision number which is to be split</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>number_I: double</dt><dd><p>First part of high precision number</p>
</dd>
<dt>number_F: double</dt><dd><p>Second part of high precision number</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shift: integer</strong></dt><dd><p>Move the cut by <code class="xref py py-obj docutils literal notranslate"><span class="pre">shift</span></code> decimal points to the right (left if negative)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mf">12.34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">split_numbers</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.34</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">split_numbers</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">12.34</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">split_numbers</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-stingray.mission_support.missions">
<span id="mission-specific-i-o"></span><h3>Mission-specific I/O<a class="headerlink" href="#module-stingray.mission_support.missions" title="Link to this heading">¶</a></h3>
<p>This module contains functions to interpret data from different missions.</p>
<p>The key functions are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#stingray.mission_support.missions.read_mission_info" title="stingray.mission_support.missions.read_mission_info"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_mission_info</span></code></a>: Search the relevant information about a mission in xselect.mdb.</p></li>
<li><p><a class="reference internal" href="#stingray.mission_support.missions.get_rough_conversion_function" title="stingray.mission_support.missions.get_rough_conversion_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_rough_conversion_function</span></code></a>: Get a rough PI-Energy conversion function for a mission.</p></li>
<li><p><a class="reference internal" href="#stingray.mission_support.missions.mission_specific_event_interpretation" title="stingray.mission_support.missions.mission_specific_event_interpretation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mission_specific_event_interpretation</span></code></a>: Get the mission-specific FITS interpretation
function. This function will take a FITS <a class="reference external" href="https://docs.astropy.org/en/stable/io/fits/api/hdulists.html#astropy.io.fits.HDUList" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.io.fits.HDUList</span></code></a> object and
modify it in place to make the read into Stingray easier.</p></li>
<li><p><a class="reference internal" href="#stingray.mission_support.missions.rough_calibration" title="stingray.mission_support.missions.rough_calibration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rough_calibration</span></code></a> (obsolete): Make a rough conversion between PI channel and energy.</p></li>
</ul>
<p>Whenever a given mission needs complicate processing, its functions can be made available
for specific missions in their own separate modules. For example, the RXTE mission has its
own module, <code class="docutils literal notranslate"><span class="pre">rxte.py</span></code>, which contains functions to interpret RXTE data.</p>
<dl class="py function">
<dt class="sig sig-object py" id="stingray.mission_support.missions.get_rough_conversion_function">
<span class="sig-prename descclassname"><span class="pre">stingray.mission_support.missions.</span></span><span class="sig-name descname"><span class="pre">get_rough_conversion_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mission</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instrument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/mission_support/missions.html#get_rough_conversion_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.mission_support.missions.get_rough_conversion_function" title="Link to this definition">¶</a></dt>
<dd><p>Get a rough PI-Energy conversion function for a mission.</p>
<p>The function should accept a PI channel and return the corresponding energy.
Additional keyword arguments (e.g. epoch, detector) can be passed to the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mission</strong><span class="classifier">str</span></dt><dd><p>Mission name</p>
</dd>
<dt><strong>instrument</strong><span class="classifier">str</span></dt><dd><p>Instrument onboard the mission</p>
</dd>
<dt><strong>epoch</strong><span class="classifier">float</span></dt><dd><p>Epoch of the observation in MJD (important for missions updating their calibration).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>function</dt><dd><p>Conversion function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.mission_support.missions.mission_specific_event_interpretation">
<span class="sig-prename descclassname"><span class="pre">stingray.mission_support.missions.</span></span><span class="sig-name descname"><span class="pre">mission_specific_event_interpretation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mission</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/mission_support/missions.html#mission_specific_event_interpretation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.mission_support.missions.mission_specific_event_interpretation" title="Link to this definition">¶</a></dt>
<dd><p>Get the mission-specific FITS interpretation function.</p>
<p>This function will read a FITS <a class="reference external" href="https://docs.astropy.org/en/stable/io/fits/api/hdulists.html#astropy.io.fits.HDUList" title="(in Astropy v6.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">astropy.io.fits.HDUList</span></code></a> object and modify it
in place to make the read into Stingray easier.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.mission_support.missions.read_mission_info">
<span class="sig-prename descclassname"><span class="pre">stingray.mission_support.missions.</span></span><span class="sig-name descname"><span class="pre">read_mission_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/mission_support/missions.html#read_mission_info"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.mission_support.missions.read_mission_info" title="Link to this definition">¶</a></dt>
<dd><p>Search the relevant information about a mission in xselect.mdb.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.mission_support.missions.rough_calibration">
<span class="sig-prename descclassname"><span class="pre">stingray.mission_support.missions.</span></span><span class="sig-name descname"><span class="pre">rough_calibration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mission</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/mission_support/missions.html#rough_calibration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.mission_support.missions.rough_calibration" title="Link to this definition">¶</a></dt>
<dd><p>Make a rough conversion between PI channel and energy.</p>
<p>Only works for NICER, NuSTAR, IXPE, and XMM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pis: float or array of floats</strong></dt><dd><p>PI channels in data</p>
</dd>
<dt><strong>mission: str</strong></dt><dd><p>Mission name</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>energies</strong><span class="classifier">float or array of floats</span></dt><dd><p>Energy values</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rough_calibration</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;nustar&#39;</span><span class="p">)</span>
<span class="go">1.62</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rough_calibration</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;ixpe&#39;</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># It&#39;s case-insensitive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rough_calibration</span><span class="p">(</span><span class="mi">1200</span><span class="p">,</span> <span class="s1">&#39;XMm&#39;</span><span class="p">)</span>
<span class="go">1.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rough_calibration</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;asDf&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">Mission asdf not recognized</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rough_calibration</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;nicer&#39;</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-stingray.mission_support.rxte"></span><dl class="py function">
<dt class="sig sig-object py" id="stingray.mission_support.rxte.pca_calibration_func">
<span class="sig-prename descclassname"><span class="pre">stingray.mission_support.rxte.</span></span><span class="sig-name descname"><span class="pre">pca_calibration_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epoch</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/mission_support/rxte.html#pca_calibration_func"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.mission_support.rxte.pca_calibration_func" title="Link to this definition">¶</a></dt>
<dd><p>Return the appropriate calibration function for RXTE for a given observing epoch.</p>
<p>This function has signature <code class="docutils literal notranslate"><span class="pre">func(pha,</span> <span class="pre">detector_id)</span></code> and gives the energy corresponding
to the PHA channel for the given detector (array values allowed).</p>
<p>Internally, this is done by pre-allocating some arrays with the energy values for each
PHA channel and detector group (1-4 and 0, due to a damage that PCU 0 incurred in 2000),
and then returning a function that looks up the energy for each channel.</p>
<p>This does not require any interpolation, as the calibration is tabulated for each channel,
and it is pretty efficient given the very small number of channels supported by the PCA (255).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>epoch</strong><span class="classifier">float</span></dt><dd><p>The epoch of the observation in MJD.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>conversion_function</strong><span class="classifier">callable</span></dt><dd><p>A function that converts PHA channel to energy. This function accepts
two arguments: the PHA channel and the PCU number.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conversion_function</span> <span class="o">=</span> <span class="n">pca_calibration_func</span><span class="p">(</span><span class="mi">50082</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">conversion_function</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">3.04</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conversion_function</span> <span class="o">=</span> <span class="n">pca_calibration_func</span><span class="p">(</span><span class="mi">55930</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">conversion_function</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">4.53</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">conversion_function</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">4.49</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">conversion_function</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="p">[</span><span class="mf">4.53</span><span class="p">,</span> <span class="mf">4.49</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">conversion_function</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="p">[</span><span class="mf">4.53</span><span class="p">,</span> <span class="mf">4.90</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.mission_support.rxte.rxte_calibration_func">
<span class="sig-prename descclassname"><span class="pre">stingray.mission_support.rxte.</span></span><span class="sig-name descname"><span class="pre">rxte_calibration_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instrument</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoch</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/mission_support/rxte.html#rxte_calibration_func"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.mission_support.rxte.rxte_calibration_func" title="Link to this definition">¶</a></dt>
<dd><p>Return the calibration function for RXTE at a given epoch.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">calibration_func</span> <span class="o">=</span> <span class="n">rxte_calibration_func</span><span class="p">(</span><span class="s2">&quot;PCa&quot;</span><span class="p">,</span> <span class="mi">50082</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">calibration_func</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="n">pca_calibration_func</span><span class="p">(</span><span class="mi">50082</span><span class="p">)(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rxte_calibration_func</span><span class="p">(</span><span class="s2">&quot;HEXTE&quot;</span><span class="p">,</span> <span class="mi">55930</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Unknown XTE instrument: HEXTE</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.mission_support.rxte.rxte_pca_event_file_interpretation">
<span class="sig-prename descclassname"><span class="pre">stingray.mission_support.rxte.</span></span><span class="sig-name descname"><span class="pre">rxte_pca_event_file_interpretation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hdulist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/mission_support/rxte.html#rxte_pca_event_file_interpretation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.mission_support.rxte.rxte_pca_event_file_interpretation" title="Link to this definition">¶</a></dt>
<dd><p>Interpret the FITS header of an RXTE event file.</p>
<p>At the moment, only science event files are supported. In these files,
the energy channels are stored in a column named PHA. However, this is not
the PHA column that can be directly used to convert to energy. These are
channels that get changed on a per-observation basis, and can be converted
to the “absolute” PHA channels (the ones tabulated in <a class="reference internal" href="#stingray.mission_support.rxte.pca_calibration_func" title="stingray.mission_support.rxte.pca_calibration_func"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pca_calibration_func</span></code></a>)
by using the TEVTB2 keyword. This function changes the content of the PHA column by
putting in the mean “absolute” PHA channel corresponding to each local PHA
channel.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>hdulist</strong><span class="classifier"><a class="reference external" href="https://docs.astropy.org/en/stable/io/fits/api/hdulists.html#astropy.io.fits.HDUList" title="(in Astropy v6.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astropy.io.fits.HDUList</span></code></a></span></dt><dd><p>The FITS file to interpret.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-stingray.utils">
<span id="other-utility-functions"></span><h3>Other Utility Functions<a class="headerlink" href="#module-stingray.utils" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.baseline_als">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">baseline_als</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_baseline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#baseline_als"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.baseline_als" title="Link to this definition">¶</a></dt>
<dd><p>Baseline Correction with Asymmetric Least Squares Smoothing.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd><p>the sample time/number/position</p>
</dd>
<dt><strong>y</strong><span class="classifier">array-like</span></dt><dd><p>the data series corresponding to <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt><strong>lam</strong><span class="classifier">float</span></dt><dd><p>the lambda parameter of the ALS method. This control how much the
baseline can adapt to local changes. A higher value corresponds to a
stiffer baseline</p>
</dd>
<dt><strong>p</strong><span class="classifier">float</span></dt><dd><p>the asymmetry parameter of the ALS method. This controls the overall
slope tolerated for the baseline. A higher value correspond to a
higher possible slope</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>y_subtracted</strong><span class="classifier">array-like, same size as <code class="docutils literal notranslate"><span class="pre">y</span></code></span></dt><dd><p>The initial time series, subtracted from the trend</p>
</dd>
<dt><strong>baseline</strong><span class="classifier">array-like, same size as <code class="docutils literal notranslate"><span class="pre">y</span></code></span></dt><dd><p>Fitted baseline. Only returned if return_baseline is <code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>niter</strong><span class="classifier">int</span></dt><dd><p>The number of iterations to perform</p>
</dd>
<dt><strong>return_baseline</strong><span class="classifier">bool</span></dt><dd><p>return the baseline?</p>
</dd>
<dt><strong>offset_correction</strong><span class="classifier">bool</span></dt><dd><p>also correct for an offset to align with the running mean of the scan</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ysub</span> <span class="o">=</span> <span class="n">baseline_als</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ysub</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.check_isallfinite">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">check_isallfinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#check_isallfinite"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.check_isallfinite" title="Link to this definition">¶</a></dt>
<dd><p>Check if all elements of an array are finite.</p>
<p>Calls <code class="docutils literal notranslate"><span class="pre">_check_isallfinite_numba</span></code> if numba is installed, otherwise
it uses <code class="docutils literal notranslate"><span class="pre">np.isfinite</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">check_isallfinite</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_isallfinite</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_isallfinite</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.contiguous_regions">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">contiguous_regions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#contiguous_regions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.contiguous_regions" title="Link to this definition">¶</a></dt>
<dd><p>Find contiguous <code class="docutils literal notranslate"><span class="pre">True</span></code> regions of the boolean array <code class="docutils literal notranslate"><span class="pre">condition</span></code>.</p>
<p>Return a 2D array where the first column is the start index of the region
and the second column is the end index, found on <a class="reference internal" href="#rc587d705fec0-so-contiguous" id="id19">[so-contiguous]</a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>condition</strong><span class="classifier">bool array</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>idx</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">[[i0_0,</span> <span class="pre">i0_1],</span> <span class="pre">[i1_0,</span> <span class="pre">i1_1],</span> <span class="pre">...]</span></code></span></dt><dd><p>A list of integer couples, with the start and end of each <code class="docutils literal notranslate"><span class="pre">True</span></code> blocks
in the original array</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div role="list" class="citation-list">
<div class="citation" id="rc587d705fec0-so-contiguous" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">so-contiguous</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://stackoverflow.com/questions/4494404/find-large-number-of-consecutive-values-fulfilling-condition-in-a-numpy-array">http://stackoverflow.com/questions/4494404/find-large-number-of-consecutive-values-fulfilling-condition-in-a-numpy-array</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.create_window">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">create_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'uniform'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#create_window"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.create_window" title="Link to this definition">¶</a></dt>
<dd><p>A method to create window functions commonly used in signal processing.</p>
<p>Windows supported are:
Hamming, Hanning, uniform (rectangular window), triangular window,
blackmann window among others.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Total number of data points in window. If negative, abs is taken.</p>
</dd>
<dt><strong>window_type</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">uniform</span></code>, <code class="docutils literal notranslate"><span class="pre">parzen</span></code>, <code class="docutils literal notranslate"><span class="pre">hamming</span></code>, <code class="docutils literal notranslate"><span class="pre">hanning</span></code>, <code class="docutils literal notranslate"><span class="pre">triangular</span></code>,                 <code class="docutils literal notranslate"><span class="pre">welch</span></code>, <code class="docutils literal notranslate"><span class="pre">blackmann</span></code>, <code class="docutils literal notranslate"><span class="pre">flat-top</span></code>}, optional, default <code class="docutils literal notranslate"><span class="pre">uniform</span></code></span></dt><dd><p>Type of window to create.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>window: numpy.ndarray</dt><dd><p>Window function of length <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.excess_variance">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">excess_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fvar'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#excess_variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.excess_variance" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the excess variance.</p>
<p>Vaughan et al. 2003, MNRAS 345, 1271 give three measurements of source
intrinsic variance: if a light curve has a total variance of <span class="math notranslate nohighlight">\(S^2\)</span>,
and each point has an error bar <span class="math notranslate nohighlight">\(\sigma_{err}\)</span>, the <em>excess variance</em>
is defined as</p>
<div class="math notranslate nohighlight">
\[\sigma_{XS} = S^2 - \overline{\sigma_{err}}^2;\]</div>
<p>the <em>normalized excess variance</em> is the excess variance divided by the
square of the mean intensity:</p>
<div class="math notranslate nohighlight">
\[\sigma_{NXS} = \dfrac{\sigma_{XS}}{\overline{x}^2};\]</div>
<p>the <em>fractional mean square variability amplitude</em>, or
<span class="math notranslate nohighlight">\(F_{var}\)</span>, is finally defined as</p>
<div class="math notranslate nohighlight">
\[F_{var} = \sqrt{\dfrac{\sigma_{XS}}{\overline{x}^2}}\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lc</strong><span class="classifier">a <code class="xref py py-class docutils literal notranslate"><span class="pre">Lightcurve</span></code> object</span></dt><dd></dd>
<dt><strong>normalization</strong><span class="classifier">str</span></dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">fvar</span></code>, return the fractional mean square variability <span class="math notranslate nohighlight">\(F_{var}\)</span>.
If <code class="docutils literal notranslate"><span class="pre">none</span></code>, return the unnormalized excess variance variance
<span class="math notranslate nohighlight">\(\sigma_{XS}\)</span>. If <code class="docutils literal notranslate"><span class="pre">norm_xs</span></code>, return the normalized excess variance
<span class="math notranslate nohighlight">\(\sigma_{XS}\)</span></p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>var_xs</strong><span class="classifier">float</span></dt><dd></dd>
<dt><strong>var_xs_err</strong><span class="classifier">float</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.find_nearest">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">find_nearest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'left'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#find_nearest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.find_nearest" title="Link to this definition">¶</a></dt>
<dd><p>Return the array value that is closest to the input value (Abigail Stevens:
Thanks StackOverflow!)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>array</strong><span class="classifier">np.array of ints or floats</span></dt><dd><p>1-D array of numbers to search through. Should already be sorted
from low values to high values.</p>
</dd>
<dt><strong>value</strong><span class="classifier">int or float</span></dt><dd><p>The value you want to find the closest to in the array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>array[idx]</strong><span class="classifier">int or float</span></dt><dd><p>The array value that is closest to the input value.</p>
</dd>
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The index of the array of the closest value.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>side</strong><span class="classifier">str</span></dt><dd><p>Look at the <code class="docutils literal notranslate"><span class="pre">numpy.searchsorted</span></code> documentation for more information.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.get_random_state">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">get_random_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#get_random_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.get_random_state" title="Link to this definition">¶</a></dt>
<dd><p>Return a Mersenne Twister pseudo-random number generator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>seed</strong><span class="classifier">integer or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>, optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>random_state</strong><span class="classifier">mtrand.RandomState object</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.heaviside">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">heaviside</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#heaviside"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.heaviside" title="Link to this definition">¶</a></dt>
<dd><p>Heaviside function. Returns 1 if x&gt;0, and 0 otherwise.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">heaviside</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heaviside</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.is_int">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">is_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#is_int"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.is_int" title="Link to this definition">¶</a></dt>
<dd><p>Test if object is an integer.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.is_iterable">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">is_iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#is_iterable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.is_iterable" title="Link to this definition">¶</a></dt>
<dd><p>Test if a variable  is an iterable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>var</strong><span class="classifier">object</span></dt><dd><p>The variable to be tested for iterably-ness</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_iter</strong><span class="classifier">bool</span></dt><dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">var</span></code> is an <code class="docutils literal notranslate"><span class="pre">Iterable</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.is_string">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">is_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#is_string"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.is_string" title="Link to this definition">¶</a></dt>
<dd><p>Portable function to answer whether a variable is a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s</strong><span class="classifier">object</span></dt><dd><p>An object that is potentially a string</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isstring</strong><span class="classifier">bool</span></dt><dd><p>A boolean decision on whether <code class="docutils literal notranslate"><span class="pre">s</span></code> is a string or not</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.look_for_array_in_array">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">look_for_array_in_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#look_for_array_in_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.look_for_array_in_array" title="Link to this definition">¶</a></dt>
<dd><p>Find a subset of values in an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>array1</strong><span class="classifier">iterable</span></dt><dd><p>An array with values to be searched</p>
</dd>
<dt><strong>array2</strong><span class="classifier">iterable</span></dt><dd><p>A second array which potentially contains a subset of values
also contained in <code class="docutils literal notranslate"><span class="pre">array1</span></code></p>
</dd>
<dt><strong>Returns ——- array3</strong><span class="classifier">iterable An array with the subset of values</span></dt><dd></dd>
<dt><strong>contained in both ``array1`` and ``array2``</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.make_dictionary_lowercase">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">make_dictionary_lowercase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recursive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#make_dictionary_lowercase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.make_dictionary_lowercase" title="Link to this definition">¶</a></dt>
<dd><p>Make all keys of a dictionary lowercase.</p>
<p>Optionally, if some values are dictionaries, they can be made lowercase too.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dictionary</strong><span class="classifier">dict</span></dt><dd><p>The dictionary to be made lowercase</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>recursive</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, make all keys of nested dictionaries lowercase too.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d1</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span> <span class="o">=</span> <span class="n">make_dictionary_lowercase</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">d2</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d3</span> <span class="o">=</span> <span class="n">make_dictionary_lowercase</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">d3</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.nearest_power_of_two">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">nearest_power_of_two</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#nearest_power_of_two"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.nearest_power_of_two" title="Link to this definition">¶</a></dt>
<dd><p>Return a number which is nearest to <code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code> and is the integral power of two.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">int, float</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x_nearest</strong><span class="classifier">int</span></dt><dd><p>Number closest to <code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code> and is the integral power of two.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.optimal_bin_time">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">optimal_bin_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fftlen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tbin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#optimal_bin_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.optimal_bin_time" title="Link to this definition">¶</a></dt>
<dd><p>Vary slightly the bin time to have a power of two number of bins.</p>
<p>Given an FFT length and a proposed bin time, return a bin time
slightly shorter than the original, that will produce a power-of-two number
of FFT bins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fftlen</strong><span class="classifier">int</span></dt><dd><p>Number of positive frequencies in a proposed Fourier spectrum</p>
</dd>
<dt><strong>tbin</strong><span class="classifier">float</span></dt><dd><p>The proposed time resolution of a light curve</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>res</strong><span class="classifier">float</span></dt><dd><p>A time resolution that will produce a Fourier spectrum with <code class="docutils literal notranslate"><span class="pre">fftlen</span></code> frequencies and
a number of FFT bins that are a power of two</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.order_list_of_arrays">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">order_list_of_arrays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#order_list_of_arrays"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.order_list_of_arrays" title="Link to this definition">¶</a></dt>
<dd><p>Sort an array according to the specified order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">iterable</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">list or dict</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.poisson_symmetrical_errors">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">poisson_symmetrical_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">counts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#poisson_symmetrical_errors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.poisson_symmetrical_errors" title="Link to this definition">¶</a></dt>
<dd><p>Optimized version of frequentist symmetrical errors.</p>
<p>Uses a lookup table in order to limit the calls to poisson_conf_interval</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>counts</strong><span class="classifier">iterable</span></dt><dd><p>An array of Poisson-distributed numbers</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>err</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of uncertainties associated with the Poisson counts in
<code class="docutils literal notranslate"><span class="pre">counts</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy.stats</span> <span class="kn">import</span> <span class="n">poisson_conf_interval</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ---- Do it without the lookup table ----</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">err_low</span><span class="p">,</span> <span class="n">err_high</span> <span class="o">=</span> <span class="n">poisson_conf_interval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">counts</span><span class="p">),</span>
<span class="gp">... </span>                <span class="n">interval</span><span class="o">=</span><span class="s1">&#39;frequentist-confidence&#39;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">err_low</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">err_high</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">err_low</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">err_high</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Do it with this function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">err_thisfun</span> <span class="o">=</span> <span class="n">poisson_symmetrical_errors</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test that results are always the same</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">err_thisfun</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.rebin_data">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">rebin_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yerr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sum'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#rebin_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.rebin_data" title="Link to this definition">¶</a></dt>
<dd><p>Rebin some data to an arbitrary new data resolution. Either sum
the data points in the new bins or average them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: iterable</strong></dt><dd><p>The dependent variable with some resolution, which can vary throughout
the time series.</p>
</dd>
<dt><strong>y: iterable</strong></dt><dd><p>The independent variable to be binned</p>
</dd>
<dt><strong>dx_new: float</strong></dt><dd><p>The new resolution of the dependent variable <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>xbin: numpy.ndarray</dt><dd><p>The midpoints of the new bins in <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt>ybin: numpy.ndarray</dt><dd><p>The binned quantity <code class="docutils literal notranslate"><span class="pre">y</span></code></p>
</dd>
<dt>ybin_err: numpy.ndarray</dt><dd><p>The uncertainties of the binned values of <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
<dt>step_size: float</dt><dd><p>The size of the binning step</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>yerr: iterable, optional</strong></dt><dd><p>The uncertainties of <code class="docutils literal notranslate"><span class="pre">y</span></code>, to be propagated during binning.</p>
</dd>
<dt><strong>method: {``sum`` | ``average`` | ``mean``}, optional, default ``sum``</strong></dt><dd><p>The method to be used in binning. Either sum the samples <code class="docutils literal notranslate"><span class="pre">y</span></code> in
each new bin of <code class="docutils literal notranslate"><span class="pre">x</span></code>, or take the arithmetic mean.</p>
</dd>
<dt><strong>dx: float</strong></dt><dd><p>The old resolution (otherwise, calculated from difference between
time bins)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xbin</span><span class="p">,</span> <span class="n">ybin</span><span class="p">,</span> <span class="n">ybinerr</span><span class="p">,</span> <span class="n">step_size</span> <span class="o">=</span> <span class="n">rebin_data</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ybin</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ybinerr</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xbin</span><span class="p">,</span> <span class="n">ybin</span><span class="p">,</span> <span class="n">ybinerr</span><span class="p">,</span> <span class="n">step_size</span> <span class="o">=</span> <span class="n">rebin_data</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ybin</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ybinerr</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.rebin_data_log">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">rebin_data_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#rebin_data_log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.rebin_data_log" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic re-bin of some data. Particularly useful for the power
spectrum.</p>
<p>The new dependent variable depends on the previous dependent variable
modified by a factor f:</p>
<div class="math notranslate nohighlight">
\[d\nu_j = d\nu_{j-1} (1+f)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: iterable</strong></dt><dd><p>The dependent variable with some resolution <code class="docutils literal notranslate"><span class="pre">dx_old</span> <span class="pre">=</span> <span class="pre">x[1]-x[0]</span></code></p>
</dd>
<dt><strong>y: iterable</strong></dt><dd><p>The independent variable to be binned</p>
</dd>
<dt><strong>f: float</strong></dt><dd><p>The factor of increase of each bin wrt the previous one.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>xbin: numpy.ndarray</dt><dd><p>The midpoints of the new bins in <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt>ybin: numpy.ndarray</dt><dd><p>The binned quantity <code class="docutils literal notranslate"><span class="pre">y</span></code></p>
</dd>
<dt>ybin_err: numpy.ndarray</dt><dd><p>The uncertainties of the binned values of <code class="docutils literal notranslate"><span class="pre">y</span></code></p>
</dd>
<dt>step_size: float</dt><dd><p>The size of the binning step</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>yerr: iterable, optional</strong></dt><dd><p>The uncertainties of <code class="docutils literal notranslate"><span class="pre">y</span></code> to be propagated during binning.</p>
</dd>
<dt><strong>method: {``sum`` | ``average`` | ``mean``}, optional, default ``sum``</strong></dt><dd><p>The method to be used in binning. Either sum the samples <code class="docutils literal notranslate"><span class="pre">y</span></code> in
each new bin of <code class="docutils literal notranslate"><span class="pre">x</span></code> or take the arithmetic mean.</p>
</dd>
<dt><strong>dx: float, optional</strong></dt><dd><p>The binning step of the initial <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.simon">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">simon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#simon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.simon" title="Link to this definition">¶</a></dt>
<dd><p>The Statistical Interpretation MONitor.</p>
<p>A warning system designed to always remind the user that Simon
is watching him/her.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>message</strong><span class="classifier">string</span></dt><dd><p>The message that is thrown</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>The rest of the arguments that are passed to <code class="docutils literal notranslate"><span class="pre">warnings.warn</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.utils.standard_error">
<span class="sig-prename descclassname"><span class="pre">stingray.utils.</span></span><span class="sig-name descname"><span class="pre">standard_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/utils.html#standard_error"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.utils.standard_error" title="Link to this definition">¶</a></dt>
<dd><p>Return the standard error of the mean (SEM) of an array of arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xs</strong><span class="classifier">2-d float array</span></dt><dd><p>List of data point arrays.</p>
</dd>
<dt><strong>mean</strong><span class="classifier">1-d float array</span></dt><dd><p>Average of the data points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>standard_error</strong><span class="classifier">1-d float array</span></dt><dd><p>Standard error of the mean (SEM).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="modeling">
<h2>Modeling<a class="headerlink" href="#modeling" title="Link to this heading">¶</a></h2>
<p>This subpackage defines classes and functions related to parametric modelling of various types of
data sets. Currently, most functionality is focused on modelling Fourier products (especially
power spectra and averaged power spectra), but rudimentary functionality exists for modelling
e.g. light curves.</p>
<section id="log-likelihood-classes">
<span id="loglikelihoods"></span><h3>Log-Likelihood Classes<a class="headerlink" href="#log-likelihood-classes" title="Link to this heading">¶</a></h3>
<p>These classes define basic log-likelihoods for modelling time series and power spectra.
<a class="reference internal" href="#stingray.modeling.LogLikelihood" title="stingray.modeling.LogLikelihood"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.LogLikelihood</span></code></a> is an abstract base class, i.e. a template for creating
user-defined log-likelihoods and should not be instantiated itself. Based on this base class
are several definitions for a <a class="reference internal" href="#stingray.modeling.GaussianLogLikelihood" title="stingray.modeling.GaussianLogLikelihood"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.GaussianLogLikelihood</span></code></a>, appropriate for
data with normally distributed uncertainties, a <a class="reference internal" href="#stingray.modeling.PoissonLogLikelihood" title="stingray.modeling.PoissonLogLikelihood"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.PoissonLogLikelihood</span></code></a>
appropriate for photon counting data, and a <a class="reference internal" href="#stingray.modeling.PSDLogLikelihood" title="stingray.modeling.PSDLogLikelihood"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.PSDLogLikelihood</span></code></a>
appropriate for (averaged) power spectra.</p>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.LogLikelihood">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">LogLikelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#LogLikelihood"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.LogLikelihood" title="Link to this definition">¶</a></dt>
<dd><p>Abstract Base Class defining the structure of a <a class="reference internal" href="#stingray.modeling.LogLikelihood" title="stingray.modeling.LogLikelihood"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogLikelihood</span></code></a> object.
This class cannot be called itself, since each statistical distribution
has its own definition for the likelihood, which should occur in subclasses.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">iterable</span></dt><dd><p>x-coordinate of the data. Could be multi-dimensional.</p>
</dd>
<dt><strong>y</strong><span class="classifier">iterable</span></dt><dd><p>y-coordinate of the data. Could be multi-dimensional.</p>
</dd>
<dt><strong>model</strong><span class="classifier">an <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code> instance</span></dt><dd><p>Your model</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>keyword arguments specific to the individual sub-classes. For
details, see the respective docstrings for each subclass</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.LogLikelihood.evaluate">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#LogLikelihood.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.LogLikelihood.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>This is where you define your log-likelihood. Do this, but do it in a subclass!</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.GaussianLogLikelihood">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">GaussianLogLikelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yerr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#GaussianLogLikelihood"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.GaussianLogLikelihood" title="Link to this definition">¶</a></dt>
<dd><p>Likelihood for data with Gaussian uncertainties.
Astronomers also call this likelihood <em>Chi-Squared</em>, but be aware
that this has <em>nothing</em> to do with the likelihood based on the
Chi-square distribution, which is also defined as in of
<a class="reference internal" href="#stingray.modeling.PSDLogLikelihood" title="stingray.modeling.PSDLogLikelihood"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSDLogLikelihood</span></code></a> in this module!</p>
<p>Use this class here whenever your data has Gaussian uncertainties.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">iterable</span></dt><dd><p>x-coordinate of the data</p>
</dd>
<dt><strong>y</strong><span class="classifier">iterable</span></dt><dd><p>y-coordinte of the data</p>
</dd>
<dt><strong>yerr</strong><span class="classifier">iterable</span></dt><dd><p>the uncertainty on the data, as standard deviation</p>
</dd>
<dt><strong>model</strong><span class="classifier">an <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code> instance</span></dt><dd><p>The model to use in the likelihood.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">iterable</span></dt><dd><p>x-coordinate of the data</p>
</dd>
<dt><strong>y</strong><span class="classifier">iterable</span></dt><dd><p>y-coordinte of the data</p>
</dd>
<dt><strong>yerr</strong><span class="classifier">iterable</span></dt><dd><p>the uncertainty on the data, as standard deviation</p>
</dd>
<dt><strong>model</strong><span class="classifier">an Astropy Model instance</span></dt><dd><p>The model to use in the likelihood.</p>
</dd>
<dt><strong>npar</strong><span class="classifier">int</span></dt><dd><p>The number of free parameters in the model</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.GaussianLogLikelihood.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#GaussianLogLikelihood.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.GaussianLogLikelihood.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>Evaluate the Gaussian log-likelihood for a given set of parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>pars</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of parameters at which to evaluate the model
and subsequently the log-likelihood. Note that the
length of this array must match the free parameters in
<code class="docutils literal notranslate"><span class="pre">model</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">npar</span></code></p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the <em>negative</em> log-likelihood, i.e.
<code class="docutils literal notranslate"><span class="pre">-loglike</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">loglike</span></code>. This is useful e.g.
for optimization routines, which generally minimize
functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>loglike</strong><span class="classifier">float</span></dt><dd><p>The log(likelihood) value for the data and model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.PoissonLogLikelihood">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">PoissonLogLikelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#PoissonLogLikelihood"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PoissonLogLikelihood" title="Link to this definition">¶</a></dt>
<dd><p>Likelihood for data with uncertainties following a Poisson distribution.
This is useful e.g. for (binned) photon count data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">iterable</span></dt><dd><p>x-coordinate of the data</p>
</dd>
<dt><strong>y</strong><span class="classifier">iterable</span></dt><dd><p>y-coordinte of the data</p>
</dd>
<dt><strong>model</strong><span class="classifier">an <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code> instance</span></dt><dd><p>The model to use in the likelihood.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>x</strong><span class="classifier">iterable</span></dt><dd><p>x-coordinate of the data</p>
</dd>
<dt><strong>y</strong><span class="classifier">iterable</span></dt><dd><p>y-coordinte of the data</p>
</dd>
<dt><strong>yerr</strong><span class="classifier">iterable</span></dt><dd><p>the uncertainty on the data, as standard deviation</p>
</dd>
<dt><strong>model</strong><span class="classifier">an <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code> instance</span></dt><dd><p>The model to use in the likelihood.</p>
</dd>
<dt><strong>npar</strong><span class="classifier">int</span></dt><dd><p>The number of free parameters in the model</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PoissonLogLikelihood.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#PoissonLogLikelihood.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PoissonLogLikelihood.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>Evaluate the log-likelihood for a given set of parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>pars</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of parameters at which to evaluate the model
and subsequently the log-likelihood. Note that the
length of this array must match the free parameters in
<code class="docutils literal notranslate"><span class="pre">model</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">npar</span></code></p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the <em>negative</em> log-likelihood, i.e.
<code class="docutils literal notranslate"><span class="pre">-loglike</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">loglike</span></code>. This is useful e.g.
for optimization routines, which generally minimize
functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>loglike</strong><span class="classifier">float</span></dt><dd><p>The log(likelihood) value for the data and model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.PSDLogLikelihood">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">PSDLogLikelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#PSDLogLikelihood"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDLogLikelihood" title="Link to this definition">¶</a></dt>
<dd><p>A likelihood based on the Chi-square distribution, appropriate for modelling
(averaged) power spectra. Note that this is <em>not</em> the same as the statistic
astronomers commonly call <em>Chi-Square</em>, which is a fit statistic derived from
the Gaussian log-likelihood, defined elsewhere in this module.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>freq</strong><span class="classifier">iterable</span></dt><dd><p>Array with frequencies</p>
</dd>
<dt><strong>power</strong><span class="classifier">iterable</span></dt><dd><p>Array with (averaged/singular) powers corresponding to the
frequencies in <code class="docutils literal notranslate"><span class="pre">freq</span></code></p>
</dd>
<dt><strong>model</strong><span class="classifier">an <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code> instance</span></dt><dd><p>The model to use in the likelihood.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>1/2 of the degrees of freedom</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>x</strong><span class="classifier">iterable</span></dt><dd><p>x-coordinate of the data</p>
</dd>
<dt><strong>y</strong><span class="classifier">iterable</span></dt><dd><p>y-coordinte of the data</p>
</dd>
<dt><strong>yerr</strong><span class="classifier">iterable</span></dt><dd><p>the uncertainty on the data, as standard deviation</p>
</dd>
<dt><strong>model</strong><span class="classifier">an <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code> instance</span></dt><dd><p>The model to use in the likelihood.</p>
</dd>
<dt><strong>npar</strong><span class="classifier">int</span></dt><dd><p>The number of free parameters in the model</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDLogLikelihood.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#PSDLogLikelihood.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDLogLikelihood.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>Evaluate the log-likelihood for a given set of parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>pars</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of parameters at which to evaluate the model
and subsequently the log-likelihood. Note that the
length of this array must match the free parameters in
<code class="docutils literal notranslate"><span class="pre">model</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">npar</span></code></p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the <em>negative</em> log-likelihood, i.e.
<code class="docutils literal notranslate"><span class="pre">-loglike</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">loglike</span></code>. This is useful e.g.
for optimization routines, which generally minimize
functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>loglike</strong><span class="classifier">float</span></dt><dd><p>The log(likelihood) value for the data and model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.LaplaceLogLikelihood">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">LaplaceLogLikelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yerr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#LaplaceLogLikelihood"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.LaplaceLogLikelihood" title="Link to this definition">¶</a></dt>
<dd><p>A Laplace likelihood for the cospectrum.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">iterable</span></dt><dd><p>Array with independent variable</p>
</dd>
<dt><strong>y</strong><span class="classifier">iterable</span></dt><dd><p>Array with dependent variable</p>
</dd>
<dt><strong>model</strong><span class="classifier">an <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code> instance</span></dt><dd><p>The model to use in the likelihood.</p>
</dd>
<dt><strong>yerr</strong><span class="classifier">iterable</span></dt><dd><p>Array with the uncertainties on <code class="docutils literal notranslate"><span class="pre">y</span></code>, in standard deviation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>x</strong><span class="classifier">iterable</span></dt><dd><p>x-coordinate of the data</p>
</dd>
<dt><strong>y</strong><span class="classifier">iterable</span></dt><dd><p>y-coordinte of the data</p>
</dd>
<dt><strong>yerr</strong><span class="classifier">iterable</span></dt><dd><p>the uncertainty on the data, as standard deviation</p>
</dd>
<dt><strong>model</strong><span class="classifier">an <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code> instance</span></dt><dd><p>The model to use in the likelihood.</p>
</dd>
<dt><strong>npar</strong><span class="classifier">int</span></dt><dd><p>The number of free parameters in the model</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.LaplaceLogLikelihood.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#LaplaceLogLikelihood.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.LaplaceLogLikelihood.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>Evaluate the log-likelihood for a given set of parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>pars</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of parameters at which to evaluate the model
and subsequently the log-likelihood. Note that the
length of this array must match the free parameters in
<code class="docutils literal notranslate"><span class="pre">model</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">npar</span></code></p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the <em>negative</em> log-likelihood, i.e.
<code class="docutils literal notranslate"><span class="pre">-loglike</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">loglike</span></code>. This is useful e.g.
for optimization routines, which generally minimize
functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>loglike</strong><span class="classifier">float</span></dt><dd><p>The log(likelihood) value for the data and model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="posterior-classes">
<h3>Posterior Classes<a class="headerlink" href="#posterior-classes" title="Link to this heading">¶</a></h3>
<p>These classes define basic posteriors for parametric modelling of time series and power spectra, based on
the log-likelihood classes defined in <a class="reference internal" href="#loglikelihoods"><span class="std std-ref">Log-Likelihood Classes</span></a>. <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.Posterior</span></code></a> is an
abstract base class laying out a basic template for defining posteriors. As with the log-likelihood classes
above, several posterior classes are defined for a variety of data types.</p>
<p>Note that priors are <strong>not</strong> pre-defined in these classes, since they are problem dependent and should be
set by the user. The convenience function <a class="reference internal" href="#stingray.modeling.set_logprior" title="stingray.modeling.set_logprior"><code class="xref py py-func docutils literal notranslate"><span class="pre">stingray.modeling.set_logprior()</span></code></a> can be useful to help set
priors for these posterior classes.</p>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.Posterior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">Posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#Posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.Posterior" title="Link to this definition">¶</a></dt>
<dd><p>Define a <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object.</p>
<p>The <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> describes the Bayesian probability distribution of
a set of parameters <span class="math notranslate nohighlight">\(\theta\)</span> given some observed data <span class="math notranslate nohighlight">\(D\)</span> and
some prior assumptions <span class="math notranslate nohighlight">\(I\)</span>.</p>
<p>It is defined as</p>
<div class="math notranslate nohighlight">
\[p(\theta | D, I) = p(D | \theta, I) p(\theta | I)/p(D| I)\]</div>
<p>where <span class="math notranslate nohighlight">\(p(D | \theta, I)\)</span> describes the likelihood, i.e. the
sampling distribution of the data and the (parametric) model, and
<span class="math notranslate nohighlight">\(p(\theta | I)\)</span> describes the prior distribution, i.e. our information
about the parameters <span class="math notranslate nohighlight">\(\theta\)</span> before we gathered the data.
The marginal likelihood <span class="math notranslate nohighlight">\(p(D| I)\)</span> describes the probability of
observing the data given the model assumptions, integrated over the
space of all parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">iterable</span></dt><dd><p>The abscissa or independent variable of the data. This could
in principle be a multi-dimensional array.</p>
</dd>
<dt><strong>y</strong><span class="classifier">iterable</span></dt><dd><p>The ordinate or dependent variable of the data.</p>
</dd>
<dt><strong>model</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">astropy.modeling.models</span></code> instance</span></dt><dd><p>The parametric model supposed to represent the data. For details
see the <code class="docutils literal notranslate"><span class="pre">astropy.modeling</span></code> documentation</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>keyword arguments related to the subclasses of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a>. For
details, see the documentation of the individual subclasses</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Sivia, D. S., and J. Skilling. “Data Analysis:         A Bayesian Tutorial. 2006.”</p></li>
<li><p>Gelman, Andrew, et al. Bayesian data analysis. Vol. 2. Boca Raton,         FL, USA: Chapman &amp; Hall/CRC, 2014.</p></li>
<li><p>von Toussaint, Udo. “Bayesian inference in physics.”         Reviews of Modern Physics 83.3 (2011): 943.</p></li>
<li><p>Hogg, David W. “Probability Calculus for inference”.         arxiv: 1205.4446</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.Posterior.logposterior">
<span class="sig-name descname"><span class="pre">logposterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#Posterior.logposterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.Posterior.logposterior" title="Link to this definition">¶</a></dt>
<dd><p>Definition of the log-posterior.
Requires methods <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> and <code class="docutils literal notranslate"><span class="pre">logprior</span></code> to both
be defined.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> is set in the subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a>
appropriate for your problem at hand, as is <code class="docutils literal notranslate"><span class="pre">logprior</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>t0</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of parameters at which to evaluate the model
and subsequently the log-posterior. Note that the
length of this array must match the free parameters in
<code class="docutils literal notranslate"><span class="pre">model</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">npar</span></code></p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the <em>negative</em> log-posterior, i.e.
<code class="docutils literal notranslate"><span class="pre">-lpost</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">lpost</span></code>. This is useful e.g.
for optimization routines, which generally minimize
functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lpost</strong><span class="classifier">float</span></dt><dd><p>The value of the log-posterior for the given parameters <code class="docutils literal notranslate"><span class="pre">t0</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.GaussianPosterior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">GaussianPosterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yerr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#GaussianPosterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.GaussianPosterior" title="Link to this definition">¶</a></dt>
<dd><p>A general class for two-dimensional data following a Gaussian
sampling distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>independent variable</p>
</dd>
<dt><strong>y</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>dependent variable</p>
</dd>
<dt><strong>yerr</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>measurement uncertainties for y</p>
</dd>
<dt><strong>model</strong><span class="classifier">instance of any subclass of <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code></span></dt><dd><p>The model for the power spectrum.</p>
</dd>
<dt><strong>priors</strong><span class="classifier">dict of form <code class="docutils literal notranslate"><span class="pre">{&quot;parameter</span> <span class="pre">name&quot;:</span> <span class="pre">function}</span></code>, optional</span></dt><dd><p>A dictionary with the definitions for the prior probabilities.
For each parameter in <code class="docutils literal notranslate"><span class="pre">model</span></code>, there must be a prior defined with
a key of the exact same name as stored in <code class="docutils literal notranslate"><span class="pre">model.param_names</span></code>.
The item for each key is a function definition defining the prior
(e.g. a lambda function or a <code class="docutils literal notranslate"><span class="pre">scipy.stats.distribution.pdf</span></code>.
If <code class="docutils literal notranslate"><span class="pre">priors</span> <span class="pre">=</span> <span class="pre">None</span></code>, then no prior is set. This means priors need
to be added by hand using the <a class="reference internal" href="#stingray.modeling.set_logprior" title="stingray.modeling.set_logprior"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_logprior()</span></code></a> function defined in
this module. Note that it is impossible to call a <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object
itself or the <code class="docutils literal notranslate"><span class="pre">self.logposterior</span></code> method without defining a prior.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.GaussianPosterior.logposterior">
<span class="sig-name descname"><span class="pre">logposterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.modeling.GaussianPosterior.logposterior" title="Link to this definition">¶</a></dt>
<dd><p>Definition of the log-posterior.
Requires methods <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> and <code class="docutils literal notranslate"><span class="pre">logprior</span></code> to both
be defined.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> is set in the subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a>
appropriate for your problem at hand, as is <code class="docutils literal notranslate"><span class="pre">logprior</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>t0</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of parameters at which to evaluate the model
and subsequently the log-posterior. Note that the
length of this array must match the free parameters in
<code class="docutils literal notranslate"><span class="pre">model</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">npar</span></code></p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the <em>negative</em> log-posterior, i.e.
<code class="docutils literal notranslate"><span class="pre">-lpost</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">lpost</span></code>. This is useful e.g.
for optimization routines, which generally minimize
functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lpost</strong><span class="classifier">float</span></dt><dd><p>The value of the log-posterior for the given parameters <code class="docutils literal notranslate"><span class="pre">t0</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.PoissonPosterior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">PoissonPosterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#PoissonPosterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PoissonPosterior" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> for Poisson light curve data. Primary intended use is for
modelling X-ray light curves, but alternative uses are conceivable.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The independent variable (e.g. time stamps of a light curve)</p>
</dd>
<dt><strong>y</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The dependent variable (e.g. counts per bin of a light curve)</p>
</dd>
<dt><strong>model</strong><span class="classifier">instance of any subclass of <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code></span></dt><dd><p>The model for the power spectrum.</p>
</dd>
<dt><strong>priors</strong><span class="classifier">dict of form <code class="docutils literal notranslate"><span class="pre">{&quot;parameter</span> <span class="pre">name&quot;:</span> <span class="pre">function}</span></code>, optional</span></dt><dd><p>A dictionary with the definitions for the prior probabilities.
For each parameter in <code class="docutils literal notranslate"><span class="pre">model</span></code>, there must be a prior defined with
a key of the exact same name as stored in <code class="docutils literal notranslate"><span class="pre">model.param_names</span></code>.
The item for each key is a function definition defining the prior
(e.g. a lambda function or a <code class="docutils literal notranslate"><span class="pre">scipy.stats.distribution.pdf</span></code>.
If <code class="docutils literal notranslate"><span class="pre">priors</span> <span class="pre">=</span> <span class="pre">None</span></code>, then no prior is set. This means priors need
to be added by hand using the <a class="reference internal" href="#stingray.modeling.set_logprior" title="stingray.modeling.set_logprior"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_logprior()</span></code></a> function defined in
this module. Note that it is impossible to call a <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object
itself or the <code class="docutils literal notranslate"><span class="pre">self.logposterior</span></code> method without defining a prior.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The independent variable (list of frequencies) stored in ps.freq</p>
</dd>
<dt><strong>y</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The dependent variable (list of powers) stored in ps.power</p>
</dd>
<dt><strong>model</strong><span class="classifier">instance of any subclass of <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code></span></dt><dd><p>The model for the power spectrum.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PoissonPosterior.logposterior">
<span class="sig-name descname"><span class="pre">logposterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.modeling.PoissonPosterior.logposterior" title="Link to this definition">¶</a></dt>
<dd><p>Definition of the log-posterior.
Requires methods <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> and <code class="docutils literal notranslate"><span class="pre">logprior</span></code> to both
be defined.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> is set in the subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a>
appropriate for your problem at hand, as is <code class="docutils literal notranslate"><span class="pre">logprior</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>t0</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of parameters at which to evaluate the model
and subsequently the log-posterior. Note that the
length of this array must match the free parameters in
<code class="docutils literal notranslate"><span class="pre">model</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">npar</span></code></p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the <em>negative</em> log-posterior, i.e.
<code class="docutils literal notranslate"><span class="pre">-lpost</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">lpost</span></code>. This is useful e.g.
for optimization routines, which generally minimize
functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lpost</strong><span class="classifier">float</span></dt><dd><p>The value of the log-posterior for the given parameters <code class="docutils literal notranslate"><span class="pre">t0</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.PSDPosterior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">PSDPosterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#PSDPosterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDPosterior" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> distribution for power spectra.
Uses an exponential distribution for the errors in the likelihood,
or a <span class="math notranslate nohighlight">\(\chi^2\)</span> distribution with <span class="math notranslate nohighlight">\(2M\)</span> degrees of freedom, where
<span class="math notranslate nohighlight">\(M\)</span> is the number of frequency bins or power spectra averaged in each bin.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ps</strong><span class="classifier">{<a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Powerspectrum</span></code></a> | <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.AveragedPowerspectrum</span></code></a>} instance</span></dt><dd><p>the <a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Powerspectrum</span></code></a> object containing the data</p>
</dd>
<dt><strong>model</strong><span class="classifier">instance of any subclass of <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code></span></dt><dd><p>The model for the power spectrum.</p>
</dd>
<dt><strong>priors</strong><span class="classifier">dict of form <code class="docutils literal notranslate"><span class="pre">{&quot;parameter</span> <span class="pre">name&quot;:</span> <span class="pre">function}</span></code>, optional</span></dt><dd><p>A dictionary with the definitions for the prior probabilities.
For each parameter in <code class="docutils literal notranslate"><span class="pre">model</span></code>, there must be a prior defined with
a key of the exact same name as stored in <code class="docutils literal notranslate"><span class="pre">model.param_names</span></code>.
The item for each key is a function definition defining the prior
(e.g. a lambda function or a <code class="docutils literal notranslate"><span class="pre">scipy.stats.distribution.pdf</span></code>.
If <code class="docutils literal notranslate"><span class="pre">priors</span> <span class="pre">=</span> <span class="pre">None</span></code>, then no prior is set. This means priors need
to be added by hand using the <a class="reference internal" href="#stingray.modeling.set_logprior" title="stingray.modeling.set_logprior"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_logprior()</span></code></a> function defined in
this module. Note that it is impossible to call a <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object
itself or the <code class="docutils literal notranslate"><span class="pre">self.logposterior</span></code> method without defining a prior.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int, default <code class="docutils literal notranslate"><span class="pre">1</span></code></span></dt><dd><p>The number of averaged periodograms or frequency bins in <code class="docutils literal notranslate"><span class="pre">ps</span></code>.
Useful for binned/averaged periodograms, since the value of
m will change the likelihood function!</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>ps</strong><span class="classifier">{<a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Powerspectrum</span></code></a> | <a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.AveragedPowerspectrum</span></code></a>} instance</span></dt><dd><p>the <a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.Powerspectrum</span></code></a> object containing the data</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The independent variable (list of frequencies) stored in <code class="docutils literal notranslate"><span class="pre">ps.freq</span></code></p>
</dd>
<dt><strong>y</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The dependent variable (list of powers) stored in <code class="docutils literal notranslate"><span class="pre">ps.power</span></code></p>
</dd>
<dt><strong>model</strong><span class="classifier">instance of any subclass of <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code></span></dt><dd><p>The model for the power spectrum.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDPosterior.logposterior">
<span class="sig-name descname"><span class="pre">logposterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.modeling.PSDPosterior.logposterior" title="Link to this definition">¶</a></dt>
<dd><p>Definition of the log-posterior.
Requires methods <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> and <code class="docutils literal notranslate"><span class="pre">logprior</span></code> to both
be defined.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> is set in the subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a>
appropriate for your problem at hand, as is <code class="docutils literal notranslate"><span class="pre">logprior</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>t0</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of parameters at which to evaluate the model
and subsequently the log-posterior. Note that the
length of this array must match the free parameters in
<code class="docutils literal notranslate"><span class="pre">model</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">npar</span></code></p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the <em>negative</em> log-posterior, i.e.
<code class="docutils literal notranslate"><span class="pre">-lpost</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">lpost</span></code>. This is useful e.g.
for optimization routines, which generally minimize
functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lpost</strong><span class="classifier">float</span></dt><dd><p>The value of the log-posterior for the given parameters <code class="docutils literal notranslate"><span class="pre">t0</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.LaplacePosterior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">LaplacePosterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yerr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#LaplacePosterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.LaplacePosterior" title="Link to this definition">¶</a></dt>
<dd><p>A general class for two-dimensional data following a Gaussian
sampling distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>independent variable</p>
</dd>
<dt><strong>y</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>dependent variable</p>
</dd>
<dt><strong>yerr</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>measurement uncertainties for y, in standard deviation</p>
</dd>
<dt><strong>model</strong><span class="classifier">instance of any subclass of <code class="docutils literal notranslate"><span class="pre">astropy.modeling.FittableModel</span></code></span></dt><dd><p>The model for the power spectrum.</p>
</dd>
<dt><strong>priors</strong><span class="classifier">dict of form <code class="docutils literal notranslate"><span class="pre">{&quot;parameter</span> <span class="pre">name&quot;:</span> <span class="pre">function}</span></code>, optional</span></dt><dd><p>A dictionary with the definitions for the prior probabilities.
For each parameter in <code class="docutils literal notranslate"><span class="pre">model</span></code>, there must be a prior defined with
a key of the exact same name as stored in <code class="docutils literal notranslate"><span class="pre">model.param_names</span></code>.
The item for each key is a function definition defining the prior
(e.g. a lambda function or a <code class="docutils literal notranslate"><span class="pre">scipy.stats.distribution.pdf</span></code>.
If <code class="docutils literal notranslate"><span class="pre">priors</span> <span class="pre">=</span> <span class="pre">None</span></code>, then no prior is set. This means priors need
to be added by hand using the <a class="reference internal" href="#stingray.modeling.set_logprior" title="stingray.modeling.set_logprior"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_logprior()</span></code></a> function defined in
this module. Note that it is impossible to call a <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object
itself or the <code class="docutils literal notranslate"><span class="pre">self.logposterior</span></code> method without defining a prior.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.LaplacePosterior.logposterior">
<span class="sig-name descname"><span class="pre">logposterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.modeling.LaplacePosterior.logposterior" title="Link to this definition">¶</a></dt>
<dd><p>Definition of the log-posterior.
Requires methods <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> and <code class="docutils literal notranslate"><span class="pre">logprior</span></code> to both
be defined.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> is set in the subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a>
appropriate for your problem at hand, as is <code class="docutils literal notranslate"><span class="pre">logprior</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>t0</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of parameters at which to evaluate the model
and subsequently the log-posterior. Note that the
length of this array must match the free parameters in
<code class="docutils literal notranslate"><span class="pre">model</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">npar</span></code></p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the <em>negative</em> log-posterior, i.e.
<code class="docutils literal notranslate"><span class="pre">-lpost</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">lpost</span></code>. This is useful e.g.
for optimization routines, which generally minimize
functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lpost</strong><span class="classifier">float</span></dt><dd><p>The value of the log-posterior for the given parameters <code class="docutils literal notranslate"><span class="pre">t0</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="parameter-estimation-classes">
<h3>Parameter Estimation Classes<a class="headerlink" href="#parameter-estimation-classes" title="Link to this heading">¶</a></h3>
<p>These classes implement functionality related to parameter estimation. They define basic <code class="docutils literal notranslate"><span class="pre">fit</span></code> and
<code class="docutils literal notranslate"><span class="pre">sample</span></code> methods using <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> and <code class="docutils literal notranslate"><span class="pre">emcee</span></code>, respectively, for optimization and Markov Chain Monte
Carlo sampling. <a class="reference internal" href="#stingray.modeling.PSDParEst" title="stingray.modeling.PSDParEst"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.PSDParEst</span></code></a> implements some more advanced functionality for modelling
power spectra, including both frequentist and Bayesian searches for (quasi-)periodic signals.</p>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.ParameterEstimation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">ParameterEstimation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fitmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BFGS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#ParameterEstimation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.ParameterEstimation" title="Link to this definition">¶</a></dt>
<dd><p>Parameter estimation of two-dimensional data, either via
optimization or MCMC.
Note: optimization with bounds is not supported. If something like
this is required, define (uniform) priors in the ParametricModel
instances to be used below.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fitmethod</strong><span class="classifier">string, optional, default <code class="docutils literal notranslate"><span class="pre">L-BFGS-B</span></code></span></dt><dd><p>Any of the strings allowed in <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> in
the method keyword. Sets the fit method to be used.</p>
</dd>
<dt><strong>max_post</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then compute the Maximum-A-Posteriori estimate. If <code class="docutils literal notranslate"><span class="pre">False</span></code>,
compute a Maximum Likelihood estimate.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.ParameterEstimation.calibrate_lrt">
<span class="sig-name descname"><span class="pre">calibrate_lrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpost2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namestr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#ParameterEstimation.calibrate_lrt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.ParameterEstimation.calibrate_lrt" title="Link to this definition">¶</a></dt>
<dd><p>Calibrate the outcome of a Likelihood Ratio Test via MCMC.</p>
<p>In order to compare models via likelihood ratio test, one generally
aims to compute a p-value for the null hypothesis (generally the
simpler model). There are two special cases where the theoretical
distribution used to compute that p-value analytically given the
observed likelihood ratio (a chi-square distribution) is not
applicable:</p>
<ul class="simple">
<li><p>the models are not nested (i.e. Model 1 is not a special, simpler
case of Model 2),</p></li>
<li><p>the parameter values fixed in Model 2 to retrieve Model 1 are at the
edges of parameter space (e.g. if one must set, say, an amplitude to
zero in order to remove a component in the more complex model, and
negative amplitudes are excluded a priori)</p></li>
</ul>
<p>In these cases, the observed likelihood ratio must be calibrated via
simulations of the simpler model (Model 1), using MCMC to take into
account the uncertainty in the parameters. This function does
exactly that: it computes the likelihood ratio for the observed data,
and produces simulations to calibrate the likelihood ratio and
compute a p-value for observing the data under the assumption that
Model 1 istrue.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">max_post=True</span></code>, the code will use MCMC to sample the posterior
of the parameters and simulate fake data from there.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">max_post=False</span></code>, the code will use the covariance matrix derived
from the fit to simulate data sets for comparison.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost1</strong><span class="classifier">object of a subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object for model 1</p>
</dd>
<dt><strong>t1</strong><span class="classifier">iterable</span></dt><dd><p>The starting parameters for model 1</p>
</dd>
<dt><strong>lpost2</strong><span class="classifier">object of a subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object for model 2</p>
</dd>
<dt><strong>t2</strong><span class="classifier">iterable</span></dt><dd><p>The starting parameters for model 2</p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>Boolean flag to decide whether to use the negative
log-likelihood or log-posterior</p>
</dd>
<dt><strong>max_post: bool, optional, default ``False``</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, set the internal state to do the optimization with the
log-likelihood rather than the log-posterior.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pvalue</strong><span class="classifier">float [0,1]</span></dt><dd><p>p-value ‘n stuff</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.ParameterEstimation.compute_lrt">
<span class="sig-name descname"><span class="pre">compute_lrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpost2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#ParameterEstimation.compute_lrt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.ParameterEstimation.compute_lrt" title="Link to this definition">¶</a></dt>
<dd><p>This function computes the Likelihood Ratio Test between two
nested models.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost1</strong><span class="classifier">object of a subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object for model 1</p>
</dd>
<dt><strong>t1</strong><span class="classifier">iterable</span></dt><dd><p>The starting parameters for model 1</p>
</dd>
<dt><strong>lpost2</strong><span class="classifier">object of a subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object for model 2</p>
</dd>
<dt><strong>t2</strong><span class="classifier">iterable</span></dt><dd><p>The starting parameters for model 2</p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>Boolean flag to decide whether to use the negative log-likelihood
or log-posterior</p>
</dd>
<dt><strong>max_post: bool, optional, default ``False``</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, set the internal state to do the optimization with the
log-likelihood rather than the log-posterior.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lrt</strong><span class="classifier">float</span></dt><dd><p>The likelihood ratio for model 2 and model 1</p>
</dd>
<dt><strong>res1</strong><span class="classifier">OptimizationResults object</span></dt><dd><p>Contains the result of fitting <code class="docutils literal notranslate"><span class="pre">lpost1</span></code></p>
</dd>
<dt><strong>res2</strong><span class="classifier">OptimizationResults object</span></dt><dd><p>Contains the results of fitting <code class="docutils literal notranslate"><span class="pre">lpost2</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.ParameterEstimation.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scipy_optimize_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#ParameterEstimation.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.ParameterEstimation.fit" title="Link to this definition">¶</a></dt>
<dd><p>Do either a Maximum-A-Posteriori (MAP) or Maximum Likelihood (ML)
fit to the data.</p>
<p>MAP fits include priors, ML fits do not.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> (or subclass) instance</span></dt><dd><p>and instance of class <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> or one of its subclasses
that defines the function to be minimized (either in <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>
or <code class="docutils literal notranslate"><span class="pre">logposterior</span></code>)</p>
</dd>
<dt><strong>t0</strong><span class="classifier">{<code class="docutils literal notranslate"><span class="pre">list</span></code> | <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>}</span></dt><dd><p>List/array with set of initial parameters</p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>Boolean to be passed to <code class="docutils literal notranslate"><span class="pre">lpost</span></code>, setting whether to use the
<em>negative</em> posterior or the <em>negative</em> log-likelihood. Useful for
optimization routines, which are generally defined as <em>minimization</em> routines.</p>
</dd>
<dt><strong>scipy_optimize_options</strong><span class="classifier">dict, optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A dictionary with options for <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code>,
directly passed on as keyword arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.OptimizationResults" title="stingray.modeling.OptimizationResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizationResults</span></code></a> object</span></dt><dd><p>An object containing useful summaries of the fitting procedure.
For details, see documentation of class:<a class="reference internal" href="#stingray.modeling.OptimizationResults" title="stingray.modeling.OptimizationResults"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OptimizationResults</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.ParameterEstimation.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namestr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#ParameterEstimation.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.ParameterEstimation.sample" title="Link to this definition">¶</a></dt>
<dd><p>Sample the <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> distribution defined in <code class="docutils literal notranslate"><span class="pre">lpost</span></code> using MCMC.
Here we use the <code class="docutils literal notranslate"><span class="pre">emcee</span></code> package, but other implementations could
in principle be used.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost</strong><span class="classifier">instance of a <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> subclass</span></dt><dd><p>and instance of class <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> or one of its subclasses
that defines the function to be minimized (either in <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>
or <code class="docutils literal notranslate"><span class="pre">logposterior</span></code>)</p>
</dd>
<dt><strong>t0</strong><span class="classifier">iterable</span></dt><dd><p>list or array containing the starting parameters. Its length
must match <code class="docutils literal notranslate"><span class="pre">lpost.model.npar</span></code>.</p>
</dd>
<dt><strong>nwalkers</strong><span class="classifier">int, optional, default 500</span></dt><dd><p>The number of walkers (chains) to use during the MCMC procedure.
The more walkers are used, the slower the estimation will be, but
the better the final distribution is likely to be.</p>
</dd>
<dt><strong>niter</strong><span class="classifier">int, optional, default 100</span></dt><dd><p>The number of iterations to run the MCMC chains for. The larger this
number, the longer the estimation will take, but the higher the
chance that the walkers have actually converged on the true
posterior distribution.</p>
</dd>
<dt><strong>burnin</strong><span class="classifier">int, optional, default 100</span></dt><dd><p>The number of iterations to run the walkers before convergence is
assumed to have occurred. This part of the chain will be discarded
before sampling from what is then assumed to be the posterior
distribution desired.</p>
</dd>
<dt><strong>threads</strong><span class="classifier"><strong>DEPRECATED</strong> int, optional, default 1</span></dt><dd><p>The number of threads for parallelization.
Default is <code class="docutils literal notranslate"><span class="pre">1</span></code>, i.e. no parallelization
With the change to the new emcee version 3, threads is
deprecated. Use the <code class="xref py py-obj docutils literal notranslate"><span class="pre">pool</span></code> keyword argument instead.
This will no longer have any effect.</p>
</dd>
<dt><strong>print_results</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>Boolean flag setting whether the results of the MCMC run should
be printed to standard output. Default: True</p>
</dd>
<dt><strong>plot</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>Boolean flag setting whether summary plots of the MCMC chains
should be produced. Default: False</p>
</dd>
<dt><strong>namestr</strong><span class="classifier">str, optional, default <code class="docutils literal notranslate"><span class="pre">test</span></code></span></dt><dd><p>Optional string for output file names for the plotting.</p>
</dd>
<dt><strong>pool</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, use pooling to parallelize the operation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier">class:<a class="reference internal" href="#stingray.modeling.SamplingResults" title="stingray.modeling.SamplingResults"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SamplingResults</span></code></a> object</span></dt><dd><p>An object of class <a class="reference internal" href="#stingray.modeling.SamplingResults" title="stingray.modeling.SamplingResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">SamplingResults</span></code></a> summarizing the
results of the MCMC run.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.ParameterEstimation.simulate_lrts">
<span class="sig-name descname"><span class="pre">simulate_lrts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s_all</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpost1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpost2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#ParameterEstimation.simulate_lrts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.ParameterEstimation.simulate_lrts" title="Link to this definition">¶</a></dt>
<dd><p>Simulate likelihood ratios.
For details, see definitions in the subclasses that implement this
task.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.PSDParEst">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">PSDParEst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BFGS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#PSDParEst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDParEst" title="Link to this definition">¶</a></dt>
<dd><p>Parameter estimation for parametric modelling of power spectra.</p>
<p>This class contains functionality that allows parameter estimation
and related tasks that involve fitting a parametric model to an
(averaged) power spectrum.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ps</strong><span class="classifier">class:<a class="reference internal" href="#stingray.Powerspectrum" title="stingray.Powerspectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.Powerspectrum</span></code></a> or class:<a class="reference internal" href="#stingray.AveragedPowerspectrum" title="stingray.AveragedPowerspectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stingray.AveragedPowerspectrum</span></code></a> object</span></dt><dd><p>The power spectrum to be modelled</p>
</dd>
<dt><strong>fitmethod</strong><span class="classifier">str, optional, default <code class="docutils literal notranslate"><span class="pre">BFGS</span></code></span></dt><dd><p>A string allowed by <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> as a valid
fitting method</p>
</dd>
<dt><strong>max_post</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, do a Maximum-A-Posteriori (MAP) fit, i.e. fit with
priors, otherwise do a Maximum Likelihood fit instead</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDParEst.calibrate_highest_outlier">
<span class="sig-name descname"><span class="pre">calibrate_highest_outlier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namestr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#PSDParEst.calibrate_highest_outlier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDParEst.calibrate_highest_outlier" title="Link to this definition">¶</a></dt>
<dd><p>Calibrate the highest outlier in a data set using MCMC-simulated
power spectra.</p>
<p>In short, the procedure does a MAP fit to the data, computes the
statistic</p>
<div class="math notranslate nohighlight">
\[\max{(T_R = 2(\mathrm{data}/\mathrm{model}))}\]</div>
<p>and then does an MCMC run using the data and the model, or generates parameter samples
from the likelihood distribution using the derived covariance in a Maximum Likelihood
fit.
From the (posterior) samples, it generates fake power spectra. Each fake spectrum is fit
in the same way as the data, and the highest data/model outlier extracted as for the data.
The observed value of <span class="math notranslate nohighlight">\(T_R\)</span> can then be directly compared to the simulated
distribution of <span class="math notranslate nohighlight">\(T_R\)</span> values in order to derive a p-value of the null
hypothesis that the observed <span class="math notranslate nohighlight">\(T_R\)</span> is compatible with being generated by
noise.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.PSDPosterior" title="stingray.modeling.PSDPosterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.PSDPosterior</span></code></a> object</span></dt><dd><p>An instance of class <a class="reference internal" href="#stingray.modeling.PSDPosterior" title="stingray.modeling.PSDPosterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.PSDPosterior</span></code></a> that defines the
function to be minimized (either in <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> or <code class="docutils literal notranslate"><span class="pre">logposterior</span></code>)</p>
</dd>
<dt><strong>t0</strong><span class="classifier">{list | numpy.ndarray}</span></dt><dd><p>List/array with set of initial parameters</p>
</dd>
<dt><strong>sample</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.SamplingResults" title="stingray.modeling.SamplingResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">SamplingResults</span></code></a> instance, optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>If a sampler has already been run, the <a class="reference internal" href="#stingray.modeling.SamplingResults" title="stingray.modeling.SamplingResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">SamplingResults</span></code></a> instance can be
fed into this method here, otherwise this method will run a sampler
automatically</p>
</dd>
<dt><strong>max_post: bool, optional, default ``False``</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, do MAP fits on the power spectrum to find the highest data/model outlier
Otherwise, do a Maximum Likelihood fit. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the simulated power spectra will
be generated from an MCMC run, otherwise the method will employ the approximated
covariance matrix for the parameters derived from the likelihood surface to generate
samples from that likelihood function.</p>
</dd>
<dt><strong>nsim</strong><span class="classifier">int, optional, default <code class="docutils literal notranslate"><span class="pre">1000</span></code></span></dt><dd><p>Number of fake power spectra to simulate from the posterior sample. Note that this
number sets the resolution of the resulting p-value. For <code class="docutils literal notranslate"><span class="pre">nsim=1000</span></code>, the highest
resolution that can be achieved is <span class="math notranslate nohighlight">\(10^{-3}\)</span>.</p>
</dd>
<dt><strong>niter</strong><span class="classifier">int, optional, default 200</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">sample</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, this variable will be used to set the number of steps in the
MCMC procedure <em>after</em> burn-in.</p>
</dd>
<dt><strong>nwalkers</strong><span class="classifier">int, optional, default 500</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">sample</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, this variable will be used to set the number of MCMC chains
run in parallel in the sampler.</p>
</dd>
<dt><strong>burnin</strong><span class="classifier">int, optional, default 200</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">sample</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, this variable will be used to set the number of burn-in steps
to be discarded in the initial phase of the MCMC run</p>
</dd>
<dt><strong>namestr</strong><span class="classifier">str, optional, default <code class="docutils literal notranslate"><span class="pre">test</span></code></span></dt><dd><p>A string to be used for storing MCMC output and plots to disk</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>An optional number to seed the random number generator with, for reproducibility of
the results obtained with this method.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pval</strong><span class="classifier">float</span></dt><dd><p>The p-value that the highest data/model outlier is produced by random noise, calibrated
using simulated power spectra from an MCMC run.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>For more details on the procedure employed here, see</p>
<blockquote>
<div><ul class="simple">
<li><p>Vaughan, 2010: <a class="reference external" href="https://arxiv.org/abs/0910.2706">https://arxiv.org/abs/0910.2706</a></p></li>
<li><p>Huppenkothen et al, 2013: <a class="reference external" href="https://arxiv.org/abs/1212.1011">https://arxiv.org/abs/1212.1011</a></p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDParEst.calibrate_lrt">
<span class="sig-name descname"><span class="pre">calibrate_lrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpost2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namestr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.modeling.PSDParEst.calibrate_lrt" title="Link to this definition">¶</a></dt>
<dd><p>Calibrate the outcome of a Likelihood Ratio Test via MCMC.</p>
<p>In order to compare models via likelihood ratio test, one generally
aims to compute a p-value for the null hypothesis (generally the
simpler model). There are two special cases where the theoretical
distribution used to compute that p-value analytically given the
observed likelihood ratio (a chi-square distribution) is not
applicable:</p>
<ul class="simple">
<li><p>the models are not nested (i.e. Model 1 is not a special, simpler
case of Model 2),</p></li>
<li><p>the parameter values fixed in Model 2 to retrieve Model 1 are at the
edges of parameter space (e.g. if one must set, say, an amplitude to
zero in order to remove a component in the more complex model, and
negative amplitudes are excluded a priori)</p></li>
</ul>
<p>In these cases, the observed likelihood ratio must be calibrated via
simulations of the simpler model (Model 1), using MCMC to take into
account the uncertainty in the parameters. This function does
exactly that: it computes the likelihood ratio for the observed data,
and produces simulations to calibrate the likelihood ratio and
compute a p-value for observing the data under the assumption that
Model 1 istrue.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">max_post=True</span></code>, the code will use MCMC to sample the posterior
of the parameters and simulate fake data from there.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">max_post=False</span></code>, the code will use the covariance matrix derived
from the fit to simulate data sets for comparison.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost1</strong><span class="classifier">object of a subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object for model 1</p>
</dd>
<dt><strong>t1</strong><span class="classifier">iterable</span></dt><dd><p>The starting parameters for model 1</p>
</dd>
<dt><strong>lpost2</strong><span class="classifier">object of a subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object for model 2</p>
</dd>
<dt><strong>t2</strong><span class="classifier">iterable</span></dt><dd><p>The starting parameters for model 2</p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>Boolean flag to decide whether to use the negative
log-likelihood or log-posterior</p>
</dd>
<dt><strong>max_post: bool, optional, default ``False``</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, set the internal state to do the optimization with the
log-likelihood rather than the log-posterior.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pvalue</strong><span class="classifier">float [0,1]</span></dt><dd><p>p-value ‘n stuff</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDParEst.compute_lrt">
<span class="sig-name descname"><span class="pre">compute_lrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpost2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.modeling.PSDParEst.compute_lrt" title="Link to this definition">¶</a></dt>
<dd><p>This function computes the Likelihood Ratio Test between two
nested models.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost1</strong><span class="classifier">object of a subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object for model 1</p>
</dd>
<dt><strong>t1</strong><span class="classifier">iterable</span></dt><dd><p>The starting parameters for model 1</p>
</dd>
<dt><strong>lpost2</strong><span class="classifier">object of a subclass of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object for model 2</p>
</dd>
<dt><strong>t2</strong><span class="classifier">iterable</span></dt><dd><p>The starting parameters for model 2</p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>Boolean flag to decide whether to use the negative log-likelihood
or log-posterior</p>
</dd>
<dt><strong>max_post: bool, optional, default ``False``</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, set the internal state to do the optimization with the
log-likelihood rather than the log-posterior.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lrt</strong><span class="classifier">float</span></dt><dd><p>The likelihood ratio for model 2 and model 1</p>
</dd>
<dt><strong>res1</strong><span class="classifier">OptimizationResults object</span></dt><dd><p>Contains the result of fitting <code class="docutils literal notranslate"><span class="pre">lpost1</span></code></p>
</dd>
<dt><strong>res2</strong><span class="classifier">OptimizationResults object</span></dt><dd><p>Contains the results of fitting <code class="docutils literal notranslate"><span class="pre">lpost2</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDParEst.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scipy_optimize_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#PSDParEst.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDParEst.fit" title="Link to this definition">¶</a></dt>
<dd><p>Do either a Maximum-A-Posteriori (MAP) or Maximum Likelihood (ML)
fit to the power spectrum.</p>
<p>MAP fits include priors, ML fits do not.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.PSDPosterior" title="stingray.modeling.PSDPosterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.PSDPosterior</span></code></a> object</span></dt><dd><p>An instance of class <a class="reference internal" href="#stingray.modeling.PSDPosterior" title="stingray.modeling.PSDPosterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.PSDPosterior</span></code></a> that defines the
function to be minimized (either in <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code> or <code class="docutils literal notranslate"><span class="pre">logposterior</span></code>)</p>
</dd>
<dt><strong>t0</strong><span class="classifier">{list | numpy.ndarray}</span></dt><dd><p>List/array with set of initial parameters</p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>Boolean to be passed to <code class="docutils literal notranslate"><span class="pre">lpost</span></code>, setting whether to use the
<em>negative</em> posterior or the <em>negative</em> log-likelihood.</p>
</dd>
<dt><strong>scipy_optimize_options</strong><span class="classifier">dict, optional, default None</span></dt><dd><p>A dictionary with options for <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code>,
directly passed on as keyword arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.OptimizationResults" title="stingray.modeling.OptimizationResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizationResults</span></code></a> object</span></dt><dd><p>An object containing useful summaries of the fitting procedure.
For details, see documentation of <a class="reference internal" href="#stingray.modeling.OptimizationResults" title="stingray.modeling.OptimizationResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizationResults</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDParEst.plotfits">
<span class="sig-name descname"><span class="pre">plotfits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">res1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namestr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#PSDParEst.plotfits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDParEst.plotfits" title="Link to this definition">¶</a></dt>
<dd><p>Plotting method that allows to plot either one or two best-fit models
with the data.</p>
<p>Plots a power spectrum with the best-fit model, as well as the data/model
residuals for each model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>res1</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.OptimizationResults" title="stingray.modeling.OptimizationResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizationResults</span></code></a> object</span></dt><dd><p>Output of a successful fitting procedure</p>
</dd>
<dt><strong>res2</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.OptimizationResults" title="stingray.modeling.OptimizationResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizationResults</span></code></a> object, optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Optional output of a second successful fitting procedure, e.g. with a
competing model</p>
</dd>
<dt><strong>save_plot</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the resulting figure will be saved to a file</p>
</dd>
<dt><strong>namestr</strong><span class="classifier">str, optional, default <code class="docutils literal notranslate"><span class="pre">test</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">save_plot</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this string defines the path and file name
for the output plot</p>
</dd>
<dt><strong>log</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, plot the axes logarithmically.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDParEst.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namestr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#PSDParEst.sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDParEst.sample" title="Link to this definition">¶</a></dt>
<dd><p>Sample the posterior distribution defined in <code class="docutils literal notranslate"><span class="pre">lpost</span></code> using MCMC.
Here we use the <code class="docutils literal notranslate"><span class="pre">emcee</span></code> package, but other implementations could
in principle be used.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost</strong><span class="classifier">instance of a <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> subclass</span></dt><dd><p>and instance of class <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> or one of its subclasses
that defines the function to be minimized (either in <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>
or <code class="docutils literal notranslate"><span class="pre">logposterior</span></code>)</p>
</dd>
<dt><strong>t0</strong><span class="classifier">iterable</span></dt><dd><p>list or array containing the starting parameters. Its length
must match <code class="docutils literal notranslate"><span class="pre">lpost.model.npar</span></code>.</p>
</dd>
<dt><strong>nwalkers</strong><span class="classifier">int, optional, default 500</span></dt><dd><p>The number of walkers (chains) to use during the MCMC procedure.
The more walkers are used, the slower the estimation will be, but
the better the final distribution is likely to be.</p>
</dd>
<dt><strong>niter</strong><span class="classifier">int, optional, default 100</span></dt><dd><p>The number of iterations to run the MCMC chains for. The larger this
number, the longer the estimation will take, but the higher the
chance that the walkers have actually converged on the true
posterior distribution.</p>
</dd>
<dt><strong>burnin</strong><span class="classifier">int, optional, default 100</span></dt><dd><p>The number of iterations to run the walkers before convergence is
assumed to have occurred. This part of the chain will be discarded
before sampling from what is then assumed to be the posterior
distribution desired.</p>
</dd>
<dt><strong>threads</strong><span class="classifier">int, optional, default 1</span></dt><dd><p>The number of threads for parallelization.
Default is <code class="docutils literal notranslate"><span class="pre">1</span></code>, i.e. no parallelization</p>
</dd>
<dt><strong>print_results</strong><span class="classifier">bool, optional, default True</span></dt><dd><p>Boolean flag setting whether the results of the MCMC run should
be printed to standard output</p>
</dd>
<dt><strong>plot</strong><span class="classifier">bool, optional, default False</span></dt><dd><p>Boolean flag setting whether summary plots of the MCMC chains
should be produced</p>
</dd>
<dt><strong>namestr</strong><span class="classifier">str, optional, default <code class="docutils literal notranslate"><span class="pre">test</span></code></span></dt><dd><p>Optional string for output file names for the plotting.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.SamplingResults" title="stingray.modeling.SamplingResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">SamplingResults</span></code></a> object</span></dt><dd><p>An object containing useful summaries of the
sampling procedure. For details see documentation of <a class="reference internal" href="#stingray.modeling.SamplingResults" title="stingray.modeling.SamplingResults"><code class="xref py py-class docutils literal notranslate"><span class="pre">SamplingResults</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDParEst.simulate_highest_outlier">
<span class="sig-name descname"><span class="pre">simulate_highest_outlier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s_all</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#PSDParEst.simulate_highest_outlier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDParEst.simulate_highest_outlier" title="Link to this definition">¶</a></dt>
<dd><p>Simulate <span class="math notranslate nohighlight">\(n\)</span> power spectra from a model and then find the highest
data/model outlier in each.</p>
<p>The data/model outlier is defined as</p>
<div class="math notranslate nohighlight">
\[\max{(T_R = 2(\mathrm{data}/\mathrm{model}))} .\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>s_all</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>A list of parameter values derived either from an approximation of the
likelihood surface, or from an MCMC run. Has dimensions <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">ndim)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of simulated power spectra to generate, and <code class="docutils literal notranslate"><span class="pre">ndim</span></code> the
number of model parameters.</p>
</dd>
<dt><strong>lpost</strong><span class="classifier">instance of a <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> subclass</span></dt><dd><p>an instance of class <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> or one of its subclasses
that defines the function to be minimized (either in <code class="docutils literal notranslate"><span class="pre">loglikelihood</span></code>
or <code class="docutils literal notranslate"><span class="pre">logposterior</span></code>)</p>
</dd>
<dt><strong>t0</strong><span class="classifier">iterable</span></dt><dd><p>list or array containing the starting parameters. Its length
must match <code class="docutils literal notranslate"><span class="pre">lpost.model.npar</span></code>.</p>
</dd>
<dt><strong>max_post: bool, optional, default ``False``</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, do MAP fits on the power spectrum to find the highest data/model outlier
Otherwise, do a Maximum Likelihood fit. If True, the simulated power spectra will
be generated from an MCMC run, otherwise the method will employ the approximated
covariance matrix for the parameters derived from the likelihood surface to generate
samples from that likelihood function.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>An optional number to seed the random number generator with, for reproducibility of
the results obtained with this method.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_y_all</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of maximum outliers for each simulated power spectrum</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.PSDParEst.simulate_lrts">
<span class="sig-name descname"><span class="pre">simulate_lrts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s_all</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpost1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpost2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#PSDParEst.simulate_lrts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.PSDParEst.simulate_lrts" title="Link to this definition">¶</a></dt>
<dd><p>Simulate likelihood ratios for two given models based on MCMC samples
for the simpler model (i.e. the null hypothesis).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>s_all</strong><span class="classifier">numpy.ndarray of shape <code class="docutils literal notranslate"><span class="pre">(nsamples,</span> <span class="pre">lpost1.npar)</span></code></span></dt><dd><p>An array with MCMC samples derived from the null hypothesis model in
<code class="docutils literal notranslate"><span class="pre">lpost1</span></code>. Its second dimension must match the number of free
parameters in <code class="docutils literal notranslate"><span class="pre">lpost1.model</span></code>.</p>
</dd>
<dt><strong>lpost1</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.LogLikelihood" title="stingray.modeling.LogLikelihood"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogLikelihood</span></code></a> or <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> subclass object</span></dt><dd><p>Object containing the null hypothesis model</p>
</dd>
<dt><strong>t1</strong><span class="classifier">iterable of length <code class="docutils literal notranslate"><span class="pre">lpost1.npar</span></code></span></dt><dd><p>A starting guess for fitting the model in <code class="docutils literal notranslate"><span class="pre">lpost1</span></code></p>
</dd>
<dt><strong>lpost2</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.LogLikelihood" title="stingray.modeling.LogLikelihood"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogLikelihood</span></code></a> or <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> subclass object</span></dt><dd><p>Object containing the alternative hypothesis model</p>
</dd>
<dt><strong>t2</strong><span class="classifier">iterable of length <code class="docutils literal notranslate"><span class="pre">lpost2.npar</span></code></span></dt><dd><p>A starting guess for fitting the model in <code class="docutils literal notranslate"><span class="pre">lpost2</span></code></p>
</dd>
<dt><strong>max_post</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then <code class="docutils literal notranslate"><span class="pre">lpost1</span></code> and <code class="docutils literal notranslate"><span class="pre">lpost2</span></code> should be <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> subclass
objects; if <code class="docutils literal notranslate"><span class="pre">False</span></code>, then <code class="docutils literal notranslate"><span class="pre">lpost1</span></code> and <code class="docutils literal notranslate"><span class="pre">lpost2</span></code> should be
<a class="reference internal" href="#stingray.modeling.LogLikelihood" title="stingray.modeling.LogLikelihood"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogLikelihood</span></code></a> subclass objects</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>A seed to initialize the <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object to be
passed on to <code class="docutils literal notranslate"><span class="pre">_generate_data</span></code>. Useful for producing exactly
reproducible results</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lrt_sim</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array with the simulated likelihood ratios for the simulated
data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="auxiliary-classes">
<h3>Auxiliary Classes<a class="headerlink" href="#auxiliary-classes" title="Link to this heading">¶</a></h3>
<p>These are helper classes instantiated by <a class="reference internal" href="#stingray.modeling.ParameterEstimation" title="stingray.modeling.ParameterEstimation"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.ParameterEstimation</span></code></a> and its subclasses to
organize the results of model fitting and sampling in a more meaningful, easily accessible way.</p>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.OptimizationResults">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">OptimizationResults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#OptimizationResults"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.OptimizationResults" title="Link to this definition">¶</a></dt>
<dd><p>Helper class that will contain the results of the regression.
Less fiddly than a dictionary.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost: instance of :class:`Posterior` or one of its subclasses</strong></dt><dd><p>The object containing the function that is being optimized
in the regression</p>
</dd>
<dt><strong>res: instance of ``scipy.OptimizeResult``</strong></dt><dd><p>The object containing the results from a optimization run</p>
</dd>
<dt><strong>neg</strong><span class="classifier">bool, optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt><dd><p>A flag that sets whether the log-likelihood or negative log-likelihood
is being used</p>
</dd>
<dt><strong>log</strong><span class="classifier">a logging.getLogger() object, default None</span></dt><dd><p>You can pass a pre-defined object for logging, else a new
logger will be instantiated</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">float</span></dt><dd><p>The result of the optimization, i.e. the function value at the
minimum that the optimizer found</p>
</dd>
<dt><strong>p_opt</strong><span class="classifier">iterable</span></dt><dd><p>The list of parameters at the minimum found by the optimizer</p>
</dd>
<dt><strong>model</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">astropy.models.Model</span></code> instance</span></dt><dd><p>The parametric model fit to the data</p>
</dd>
<dt><strong>cov</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The covariance matrix for the parameters, has shape <code class="docutils literal notranslate"><span class="pre">(len(p_opt),</span> <span class="pre">len(p_opt))</span></code></p>
</dd>
<dt><strong>err</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The standard deviation of the parameters, derived from the diagonal of <code class="docutils literal notranslate"><span class="pre">cov</span></code>.
Has the same shape as <code class="docutils literal notranslate"><span class="pre">p_opt</span></code></p>
</dd>
<dt><strong>mfit</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The values of the model for all <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt><strong>deviance</strong><span class="classifier">float</span></dt><dd><p>The deviance, calculated as <code class="docutils literal notranslate"><span class="pre">-2*log(likelihood)</span></code></p>
</dd>
<dt><strong>aic</strong><span class="classifier">float</span></dt><dd><p>The Akaike Information Criterion, derived from the log(likelihood) and often used
in model comparison between non-nested models;
For more details, see <a class="footnote-reference brackets" href="#id22" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a></p>
</dd>
<dt><strong>bic</strong><span class="classifier">float</span></dt><dd><p>The Bayesian Information Criterion, derived from the log(likelihood) and often used
in model comparison between non-nested models;
For more details, see <a class="footnote-reference brackets" href="#id23" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a></p>
</dd>
<dt><strong>merit</strong><span class="classifier">float</span></dt><dd><p>sum of squared differences between data and model, normalized by the
model values</p>
</dd>
<dt><strong>dof</strong><span class="classifier">int</span></dt><dd><p>The number of degrees of freedom in the problem, defined as the number of
data points - the number of parameters</p>
</dd>
<dt><strong>sexp</strong><span class="classifier">int</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">2*(number</span> <span class="pre">of</span> <span class="pre">parameters)*(number</span> <span class="pre">of</span> <span class="pre">data</span> <span class="pre">points)</span></code></p>
</dd>
<dt><strong>ssd</strong><span class="classifier">float</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">sqrt(2*(sexp))</span></code>, expected sum of data-model residuals</p>
</dd>
<dt><strong>sobs</strong><span class="classifier">float</span></dt><dd><p>sum of data-model residuals</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://doi.org/10.1109/TAC.1974.1100705">https://doi.org/10.1109/TAC.1974.1100705</a></p>
</aside>
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">8</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://projecteuclid.org/euclid.aos/1176344136">https://projecteuclid.org/euclid.aos/1176344136</a></p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.OptimizationResults._compute_covariance">
<span class="sig-name descname"><span class="pre">_compute_covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#OptimizationResults._compute_covariance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.OptimizationResults._compute_covariance" title="Link to this definition">¶</a></dt>
<dd><p>Compute the covariance of the parameters using inverse of the Hessian, i.e.
the second-order derivative of the log-likelihood. Also calculates an estimate
of the standard deviation in the parameters, using the square root of the diagonal
of the covariance matrix.</p>
<p>The Hessian is either estimated directly by the chosen method of fitting, or
approximated using the <code class="docutils literal notranslate"><span class="pre">statsmodel</span></code> <code class="docutils literal notranslate"><span class="pre">approx_hess</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lpost: instance of :class:`Posterior` or one of its subclasses</strong></dt><dd><p>The object containing the function that is being optimized
in the regression</p>
</dd>
<dt><strong>res: instance of ``scipy``’s ``OptimizeResult`` class</strong></dt><dd><p>The object containing the results from a optimization run</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.OptimizationResults._compute_criteria">
<span class="sig-name descname"><span class="pre">_compute_criteria</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#OptimizationResults._compute_criteria"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.OptimizationResults._compute_criteria" title="Link to this definition">¶</a></dt>
<dd><p>Compute various information criteria useful for model comparison in
non-nested models.</p>
<p>Currently implemented are the Akaike Information Criterion <a class="footnote-reference brackets" href="#id26" id="id24" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> and the
Bayesian Information Criterion <a class="footnote-reference brackets" href="#id27" id="id25" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lpost: instance of :class:`Posterior` or one of its subclasses</strong></dt><dd><p>The object containing the function that is being optimized
in the regression</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id24">9</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://doi.org/10.1109/TAC.1974.1100705">https://doi.org/10.1109/TAC.1974.1100705</a></p>
</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id25">10</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://projecteuclid.org/euclid.aos/1176344136">https://projecteuclid.org/euclid.aos/1176344136</a></p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.OptimizationResults._compute_model">
<span class="sig-name descname"><span class="pre">_compute_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#OptimizationResults._compute_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.OptimizationResults._compute_model" title="Link to this definition">¶</a></dt>
<dd><p>Compute the values of the best-fit model for all <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lpost: instance of :class:`Posterior` or one of its subclasses</strong></dt><dd><p>The object containing the function that is being optimized
in the regression</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.OptimizationResults._compute_statistics">
<span class="sig-name descname"><span class="pre">_compute_statistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#OptimizationResults._compute_statistics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.OptimizationResults._compute_statistics" title="Link to this definition">¶</a></dt>
<dd><p>Compute some useful fit statistics, like the degrees of freedom and the
figure of merit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lpost: instance of :class:`Posterior` or one of its subclasses</strong></dt><dd><p>The object containing the function that is being optimized
in the regression</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.OptimizationResults.print_summary">
<span class="sig-name descname"><span class="pre">print_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#OptimizationResults.print_summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.OptimizationResults.print_summary" title="Link to this definition">¶</a></dt>
<dd><p>Print a useful summary of the fitting procedure to screen or
a log file.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost</strong><span class="classifier">instance of <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> or one of its subclasses</span></dt><dd><p>The object containing the function that is being optimized
in the regression</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="stingray.modeling.SamplingResults">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">SamplingResults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#SamplingResults"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.SamplingResults" title="Link to this definition">¶</a></dt>
<dd><p>Helper class that will contain the results of the sampling
in a handy format.</p>
<p>Less fiddly than a dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sampler: ``emcee.EnsembleSampler`` object</strong></dt><dd><p>The object containing the sampler that’s done all the work.</p>
</dd>
<dt><strong>ci_min: float out of [0,100]</strong></dt><dd><p>The lower bound percentile for printing credible intervals
on the parameters</p>
</dd>
<dt><strong>ci_max: float out of [0,100]</strong></dt><dd><p>The upper bound percentile for printing credible intervals
on the parameters</p>
</dd>
<dt><strong>log</strong><span class="classifier">a logging.getLogger() object, default None</span></dt><dd><p>You can pass a pre-defined object for logging, else a new
logger will be instantiated</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of samples from the MCMC run, including all chains
flattened into one long (<code class="docutils literal notranslate"><span class="pre">nwalkers*niter</span></code>, <code class="docutils literal notranslate"><span class="pre">ndim</span></code>) array</p>
</dd>
<dt><strong>nwalkers</strong><span class="classifier">int</span></dt><dd><p>The number of chains used in the MCMC procedure</p>
</dd>
<dt><strong>niter</strong><span class="classifier">int</span></dt><dd><p>The number of MCMC iterations in each chain</p>
</dd>
<dt><strong>ndim</strong><span class="classifier">int</span></dt><dd><p>The dimensionality of the problem, i.e. the number of
parameters in the model</p>
</dd>
<dt><strong>acceptance</strong><span class="classifier">float</span></dt><dd><p>The mean acceptance ratio, calculated over all chains</p>
</dd>
<dt><strong>L</strong><span class="classifier">float</span></dt><dd><p>The product of acceptance ratio and number of samples</p>
</dd>
<dt><strong>acor</strong><span class="classifier">float</span></dt><dd><p>The autocorrelation length for the chains; should be shorter
than the chains themselves for independent sampling</p>
</dd>
<dt><strong>rhat</strong><span class="classifier">float</span></dt><dd><p>weighted average of between-sequence variance and within-sequence
variance; Gelman-Rubin convergence statistic <a class="footnote-reference brackets" href="#id29" id="id28" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a></p>
</dd>
<dt><strong>mean</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size <code class="docutils literal notranslate"><span class="pre">ndim</span></code>, with the posterior means of the parameters
derived from the MCMC chains</p>
</dd>
<dt><strong>std</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of size <code class="docutils literal notranslate"><span class="pre">ndim</span></code> with the posterior standard deviations of
the parameters derived from the MCMC chains</p>
</dd>
<dt><strong>ci</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape <code class="docutils literal notranslate"><span class="pre">(ndim,</span> <span class="pre">2)</span></code> containing the lower and upper bounds
of the credible interval (the Bayesian equivalent of the confidence
interval) for each parameter using the bounds set by <code class="docutils literal notranslate"><span class="pre">ci_min</span></code> and <code class="docutils literal notranslate"><span class="pre">ci_max</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id28">11</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://projecteuclid.org/euclid.ss/1177011136">https://projecteuclid.org/euclid.ss/1177011136</a></p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.SamplingResults._check_convergence">
<span class="sig-name descname"><span class="pre">_check_convergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampler</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#SamplingResults._check_convergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.SamplingResults._check_convergence" title="Link to this definition">¶</a></dt>
<dd><p>Compute common statistics for convergence of the MCMC
chains. While you can never be completely sure that your chains
converged, these present reasonable heuristics to give an
indication whether convergence is very far off or reasonably close.</p>
<p>Currently implemented are the autocorrelation time <a class="footnote-reference brackets" href="#id32" id="id30" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a> and the
Gelman-Rubin convergence criterion <a class="footnote-reference brackets" href="#id33" id="id31" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>sampler</strong><span class="classifier">an <code class="docutils literal notranslate"><span class="pre">emcee.EnsembleSampler</span></code> object</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id32" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id30">12</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://arxiv.org/abs/1202.3665">https://arxiv.org/abs/1202.3665</a></p>
</aside>
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id31">13</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://projecteuclid.org/euclid.ss/1177011136">https://projecteuclid.org/euclid.ss/1177011136</a></p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.SamplingResults._compute_rhat">
<span class="sig-name descname"><span class="pre">_compute_rhat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampler</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#SamplingResults._compute_rhat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.SamplingResults._compute_rhat" title="Link to this definition">¶</a></dt>
<dd><p>Compute Gelman-Rubin convergence criterion <a class="footnote-reference brackets" href="#id35" id="id34" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>sampler</strong><span class="classifier">an <code class="xref py py-obj docutils literal notranslate"><span class="pre">emcee.EnsembleSampler</span></code> object</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id35" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id34">14</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://projecteuclid.org/euclid.ss/1177011136">https://projecteuclid.org/euclid.ss/1177011136</a></p>
</aside>
</aside>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.SamplingResults._infer">
<span class="sig-name descname"><span class="pre">_infer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ci_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">95</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#SamplingResults._infer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.SamplingResults._infer" title="Link to this definition">¶</a></dt>
<dd><p>Infer the <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> means, standard deviations and credible intervals
(i.e. the Bayesian equivalent to confidence intervals) from the <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> samples
for each parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ci_min</strong><span class="classifier">float</span></dt><dd><p>Lower bound to the credible interval, given as percentage between
0 and 100</p>
</dd>
<dt><strong>ci_max</strong><span class="classifier">float</span></dt><dd><p>Upper bound to the credible interval, given as percentage between
0 and 100</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.SamplingResults.plot_results">
<span class="sig-name descname"><span class="pre">plot_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsamples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test.pdf'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#SamplingResults.plot_results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.SamplingResults.plot_results" title="Link to this definition">¶</a></dt>
<dd><p>Plot some results in a triangle plot.
If installed, will use <a class="reference internal" href="#r95a502fd5a85-corner" id="id36">[corner]</a>
for the plotting, if not,
uses its own code to make a triangle plot.</p>
<p>By default, this method returns a <code class="docutils literal notranslate"><span class="pre">matplotlib.Figure</span></code> object, but
if <code class="docutils literal notranslate"><span class="pre">save_plot=True</span></code> the plot can be saved to file automatically,</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>nsamples</strong><span class="classifier">int, default 1000</span></dt><dd><p>The maximum number of samples used for plotting.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">matplotlib.Figure instance, default None</span></dt><dd><p>If created externally, you can pass a Figure instance to this method.
If none is passed, the method will create one internally.</p>
</dd>
<dt><strong>save_plot</strong><span class="classifier">bool, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> save the plot to file with a file name specified by the
keyword <code class="docutils literal notranslate"><span class="pre">filename</span></code>. If <code class="docutils literal notranslate"><span class="pre">False</span></code> just return the <code class="docutils literal notranslate"><span class="pre">Figure</span></code> object</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Name of the output file with the figure</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r95a502fd5a85-corner" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id36">corner</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/dfm/corner.py">https://github.com/dfm/corner.py</a></p>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.modeling.SamplingResults.print_results">
<span class="sig-name descname"><span class="pre">print_results</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/parameterestimation.html#SamplingResults.print_results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.SamplingResults.print_results" title="Link to this definition">¶</a></dt>
<dd><p>Print results of the MCMC run on screen or to a log-file.</p>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="convenience-functions">
<h3>Convenience Functions<a class="headerlink" href="#convenience-functions" title="Link to this heading">¶</a></h3>
<p>These functions are designed to help the user perform common tasks related to modelling and parameter
estimation. In particular, the function <a class="reference internal" href="#stingray.modeling.set_logprior" title="stingray.modeling.set_logprior"><code class="xref py py-func docutils literal notranslate"><span class="pre">stingray.modeling.set_logprior()</span></code></a> is designed to
help users set priors in their <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.modeling.Posterior</span></code></a> subclass objects.</p>
<dl class="py function">
<dt class="sig sig-object py" id="stingray.modeling.set_logprior">
<span class="sig-prename descclassname"><span class="pre">stingray.modeling.</span></span><span class="sig-name descname"><span class="pre">set_logprior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lpost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/posterior.html#set_logprior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.set_logprior" title="Link to this definition">¶</a></dt>
<dd><p>This function constructs the <code class="docutils literal notranslate"><span class="pre">logprior</span></code> method required to successfully
use a <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object.</p>
<p>All instances of class <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> and its subclasses require to implement a
<code class="docutils literal notranslate"><span class="pre">logprior</span></code> methods. However, priors are strongly problem-dependent and
therefore usually user-defined.</p>
<p>This function allows for setting the <code class="docutils literal notranslate"><span class="pre">logprior</span></code> method on any instance
of class <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> efficiently by allowing the user to pass a
dictionary of priors and an instance of class <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lpost</strong><span class="classifier"><a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> object</span></dt><dd><p>An instance of class <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a> or any of its subclasses</p>
</dd>
<dt><strong>priors</strong><span class="classifier">dict</span></dt><dd><p>A dictionary containing the prior definitions. Keys are parameter
names as defined by the <code class="docutils literal notranslate"><span class="pre">astropy.models.FittableModel</span></code> instance supplied
to the <code class="docutils literal notranslate"><span class="pre">model</span></code> parameter in <a class="reference internal" href="#stingray.modeling.Posterior" title="stingray.modeling.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a>. Items are functions
that take a parameter as input and return the log-prior probability
of that parameter.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>logprior</strong><span class="classifier">function</span></dt><dd><p>The function definition for the prior</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Make a light curve and power spectrum</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">photon_arrivals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="o">.</span><span class="n">make_lightcurve</span><span class="p">(</span><span class="n">photon_arrivals</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">Powerspectrum</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;frac&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Define the model</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">PowerLaw1D</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span><span class="o">.</span><span class="n">x_0</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>Instantiate the posterior:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lpost</span> <span class="o">=</span> <span class="n">PSDPosterior</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">ps</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">ps</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Define the priors:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p_alpha</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">alpha</span><span class="p">:</span> <span class="p">((</span><span class="o">-</span><span class="mf">1.</span> <span class="o">&lt;=</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mf">5.</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_amplitude</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">amplitude</span><span class="p">:</span> <span class="p">((</span><span class="o">-</span><span class="mi">10</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">amplitude</span><span class="p">))</span> <span class="o">&amp;</span>
<span class="gp">... </span>                                <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">amplitude</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">10.0</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">priors</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span><span class="n">p_alpha</span><span class="p">,</span> <span class="s2">&quot;amplitude&quot;</span><span class="p">:</span><span class="n">p_amplitude</span><span class="p">}</span>
</pre></div>
</div>
<p>Set the logprior method in the lpost object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lpost</span><span class="o">.</span><span class="n">logprior</span> <span class="o">=</span> <span class="n">set_logprior</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">priors</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-stingray.modeling.scripts"></span><dl class="py function">
<dt class="sig sig-object py" id="stingray.modeling.scripts.fit_crossspectrum">
<span class="sig-prename descclassname"><span class="pre">stingray.modeling.scripts.</span></span><span class="sig-name descname"><span class="pre">fit_crossspectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_pars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/scripts.html#fit_crossspectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.scripts.fit_crossspectrum" title="Link to this definition">¶</a></dt>
<dd><p>Fit a number of Lorentzians to a cross spectrum, possibly including white
noise. Each Lorentzian has three parameters (amplitude, centroid position,
full-width at half maximum), plus one extra parameter if the white noise
level should be fit as well. Priors for each parameter can be included in
case <code class="xref py py-obj docutils literal notranslate"><span class="pre">max_post</span> <span class="pre">=</span> <span class="pre">True</span></code>, in which case the function will attempt a
Maximum-A-Posteriori fit. Priors must be specified as a dictionary with one
entry for each parameter.
The parameter names are <code class="xref py py-obj docutils literal notranslate"><span class="pre">(amplitude_i,</span> <span class="pre">x_0_i,</span> <span class="pre">fwhm_i)</span></code> for each <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code> out of
a total of <code class="xref py py-obj docutils literal notranslate"><span class="pre">N</span></code> Lorentzians. The white noise level has a parameter
<code class="xref py py-obj docutils literal notranslate"><span class="pre">amplitude_(N+1)</span></code>. For example, a model with two Lorentzians and a
white noise level would have parameters:
[amplitude_0, x_0_0, fwhm_0, amplitude_1, x_0_1, fwhm_1, amplitude_2].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cs</strong><span class="classifier">Crossspectrum</span></dt><dd><p>A Crossspectrum object with the data to be fit</p>
</dd>
<dt><strong>model: astropy.modeling.models class instance</strong></dt><dd><p>The parametric model supposed to represent the data. For details
see the astropy.modeling documentation</p>
</dd>
<dt><strong>starting_pars</strong><span class="classifier">iterable, optional, default None</span></dt><dd><p>The list of starting guesses for the optimizer. If it is not provided,
then default parameters are taken from <code class="xref py py-obj docutils literal notranslate"><span class="pre">model</span></code>. See explanation above
for ordering of parameters in this list.</p>
</dd>
<dt><strong>max_post</strong><span class="classifier">bool, optional, default False</span></dt><dd><p>If True, perform a Maximum-A-Posteriori fit of the data rather than a
Maximum Likelihood fit. Note that this requires priors to be specified,
otherwise this will cause an exception!</p>
</dd>
<dt><strong>priors</strong><span class="classifier">{dict | None}, optional, default None</span></dt><dd><p>Dictionary with priors for the MAP fit. This should be of the form
{“parameter name”: probability distribution, …}</p>
</dd>
<dt><strong>fitmethod</strong><span class="classifier">string, optional, default “L-BFGS-B”</span></dt><dd><p>Specifies an optimization algorithm to use. Supply any valid option for
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="(in SciPy v1.14.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>parest</strong><span class="classifier">PSDParEst object</span></dt><dd><p>A PSDParEst object for further analysis</p>
</dd>
<dt><strong>res</strong><span class="classifier">OptimizationResults object</span></dt><dd><p>The OptimizationResults object storing useful results and quantities
relating to the fit</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.modeling.scripts.fit_lorentzians">
<span class="sig-prename descclassname"><span class="pre">stingray.modeling.scripts.</span></span><span class="sig-name descname"><span class="pre">fit_lorentzians</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nlor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_pars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_whitenoise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/scripts.html#fit_lorentzians"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.scripts.fit_lorentzians" title="Link to this definition">¶</a></dt>
<dd><p>Fit a number of Lorentzians to a power spectrum, possibly including white
noise. Each Lorentzian has three parameters (amplitude, centroid position,
full-width at half maximum), plus one extra parameter if the white noise
level should be fit as well. Priors for each parameter can be included in
case <code class="xref py py-obj docutils literal notranslate"><span class="pre">max_post</span> <span class="pre">=</span> <span class="pre">True</span></code>, in which case the function will attempt a
Maximum-A-Posteriori fit. Priors must be specified as a dictionary with one
entry for each parameter.
The parameter names are <code class="xref py py-obj docutils literal notranslate"><span class="pre">(amplitude_i,</span> <span class="pre">x_0_i,</span> <span class="pre">fwhm_i)</span></code> for each <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code> out of
a total of <code class="xref py py-obj docutils literal notranslate"><span class="pre">N</span></code> Lorentzians. The white noise level has a parameter
<code class="xref py py-obj docutils literal notranslate"><span class="pre">amplitude_(N+1)</span></code>. For example, a model with two Lorentzians and a
white noise level would have parameters:
[amplitude_0, x_0_0, fwhm_0, amplitude_1, x_0_1, fwhm_1, amplitude_2].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ps</strong><span class="classifier">Powerspectrum</span></dt><dd><p>A Powerspectrum object with the data to be fit</p>
</dd>
<dt><strong>nlor</strong><span class="classifier">int</span></dt><dd><p>The number of Lorentzians to fit</p>
</dd>
<dt><strong>starting_pars</strong><span class="classifier">iterable</span></dt><dd><p>The list of starting guesses for the optimizer. If it is not provided,
then default parameters are taken from <code class="xref py py-obj docutils literal notranslate"><span class="pre">model</span></code>. See explanation above
for ordering of parameters in this list.</p>
</dd>
<dt><strong>fit_whitenoise</strong><span class="classifier">bool, optional, default True</span></dt><dd><p>If True, the code will attempt to fit a white noise level along with
the Lorentzians. Be sure to include a starting parameter for the
optimizer in <code class="xref py py-obj docutils literal notranslate"><span class="pre">starting_pars</span></code>!</p>
</dd>
<dt><strong>max_post</strong><span class="classifier">bool, optional, default False</span></dt><dd><p>If True, perform a Maximum-A-Posteriori fit of the data rather than a
Maximum Likelihood fit. Note that this requires priors to be specified,
otherwise this will cause an exception!</p>
</dd>
<dt><strong>priors</strong><span class="classifier">{dict | None}, optional, default None</span></dt><dd><p>Dictionary with priors for the MAP fit. This should be of the form
{“parameter name”: probability distribution, …}</p>
</dd>
<dt><strong>fitmethod</strong><span class="classifier">string, optional, default “L-BFGS-B”</span></dt><dd><p>Specifies an optimization algorithm to use. Supply any valid option for
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="(in SciPy v1.14.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>parest</strong><span class="classifier">PSDParEst object</span></dt><dd><p>A PSDParEst object for further analysis</p>
</dd>
<dt><strong>res</strong><span class="classifier">OptimizationResults object</span></dt><dd><p>The OptimizationResults object storing useful results and quantities
relating to the fit</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We start by making an example power spectrum with three Lorentzians
&gt;&gt;&gt; np.random.seed(400)
&gt;&gt;&gt; nlor = 3</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_0_0</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_0_1</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_0_2</span> <span class="o">=</span> <span class="mf">7.5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude_0</span> <span class="o">=</span> <span class="mf">150.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude_1</span> <span class="o">=</span> <span class="mf">50.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude_2</span> <span class="o">=</span> <span class="mf">15.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fwhm_0</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fwhm_1</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fwhm_2</span> <span class="o">=</span> <span class="mf">0.5</span>
</pre></div>
</div>
<p>We will also include a white noise level:
&gt;&gt;&gt; whitenoise = 2.0</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Lorentz1D</span><span class="p">(</span><span class="n">amplitude_0</span><span class="p">,</span> <span class="n">x_0_0</span><span class="p">,</span> <span class="n">fwhm_0</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span>         <span class="n">models</span><span class="o">.</span><span class="n">Lorentz1D</span><span class="p">(</span><span class="n">amplitude_1</span><span class="p">,</span> <span class="n">x_0_1</span><span class="p">,</span> <span class="n">fwhm_1</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span>         <span class="n">models</span><span class="o">.</span><span class="n">Lorentz1D</span><span class="p">(</span><span class="n">amplitude_2</span><span class="p">,</span> <span class="n">x_0_2</span><span class="p">,</span> <span class="n">fwhm_2</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span>         <span class="n">models</span><span class="o">.</span><span class="n">Const1D</span><span class="p">(</span><span class="n">whitenoise</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">power</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">noise</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">Powerspectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Now we have to guess starting parameters. For each Lorentzian, we have
amplitude, centroid position and fwhm, and this pattern repeats for each
Lorentzian in the fit. The white noise level is the last parameter.
&gt;&gt;&gt; t0 = [150, 0.4, 0.2, 50, 2.3, 0.6, 20, 8.0, 0.4, 2.1]</p>
<p>We’re ready for doing the fit:
&gt;&gt;&gt; parest, res = fit_lorentzians(ps, nlor, t0)</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">res</span></code> contains a whole array of useful information about the fit, for
example the parameters at the optimum:
&gt;&gt;&gt; p_opt = res.p_opt</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.modeling.scripts.fit_powerspectrum">
<span class="sig-prename descclassname"><span class="pre">stingray.modeling.scripts.</span></span><span class="sig-name descname"><span class="pre">fit_powerspectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_pars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_post</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/modeling/scripts.html#fit_powerspectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.modeling.scripts.fit_powerspectrum" title="Link to this definition">¶</a></dt>
<dd><p>Fit a number of Lorentzians to a power spectrum, possibly including white
noise. Each Lorentzian has three parameters (amplitude, centroid position,
full-width at half maximum), plus one extra parameter if the white noise
level should be fit as well. Priors for each parameter can be included in
case <code class="xref py py-obj docutils literal notranslate"><span class="pre">max_post</span> <span class="pre">=</span> <span class="pre">True</span></code>, in which case the function will attempt a
Maximum-A-Posteriori fit. Priors must be specified as a dictionary with one
entry for each parameter.
The parameter names are <code class="xref py py-obj docutils literal notranslate"><span class="pre">(amplitude_i,</span> <span class="pre">x_0_i,</span> <span class="pre">fwhm_i)</span></code> for each <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code> out of
a total of <code class="xref py py-obj docutils literal notranslate"><span class="pre">N</span></code> Lorentzians. The white noise level has a parameter
<code class="xref py py-obj docutils literal notranslate"><span class="pre">amplitude_(N+1)</span></code>. For example, a model with two Lorentzians and a
white noise level would have parameters:
[amplitude_0, x_0_0, fwhm_0, amplitude_1, x_0_1, fwhm_1, amplitude_2].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ps</strong><span class="classifier">Powerspectrum</span></dt><dd><p>A Powerspectrum object with the data to be fit</p>
</dd>
<dt><strong>model: astropy.modeling.models class instance</strong></dt><dd><p>The parametric model supposed to represent the data. For details
see the astropy.modeling documentation</p>
</dd>
<dt><strong>starting_pars</strong><span class="classifier">iterable, optional, default None</span></dt><dd><p>The list of starting guesses for the optimizer. If it is not provided,
then default parameters are taken from <code class="xref py py-obj docutils literal notranslate"><span class="pre">model</span></code>. See explanation above
for ordering of parameters in this list.</p>
</dd>
<dt><strong>fit_whitenoise</strong><span class="classifier">bool, optional, default True</span></dt><dd><p>If True, the code will attempt to fit a white noise level along with
the Lorentzians. Be sure to include a starting parameter for the
optimizer in <code class="xref py py-obj docutils literal notranslate"><span class="pre">starting_pars</span></code>!</p>
</dd>
<dt><strong>max_post</strong><span class="classifier">bool, optional, default False</span></dt><dd><p>If True, perform a Maximum-A-Posteriori fit of the data rather than a
Maximum Likelihood fit. Note that this requires priors to be specified,
otherwise this will cause an exception!</p>
</dd>
<dt><strong>priors</strong><span class="classifier">{dict | None}, optional, default None</span></dt><dd><p>Dictionary with priors for the MAP fit. This should be of the form
{“parameter name”: probability distribution, …}</p>
</dd>
<dt><strong>fitmethod</strong><span class="classifier">string, optional, default “L-BFGS-B”</span></dt><dd><p>Specifies an optimization algorithm to use. Supply any valid option for
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="(in SciPy v1.14.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>parest</strong><span class="classifier">PSDParEst object</span></dt><dd><p>A PSDParEst object for further analysis</p>
</dd>
<dt><strong>res</strong><span class="classifier">OptimizationResults object</span></dt><dd><p>The OptimizationResults object storing useful results and quantities
relating to the fit</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We start by making an example power spectrum with three Lorentzians
&gt;&gt;&gt; m = 1
&gt;&gt;&gt; nfreq = 100000
&gt;&gt;&gt; freq = np.linspace(1, 1000, nfreq)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># set the seed for the random number generator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">nfreq</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">PowerLaw1D</span><span class="p">()</span> <span class="o">+</span> <span class="n">models</span><span class="o">.</span><span class="n">Const1D</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">x_0_0</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha_0</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude_0</span> <span class="o">=</span> <span class="mf">100.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude_1</span> <span class="o">=</span> <span class="mf">2.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">=</span> <span class="n">alpha_0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">amplitude_0</span> <span class="o">=</span> <span class="n">amplitude_0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">amplitude_1</span> <span class="o">=</span> <span class="n">amplitude_1</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">p</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span> <span class="o">=</span> <span class="n">Powerspectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ps</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="s2">&quot;leahy&quot;</span>
</pre></div>
</div>
<p>Now we have to guess starting parameters. For each Lorentzian, we have
amplitude, centroid position and fwhm, and this pattern repeats for each
Lorentzian in the fit. The white noise level is the last parameter.
&gt;&gt;&gt; t0 = [80, 1.5, 2.5]</p>
<p>Let’s also make a model to test:
&gt;&gt;&gt; model_to_test = models.PowerLaw1D() + models.Const1D()
&gt;&gt;&gt; model_to_test.amplitude_1.fixed = True</p>
<p>We’re ready for doing the fit:
&gt;&gt;&gt; parest, res = fit_powerspectrum(ps, model_to_test, t0)</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">res</span></code> contains a whole array of useful information about the fit, for
example the parameters at the optimum:
&gt;&gt;&gt; p_opt = res.p_opt</p>
</dd></dl>

</section>
</section>
<hr class="docutils" />
<section id="pulsar">
<h2>Pulsar<a class="headerlink" href="#pulsar" title="Link to this heading">¶</a></h2>
<p>This submodule broadly defines functionality related to (X-ray) pulsar data analysis, especially
periodicity searches.</p>
<span class="target" id="module-stingray.pulse"></span><dl class="py class">
<dt class="sig sig-object py" id="stingray.pulse.SincSquareModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">SincSquareModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/modeling.html#SincSquareModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.SincSquareModel" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.ef_profile_stat">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">ef_profile_stat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#ef_profile_stat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.ef_profile_stat" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the epoch folding statistics ‘a la Leahy et al. (1983).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>profile</strong><span class="classifier">array</span></dt><dd><p>The pulse profile</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stat</strong><span class="classifier">float</span></dt><dd><p>The epoch folding statistics</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>err</strong><span class="classifier">float or array</span></dt><dd><p>The uncertainties on the pulse profile</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.epoch_folding_search">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">epoch_folding_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expocorr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/search.html#epoch_folding_search"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.epoch_folding_search" title="Link to this definition">¶</a></dt>
<dd><p>Performs epoch folding at trial frequencies in photon data.</p>
<p>If no exposure correction is needed and numba is installed, it uses a fast
algorithm to perform the folding. Otherwise, it runs a <em>much</em> slower
algorithm, which however yields a more precise result.
The search can be done in segments and the results averaged. Use
segment_size to control this</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">array-like</span></dt><dd><p>the event arrival times</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">array-like</span></dt><dd><p>the trial values for the frequencies</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>(fgrid, stats) or (fgrid, fdgrid, stats), as follows:</dt><dd></dd>
<dt><strong>fgrid</strong><span class="classifier">array-like</span></dt><dd><p>frequency grid of the epoch folding periodogram</p>
</dd>
<dt><strong>fdgrid</strong><span class="classifier">array-like</span></dt><dd><p>frequency derivative grid. Only returned if fdots is an array.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">array-like</span></dt><dd><p>the epoch folding statistics corresponding to each frequency bin.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbin</strong><span class="classifier">int</span></dt><dd><p>the number of bins of the folded profiles</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>the length of the segments to be averaged in the periodogram</p>
</dd>
<dt><strong>fdots</strong><span class="classifier">array-like</span></dt><dd><p>trial values of the first frequency derivative (optional)</p>
</dd>
<dt><strong>expocorr</strong><span class="classifier">bool</span></dt><dd><p>correct for the exposure (Use it if the period is comparable to the
length of the good time intervals). If True, GTIs have to be specified
via the <code class="docutils literal notranslate"><span class="pre">gti</span></code> keyword</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti0_0, gti0_1], [gti1_0, gti1_1], …]</span></dt><dd><p>Good time intervals</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array-like</span></dt><dd><p>weight for each time. This might be, for example, the number of counts
if the times array contains the time bins of a light curve</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.fftfit">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">fftfit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prof</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quick</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_bootstrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">fftfit_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#fftfit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.fftfit" title="Link to this definition">¶</a></dt>
<dd><p>Align a template to a pulse profile.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>prof</strong><span class="classifier">array</span></dt><dd><p>The pulse profile</p>
</dd>
<dt><strong>template</strong><span class="classifier">array, default None</span></dt><dd><p>The template of the pulse used to perform the TOA calculation. If None,
a simple sinusoid is used</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mean_amp, std_amp</strong><span class="classifier">floats</span></dt><dd><p>Mean and standard deviation of the amplitude</p>
</dd>
<dt><strong>mean_phase, std_phase</strong><span class="classifier">floats</span></dt><dd><p>Mean and standard deviation of the phase</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>sigma</strong><span class="classifier">array</span></dt><dd><p>error on profile bins (currently has no effect)</p>
</dd>
<dt><strong>use_bootstrap</strong><span class="classifier">bool</span></dt><dd><p>Calculate errors using a bootstrap method, with <code class="xref py py-obj docutils literal notranslate"><span class="pre">fftfit_error</span></code></p>
</dd>
<dt><strong>**fftfit_kwargs</strong><span class="classifier">additional arguments for <code class="xref py py-obj docutils literal notranslate"><span class="pre">fftfit_error</span></code></span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.fit_gaussian">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">fit_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stddev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tied</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/modeling.html#fit_gaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.fit_gaussian" title="Link to this definition">¶</a></dt>
<dd><p>Fit a gaussian function to x,y values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd></dd>
<dt><strong>y</strong><span class="classifier">array-like</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g</strong><span class="classifier">function</span></dt><dd><p>The best-fit function, accepting x as input
and returning the best-fit model as output</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>The initial value for the amplitude</p>
</dd>
<dt><strong>mean</strong><span class="classifier">float</span></dt><dd><p>The initial value for the mean of the gaussian function</p>
</dd>
<dt><strong>stddev</strong><span class="classifier">float</span></dt><dd><p>The initial value for the standard deviation of the gaussian function</p>
</dd>
<dt><strong>tied</strong><span class="classifier">dict</span></dt><dd></dd>
<dt><strong>fixed</strong><span class="classifier">dict</span></dt><dd></dd>
<dt><strong>bounds</strong><span class="classifier">dict</span></dt><dd><p>Parameters to be passed to the [astropy models]_</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.fit_sinc">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">fit_sinc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tied</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obs_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/modeling.html#fit_sinc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.fit_sinc" title="Link to this definition">¶</a></dt>
<dd><p>Fit a sinc function to x,y values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd></dd>
<dt><strong>y</strong><span class="classifier">array-like</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sincfit</strong><span class="classifier">function</span></dt><dd><p>The best-fit function, accepting x as input
and returning the best-fit model as output</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amp</strong><span class="classifier">float</span></dt><dd><p>The initial value for the amplitude</p>
</dd>
<dt><strong>mean</strong><span class="classifier">float</span></dt><dd><p>The initial value for the mean of the sinc</p>
</dd>
<dt><strong>obs_length</strong><span class="classifier">float</span></dt><dd><p>The length of the observation. Default None. If it’s defined, it
fixes width to 1/(pi*obs_length), as expected from epoch folding
periodograms</p>
</dd>
<dt><strong>width</strong><span class="classifier">float</span></dt><dd><p>The initial value for the width of the sinc. Only valid if
obs_length is 0</p>
</dd>
<dt><strong>tied</strong><span class="classifier">dict</span></dt><dd></dd>
<dt><strong>fixed</strong><span class="classifier">dict</span></dt><dd></dd>
<dt><strong>bounds</strong><span class="classifier">dict</span></dt><dd><p>Parameters to be passed to the [astropy models]_</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.fold_events">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">fold_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">frequency_derivatives</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#fold_events"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.fold_events" title="Link to this definition">¶</a></dt>
<dd><p>Epoch folding with exposure correction.</p>
<p>By default, the keyword <code class="xref py py-obj docutils literal notranslate"><span class="pre">times</span></code> accepts a list of
unbinned photon arrival times. If the input data is
a (binned) light curve, then <code class="xref py py-obj docutils literal notranslate"><span class="pre">times</span></code> will contain the
time stamps of the observation, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">weights</span></code> should
be set to the corresponding fluxes or counts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">array of floats</span></dt><dd><p>Photon arrival times, or, if <code class="xref py py-obj docutils literal notranslate"><span class="pre">weights</span></code> is set,
time stamps of a light curve.</p>
</dd>
<dt><strong>f, fdot, fddot…</strong><span class="classifier">float</span></dt><dd><p>The frequency and any number of derivatives.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phase_bins</strong><span class="classifier">array of floats</span></dt><dd><p>The phases corresponding to the pulse profile</p>
</dd>
<dt><strong>profile</strong><span class="classifier">array of floats</span></dt><dd><p>The pulse profile</p>
</dd>
<dt><strong>profile_err</strong><span class="classifier">array of floats</span></dt><dd><p>The uncertainties on the pulse profile</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbin</strong><span class="classifier">int, optional, default 16</span></dt><dd><p>The number of bins in the pulse profile</p>
</dd>
<dt><strong>weights</strong><span class="classifier">float or array of floats, optional</span></dt><dd><p>The weights of the data. It can either be specified as a single value
for all points, or an array with the same length as <code class="docutils literal notranslate"><span class="pre">time</span></code></p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti0_0, gti0_1], [gti1_0, gti1_1], …], optional</span></dt><dd><p>Good time intervals</p>
</dd>
<dt><strong>ref_time</strong><span class="classifier">float, optional, default 0</span></dt><dd><p>Reference time for the timing solution</p>
</dd>
<dt><strong>expocorr</strong><span class="classifier">bool, default False</span></dt><dd><p>Correct each bin for exposure (use when the period of the pulsar is
comparable to that of GTIs)</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, [“ef”, “pdm”], default “ef”</span></dt><dd><p>Whether to calculate the epoch folding or phase dispersion
minimization folded profile. For “ef”, it calculates the (weighted)
sum of the data points in each phase bin, for “pdm”, the variance
in each phase bin</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.get_TOA">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">get_TOA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prof</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">period</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tstart</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quick</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_bootstrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">fftfit_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#get_TOA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.get_TOA" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the Time-Of-Arrival of a pulse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>prof</strong><span class="classifier">array</span></dt><dd><p>The pulse profile</p>
</dd>
<dt><strong>template</strong><span class="classifier">array, default None</span></dt><dd><p>The template of the pulse used to perform the TOA calculation, if any.
Otherwise use the default of fftfit</p>
</dd>
<dt><strong>tstart</strong><span class="classifier">float</span></dt><dd><p>The time at the start of the pulse profile</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>toa, toastd</strong><span class="classifier">floats</span></dt><dd><p>Mean and standard deviation of the TOA</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nstep</strong><span class="classifier">int, optional, default 100</span></dt><dd><p>Number of steps for the bootstrap method</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.get_orbital_correction_from_ephemeris_file">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">get_orbital_correction_from_ephemeris_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mjdstart</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mjdstop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntimes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ephem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DE405'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_pint_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#get_orbital_correction_from_ephemeris_file"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.get_orbital_correction_from_ephemeris_file" title="Link to this definition">¶</a></dt>
<dd><p>Get a correction for orbital motion from pulsar parameter file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mjdstart, mjdstop</strong><span class="classifier">float</span></dt><dd><p>Start and end of the time interval where we want the orbital solution</p>
</dd>
<dt><strong>parfile</strong><span class="classifier">str</span></dt><dd><p>Any parameter file understood by PINT (Tempo or Tempo2 format)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>correction_sec</strong><span class="classifier">function</span></dt><dd><p>Function that accepts in input an array of times in seconds and a
floating-point MJDref value, and returns the deorbited times</p>
</dd>
<dt><strong>correction_mjd</strong><span class="classifier">function</span></dt><dd><p>Function that accepts times in MJDs and returns the deorbited times.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ntimes</strong><span class="classifier">int</span></dt><dd><p>Number of time intervals to use for interpolation. Default 1000</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.htest">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">htest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datatype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'binned'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#htest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.htest" title="Link to this definition">¶</a></dt>
<dd><p>htest-test statistic, a` la De Jager+89, A&amp;A, 221, 180D, eq. 2.</p>
<p>If datatype is “binned” or “gauss”, uses the formulation from
Bachetti+2021, ApJ, arxiv:2012.11397</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array of floats</span></dt><dd><p>Phase values or binned flux values</p>
</dd>
<dt><strong>nmax</strong><span class="classifier">int, default 20</span></dt><dd><p>Maximum of harmonics for Z^2_n</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>The best number of harmonics that describe the signal.</p>
</dd>
<dt><strong>htest</strong><span class="classifier">float</span></dt><dd><p>The htest statistics of the events.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>datatype</strong><span class="classifier">str</span></dt><dd><p>The datatype of data: “events” if phase values between 0 and 1,
“binned” if folded pulse profile from photons, “gauss” if
folded pulse profile with normally-distributed fluxes</p>
</dd>
<dt><strong>err</strong><span class="classifier">float</span></dt><dd><p>The uncertainty on the pulse profile fluxes (required for
datatype=”gauss”, ignored otherwise)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.p_to_f">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">p_to_f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">period_derivatives</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#p_to_f"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.p_to_f" title="Link to this definition">¶</a></dt>
<dd><p>Convert periods into frequencies, and vice versa.</p>
<p>For now, limited to third derivative. Raises when a
fourth derivative is passed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p, pdot, pddot, …</strong><span class="classifier">floats</span></dt><dd><p>period derivatives, starting from zeroth and in
increasing order</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">p_to_f</span><span class="p">()</span> <span class="o">==</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_to_f</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_to_f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_to_f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_to_f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.pdm_profile_stat">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">pdm_profile_stat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#pdm_profile_stat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.pdm_profile_stat" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the phase dispersion minimization
statistic following Stellingwerf (1978)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>profile</strong><span class="classifier">array</span></dt><dd><p>The PDM pulse profile (variance as a function
of phase)</p>
</dd>
<dt><strong>sample_var</strong><span class="classifier">float</span></dt><dd><p>The total population variance of the sample</p>
</dd>
<dt><strong>nsample</strong><span class="classifier">int</span></dt><dd><p>The number of time bins in the initial time
series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stat</strong><span class="classifier">float</span></dt><dd><p>The epoch folding statistics</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.phase_dispersion_search">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">phase_dispersion_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expocorr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/search.html#phase_dispersion_search"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.phase_dispersion_search" title="Link to this definition">¶</a></dt>
<dd><p>Performs folding at trial frequencies in time series data (i.e.~a light curve
of flux or photon counts) and computes the Phase Dispersion Minimization statistic.</p>
<p>If no exposure correction is needed and numba is installed, it uses a fast
algorithm to perform the folding. Otherwise, it runs a <em>much</em> slower
algorithm, which however yields a more precise result.
The search can be done in segments and the results averaged. Use
segment_size to control this</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">array-like</span></dt><dd><p>the time stamps of the time series</p>
</dd>
<dt><strong>flux</strong><span class="classifier">array-like</span></dt><dd><p>the flux or photon count values of the time series</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">array-like</span></dt><dd><p>the trial values for the frequencies</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>(fgrid, stats) or (fgrid, fdgrid, stats), as follows:</dt><dd></dd>
<dt><strong>fgrid</strong><span class="classifier">array-like</span></dt><dd><p>frequency grid of the epoch folding periodogram</p>
</dd>
<dt><strong>fdgrid</strong><span class="classifier">array-like</span></dt><dd><p>frequency derivative grid. Only returned if fdots is an array.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">array-like</span></dt><dd><p>the epoch folding statistics corresponding to each frequency bin.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbin</strong><span class="classifier">int</span></dt><dd><p>the number of bins of the folded profiles</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>the length of the segments to be averaged in the periodogram</p>
</dd>
<dt><strong>fdots</strong><span class="classifier">array-like</span></dt><dd><p>trial values of the first frequency derivative (optional)</p>
</dd>
<dt><strong>expocorr</strong><span class="classifier">bool</span></dt><dd><p>correct for the exposure (Use it if the period is comparable to the
length of the good time intervals). If True, GTIs have to be specified
via the <code class="docutils literal notranslate"><span class="pre">gti</span></code> keyword</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti0_0, gti0_1], [gti1_0, gti1_1], …]</span></dt><dd><p>Good time intervals</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.phase_exposure">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">phase_exposure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">period</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#phase_exposure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.phase_exposure" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the exposure on each phase of a pulse profile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start_time, stop_time</strong><span class="classifier">float</span></dt><dd><p>Starting and stopping time (or phase if <code class="docutils literal notranslate"><span class="pre">period==1</span></code>)</p>
</dd>
<dt><strong>period</strong><span class="classifier">float</span></dt><dd><p>The pulse period (if 1, equivalent to phases)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>expo</strong><span class="classifier">array of floats</span></dt><dd><p>The normalized exposure of each bin in the pulse profile (1 is the
highest exposure, 0 the lowest)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbin</strong><span class="classifier">int, optional, default 16</span></dt><dd><p>The number of bins in the profile</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti00, gti01], [gti10, gti11], …], optional, default None</span></dt><dd><p>Good Time Intervals</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.phaseogram">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">phaseogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nph</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ph0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mjdref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fddot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pepoch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phaseogram_ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">plot_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/search.html#phaseogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.phaseogram" title="Link to this definition">¶</a></dt>
<dd><p>Calculate and plot the phaseogram of a pulsar observation.</p>
<p>The phaseogram is a 2-D histogram where the x axis is the pulse phase and
the y axis is the time. It shows how the pulse phase changes with time, and
it is very useful to see if the pulse solution is correct and/or if there
are additional frequency derivatives appearing in the data (due to spin up
or down, or even orbital motion)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">array</span></dt><dd><p>Event arrival times</p>
</dd>
<dt><strong>f</strong><span class="classifier">float</span></dt><dd><p>Pulse frequency</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phaseogr</strong><span class="classifier">2-D matrix</span></dt><dd><p>The phaseogram</p>
</dd>
<dt><strong>phases</strong><span class="classifier">array-like</span></dt><dd><p>The x axis of the phaseogram (the x bins of the histogram),
corresponding to the pulse phase in each column</p>
</dd>
<dt><strong>times</strong><span class="classifier">array-like</span></dt><dd><p>The y axis of the phaseogram (the y bins of the histogram),
corresponding to the time at each row</p>
</dd>
<dt><strong>additional_info</strong><span class="classifier">dict</span></dt><dd><p>Additional information, like the pulse profile and the axes to modify
the plot (the latter, only if <code class="xref py py-obj docutils literal notranslate"><span class="pre">return_plot</span></code> is True)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nph</strong><span class="classifier">int</span></dt><dd><p>Number of phase bins</p>
</dd>
<dt><strong>nt</strong><span class="classifier">int</span></dt><dd><p>Number of time bins</p>
</dd>
<dt><strong>ph0</strong><span class="classifier">float</span></dt><dd><p>The starting phase of the pulse</p>
</dd>
<dt><strong>mjdref</strong><span class="classifier">float</span></dt><dd><p>MJD reference time. If given, the y axis of the plot will be in MJDs,
otherwise it will be in seconds.</p>
</dd>
<dt><strong>fdot</strong><span class="classifier">float</span></dt><dd><p>First frequency derivative</p>
</dd>
<dt><strong>fddot</strong><span class="classifier">float</span></dt><dd><p>Second frequency derivative</p>
</dd>
<dt><strong>pepoch</strong><span class="classifier">float</span></dt><dd><p>If the input pulse solution is referred to a given time, give it here.
It has no effect (just a phase shift of the pulse) if <code class="xref py py-obj docutils literal notranslate"><span class="pre">fdot</span></code> is zero.
if <code class="xref py py-obj docutils literal notranslate"><span class="pre">mjdref</span></code> is specified, pepoch MUST be in MJD</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array</span></dt><dd><p>Weight for each time</p>
</dd>
<dt><strong>plot</strong><span class="classifier">bool</span></dt><dd><p>Return the axes in the additional_info, and don’t close the plot, so
that the user can add information to it.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.plot_phaseogram">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">plot_phaseogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phaseogram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_str</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">plot_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/search.html#plot_phaseogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.plot_phaseogram" title="Link to this definition">¶</a></dt>
<dd><p>Plot a phaseogram.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phaseogram</strong><span class="classifier">NxM array</span></dt><dd><p>The phaseogram to be plotted</p>
</dd>
<dt><strong>phase_bins</strong><span class="classifier">array of M + 1 elements</span></dt><dd><p>The bins on the x-axis</p>
</dd>
<dt><strong>time_bins</strong><span class="classifier">array of N + 1 elements</span></dt><dd><p>The bins on the y-axis</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>ax</strong><span class="classifier"><a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.axis.html#matplotlib.pyplot.axis" title="(in Matplotlib v3.9.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis</span></code></a> instance</span></dt><dd><p>Axis where the phaseogram was plotted.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>unit_str</strong><span class="classifier">str</span></dt><dd><p>String indicating the time unit (e.g. ‘s’, ‘MJD’, etc)</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.axis.html#matplotlib.pyplot.axis" title="(in Matplotlib v3.9.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis</span></code></a> instance</span></dt><dd><p>Axis to plot to. If None, create a new one.</p>
</dd>
<dt><strong>plot_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional arguments to be passed to pcolormesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.plot_profile">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">plot_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/search.html#plot_profile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.plot_profile" title="Link to this definition">¶</a></dt>
<dd><p>Plot a pulse profile showing some stats.</p>
<p>If err is None, the profile is assumed in counts and the Poisson confidence
level is plotted. Otherwise, err is shown as error bars</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phase</strong><span class="classifier">array-like</span></dt><dd><p>The bins on the x-axis</p>
</dd>
<dt><strong>profile</strong><span class="classifier">array-like</span></dt><dd><p>The pulsed profile</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>ax</strong><span class="classifier"><a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.axis.html#matplotlib.pyplot.axis" title="(in Matplotlib v3.9.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis</span></code></a> instance</span></dt><dd><p>Axis where the profile was plotted.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ax</strong><span class="classifier"><a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.axis.html#matplotlib.pyplot.axis" title="(in Matplotlib v3.9.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.pyplot.axis</span></code></a> instance</span></dt><dd><p>Axis to plot to. If None, create a new one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.pulse_phase">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">pulse_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">frequency_derivatives</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#pulse_phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.pulse_phase" title="Link to this definition">¶</a></dt>
<dd><p>Calculate pulse phase from the frequency and its derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">array of floats</span></dt><dd><p>The times at which the phase is calculated</p>
</dd>
<dt><strong>*frequency_derivatives: floats</strong></dt><dd><p>List of derivatives in increasing order, starting from zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phases</strong><span class="classifier">array of floats</span></dt><dd><p>The absolute pulse phase</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ph0</strong><span class="classifier">float</span></dt><dd><p>The starting phase</p>
</dd>
<dt><strong>to_1</strong><span class="classifier">bool, default True</span></dt><dd><p>Only return the fractional part of the phase, normalized from 0 to 1</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.search_best_peaks">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">search_best_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/search.html#search_best_peaks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.search_best_peaks" title="Link to this definition">¶</a></dt>
<dd><p>Search peaks above threshold in an epoch folding periodogram.</p>
<p>If more values of stat are above threshold and are contiguous, only the
largest one is returned (see Examples).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd><p>The x axis of the periodogram (frequencies, periods, …)</p>
</dd>
<dt><strong>stat</strong><span class="classifier">array-like</span></dt><dd><p>The y axis. It must have the same shape as x</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>The threshold value over which we look for peaks in the stat array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>best_x</strong><span class="classifier">array-like</span></dt><dd><p>the array containing the x position of the peaks above threshold. If no
peaks are above threshold, an empty list is returned. The array is
sorted by inverse value of stat</p>
</dd>
<dt><strong>best_stat</strong><span class="classifier">array-like</span></dt><dd><p>for each best_x, give the corresponding stat value. Empty if no peaks
above threshold.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test multiple peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">best_x</span><span class="p">,</span> <span class="n">best_stat</span> <span class="o">=</span> <span class="n">search_best_peaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">best_x</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">best_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">7.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">best_x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">best_x</span><span class="p">,</span> <span class="n">best_stat</span> <span class="o">=</span> <span class="n">search_best_peaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">best_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test no peak above threshold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">best_x</span><span class="p">,</span> <span class="n">best_stat</span> <span class="o">=</span> <span class="n">search_best_peaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">best_x</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">best_stat</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.sinc_square_deriv">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">sinc_square_deriv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/modeling.html#sinc_square_deriv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.sinc_square_deriv" title="Link to this definition">¶</a></dt>
<dd><p>Calculate partial derivatives of sinc-squared.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: array-like</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d_amplitude</strong><span class="classifier">array-like</span></dt><dd><p>partial derivative of sinc-squared function
with respect to the amplitude</p>
</dd>
<dt><strong>d_mean</strong><span class="classifier">array-like</span></dt><dd><p>partial derivative of sinc-squared function
with respect to the mean</p>
</dd>
<dt><strong>d_width</strong><span class="classifier">array-like</span></dt><dd><p>partial derivative of sinc-squared function
with respect to the width</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>the value for x=mean</p>
</dd>
<dt><strong>mean</strong><span class="classifier">float</span></dt><dd><p>mean of the sinc function</p>
</dd>
<dt><strong>width</strong><span class="classifier">float</span></dt><dd><p>width of the sinc function</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">sinc_square_deriv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">2.</span><span class="p">),</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.sinc_square_model">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">sinc_square_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/modeling.html#sinc_square_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.sinc_square_model" title="Link to this definition">¶</a></dt>
<dd><p>Calculate a sinc-squared function.</p>
<p>(sin(x)/x)**2</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: array-like</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sqvalues</strong><span class="classifier">array-like</span></dt><dd><p>Return square of sinc function</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>the value for x=mean</p>
</dd>
<dt><strong>mean</strong><span class="classifier">float</span></dt><dd><p>mean of the sinc function</p>
</dd>
<dt><strong>width</strong><span class="classifier">float</span></dt><dd><p>width of the sinc function</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">sinc_square_model</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">2.</span><span class="p">),</span> <span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.test">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#stingray.pulse.test" title="Link to this definition">¶</a></dt>
<dd><p>Run the tests for the package.</p>
<p>This method builds arguments for and then calls <code class="docutils literal notranslate"><span class="pre">pytest.main</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>package</strong><span class="classifier">str, optional</span></dt><dd><p>The name of a specific package to test, e.g. ‘io.fits’ or
‘utils’. Accepts comma separated string to specify multiple
packages. If nothing is specified all default tests are run.</p>
</dd>
<dt><strong>args</strong><span class="classifier">str, optional</span></dt><dd><p>Additional arguments to be passed to <code class="docutils literal notranslate"><span class="pre">pytest.main</span></code> in the <code class="docutils literal notranslate"><span class="pre">args</span></code>
keyword argument.</p>
</dd>
<dt><strong>docs_path</strong><span class="classifier">str, optional</span></dt><dd><p>The path to the documentation .rst files.</p>
</dd>
<dt><strong>parallel</strong><span class="classifier">int or ‘auto’, optional</span></dt><dd><p>When provided, run the tests in parallel on the specified
number of CPUs.  If parallel is <code class="docutils literal notranslate"><span class="pre">'auto'</span></code>, it will use the all
the cores on the machine.  Requires the <code class="docutils literal notranslate"><span class="pre">pytest-xdist</span></code> plugin.</p>
</dd>
<dt><strong>pastebin</strong><span class="classifier">(‘failed’, ‘all’, None), optional</span></dt><dd><p>Convenience option for turning on pytest pastebin output. Set to
‘failed’ to upload info for failed tests, or ‘all’ to upload info
for all tests.</p>
</dd>
<dt><strong>pdb</strong><span class="classifier">bool, optional</span></dt><dd><p>Turn on PDB post-mortem analysis for failing tests. Same as
specifying <code class="docutils literal notranslate"><span class="pre">--pdb</span></code> in <code class="docutils literal notranslate"><span class="pre">args</span></code>.</p>
</dd>
<dt><strong>pep8</strong><span class="classifier">bool, optional</span></dt><dd><p>Turn on PEP8 checking via the pytest-pep8 plugin and disable normal
tests. Same as specifying <code class="docutils literal notranslate"><span class="pre">--pep8</span> <span class="pre">-k</span> <span class="pre">pep8</span></code> in <code class="docutils literal notranslate"><span class="pre">args</span></code>.</p>
</dd>
<dt><strong>plugins</strong><span class="classifier">list, optional</span></dt><dd><p>Plugins to be passed to <code class="docutils literal notranslate"><span class="pre">pytest.main</span></code> in the <code class="docutils literal notranslate"><span class="pre">plugins</span></code> keyword
argument.</p>
</dd>
<dt><strong>remote_data</strong><span class="classifier">{‘none’, ‘astropy’, ‘any’}, optional</span></dt><dd><p>Controls whether to run tests marked with &#64;pytest.mark.remote_data. This can be
set to run no tests with remote data (<code class="docutils literal notranslate"><span class="pre">none</span></code>), only ones that use
data from <a class="reference external" href="http://data.astropy.org">http://data.astropy.org</a> (<code class="docutils literal notranslate"><span class="pre">astropy</span></code>), or all tests that
use remote data (<code class="docutils literal notranslate"><span class="pre">any</span></code>). The default is <code class="docutils literal notranslate"><span class="pre">none</span></code>.</p>
</dd>
<dt><strong>repeat</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>, optional</span></dt><dd><p>If set, specifies how many times each test should be run. This is
useful for diagnosing sporadic failures.</p>
</dd>
<dt><strong>skip_docs</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, optional</span></dt><dd><p>When <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a>, skips running the doctests in the .rst files.</p>
</dd>
<dt><strong>test_path</strong><span class="classifier">str, optional</span></dt><dd><p>Specify location to test by path. May be a single file or
directory. Must be specified absolutely or relative to the
calling directory.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>Convenience option to turn on verbose output from pytest. Passing
True is the same as specifying <code class="docutils literal notranslate"><span class="pre">-v</span></code> in <code class="docutils literal notranslate"><span class="pre">args</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.z_n">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">z_n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datatype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'events'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#z_n"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.z_n" title="Link to this definition">¶</a></dt>
<dd><p>Z^2_n statistics, a` la Buccheri+83, A&amp;A, 128, 245, eq. 2.</p>
<p>If datatype is “binned” or “gauss”, uses the formulation from
Bachetti+2021, ApJ, arxiv:2012.11397</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array of floats</span></dt><dd><p>Phase values or binned flux values</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, default 2</span></dt><dd><p>Number of harmonics, including the fundamental</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z2_n</strong><span class="classifier">float</span></dt><dd><p>The Z^2_n statistics of the events.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>datatype</strong><span class="classifier">str</span></dt><dd><p>The data type: “events” if phase values between 0 and 1,
“binned” if folded pulse profile from photons, “gauss” if
folded pulse profile with normally-distributed fluxes</p>
</dd>
<dt><strong>err</strong><span class="classifier">float</span></dt><dd><p>The uncertainty on the pulse profile fluxes (required for
datatype=”gauss”, ignored otherwise)</p>
</dd>
<dt><strong>norm</strong><span class="classifier">float</span></dt><dd><p>For backwards compatibility; if norm is not None, it is
substituted to <code class="docutils literal notranslate"><span class="pre">data</span></code>, and data is ignored. This raises
a DeprecationWarning</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.z_n_binned_events">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">z_n_binned_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#z_n_binned_events"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.z_n_binned_events" title="Link to this definition">¶</a></dt>
<dd><p>Z^2_n statistic for pulse profiles from binned events</p>
<p>See Bachetti+2021, arXiv:2012.11397</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>profile</strong><span class="classifier">array of floats</span></dt><dd><p>The folded pulse profile (containing the number of
photons falling in each pulse bin)</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of harmonics, including the fundamental</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z2_n</strong><span class="classifier">float</span></dt><dd><p>The value of the statistic</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.z_n_binned_events_all">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">z_n_binned_events_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#z_n_binned_events_all"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.z_n_binned_events_all" title="Link to this definition">¶</a></dt>
<dd><p>Z^2_n statistic for multiple harmonics and binned events</p>
<p>See Bachetti+2021, arXiv:2012.11397</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>profile</strong><span class="classifier">array of floats</span></dt><dd><p>The folded pulse profile (containing the number of
photons falling in each pulse bin)</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of harmonics, including the fundamental</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ks</strong><span class="classifier">list of ints</span></dt><dd><p>Harmonic numbers, from 1 to nmax (included)</p>
</dd>
<dt><strong>z2_n</strong><span class="classifier">float</span></dt><dd><p>The value of the statistic for all ks</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.z_n_events">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">z_n_events</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#z_n_events"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.z_n_events" title="Link to this definition">¶</a></dt>
<dd><p>Z^2_n statistics, a` la Buccheri+83, A&amp;A, 128, 245, eq. 2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phase</strong><span class="classifier">array of floats</span></dt><dd><p>The phases of the events</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, default 2</span></dt><dd><p>Number of harmonics, including the fundamental</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z2_n</strong><span class="classifier">float</span></dt><dd><p>The Z^2_n statistic</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.z_n_events_all">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">z_n_events_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#z_n_events_all"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.z_n_events_all" title="Link to this definition">¶</a></dt>
<dd><p>Z^2_n statistics, a` la Buccheri+83, A&amp;A, 128, 245, eq. 2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phase</strong><span class="classifier">array of floats</span></dt><dd><p>The phases of the events</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, default 2</span></dt><dd><p>Number of harmonics, including the fundamental</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ks</strong><span class="classifier">list of ints</span></dt><dd><p>Harmonic numbers, from 1 to nmax (included)</p>
</dd>
<dt><strong>z2_n</strong><span class="classifier">float</span></dt><dd><p>The Z^2_n statistic for all ks</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.z_n_gauss">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">z_n_gauss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#z_n_gauss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.z_n_gauss" title="Link to this definition">¶</a></dt>
<dd><p>Z^2_n statistic for normally-distributed profiles</p>
<p>See Bachetti+2021, arXiv:2012.11397</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>profile</strong><span class="classifier">array of floats</span></dt><dd><p>The folded pulse profile</p>
</dd>
<dt><strong>err</strong><span class="classifier">float</span></dt><dd><p>The (assumed constant) uncertainty on the flux in each bin.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of harmonics, including the fundamental</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z2_n</strong><span class="classifier">float</span></dt><dd><p>The value of the statistic</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.z_n_gauss_all">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">z_n_gauss_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/pulsar.html#z_n_gauss_all"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.z_n_gauss_all" title="Link to this definition">¶</a></dt>
<dd><p>Z^2_n statistic for n harmonics and normally-distributed profiles</p>
<p>See Bachetti+2021, arXiv:2012.11397</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>profile</strong><span class="classifier">array of floats</span></dt><dd><p>The folded pulse profile</p>
</dd>
<dt><strong>err</strong><span class="classifier">float</span></dt><dd><p>The (assumed constant) uncertainty on the flux in each bin.</p>
</dd>
<dt><strong>nmax</strong><span class="classifier">int</span></dt><dd><p>Maximum number of harmonics, including the fundamental</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ks</strong><span class="classifier">list of ints</span></dt><dd><p>Harmonic numbers, from 1 to nmax (included)</p>
</dd>
<dt><strong>z2_n</strong><span class="classifier">list of floats</span></dt><dd><p>The value of the statistic for all ks</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="stingray.pulse.z_n_search">
<span class="sig-prename descclassname"><span class="pre">stingray.pulse.</span></span><span class="sig-name descname"><span class="pre">z_n_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nharm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expocorr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/pulse/search.html#z_n_search"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.pulse.z_n_search" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the Z^2_n statistics at trial frequencies in photon data.</p>
<p>The “real” Z^2_n statistics is very slow. Therefore, in this function data
are folded first, and then the statistics is calculated using the value of
the profile as an additional normalization term.
The two methods are mostly equivalent. However, the number of bins has to
be chosen wisely: if the number of bins is too small, the search for high
harmonics is ineffective.
If no exposure correction is needed and numba is installed, it uses a fast
algorithm to perform the folding. Otherwise, it runs a <em>much</em> slower
algorithm, which however yields a more precise result.
The search can be done in segments and the results averaged. Use
segment_size to control this</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times</strong><span class="classifier">array-like</span></dt><dd><p>the event arrival times</p>
</dd>
<dt><strong>frequencies</strong><span class="classifier">array-like</span></dt><dd><p>the trial values for the frequencies</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>(fgrid, stats) or (fgrid, fdgrid, stats), as follows:</dt><dd></dd>
<dt><strong>fgrid</strong><span class="classifier">array-like</span></dt><dd><p>frequency grid of the epoch folding periodogram</p>
</dd>
<dt><strong>fdgrid</strong><span class="classifier">array-like</span></dt><dd><p>frequency derivative grid. Only returned if fdots is an array.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">array-like</span></dt><dd><p>the Z^2_n statistics corresponding to each frequency bin.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbin</strong><span class="classifier">int</span></dt><dd><p>the number of bins of the folded profiles</p>
</dd>
<dt><strong>segment_size</strong><span class="classifier">float</span></dt><dd><p>the length of the segments to be averaged in the periodogram</p>
</dd>
<dt><strong>fdots</strong><span class="classifier">array-like</span></dt><dd><p>trial values of the first frequency derivative (optional)</p>
</dd>
<dt><strong>expocorr</strong><span class="classifier">bool</span></dt><dd><p>correct for the exposure (Use it if the period is comparable to the
length of the good time intervals.)</p>
</dd>
<dt><strong>gti</strong><span class="classifier">[[gti0_0, gti0_1], [gti1_0, gti1_1], …]</span></dt><dd><p>Good time intervals</p>
</dd>
<dt><strong>weights</strong><span class="classifier">array-like</span></dt><dd><p>weight for each time. This might be, for example, the number of counts
if the times array contains the time bins of a light curve</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="simulator">
<h2>Simulator<a class="headerlink" href="#simulator" title="Link to this heading">¶</a></h2>
<p>This submodule defines extensive functionality related to simulating spectral-timing data sets,
including transfer and window functions, simulating light curves from power spectra for a range
of stochastic processes.</p>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.simulator.simulator.</span></span><span class="sig-name descname"><span class="pre">Simulator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">red_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poisson</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator" title="Link to this definition">¶</a></dt>
<dd><p>Methods to simulate and visualize light curves.</p>
<p>TODO: Improve documentation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">int, default 1</span></dt><dd><p>time resolution of simulated light curve</p>
</dd>
<dt><strong>N</strong><span class="classifier">int, default 1024</span></dt><dd><p>bins count of simulated light curve</p>
</dd>
<dt><strong>mean</strong><span class="classifier">float, default 0</span></dt><dd><p>mean value of the simulated light curve</p>
</dd>
<dt><strong>rms</strong><span class="classifier">float, default 1</span></dt><dd><p>fractional rms of the simulated light curve,
actual rms is calculated by mean*rms</p>
</dd>
<dt><strong>err</strong><span class="classifier">float, default 0</span></dt><dd><p>the errorbars on the final light curve</p>
</dd>
<dt><strong>red_noise</strong><span class="classifier">int, default 1</span></dt><dd><p>multiple of real length of light curve, by
which to simulate, to avoid red noise leakage</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">int, default None</span></dt><dd><p>seed value for random processes</p>
</dd>
<dt><strong>poisson</strong><span class="classifier">bool, default False</span></dt><dd><p>return Poisson-distributed light curves.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.count_channels">
<span class="sig-name descname"><span class="pre">count_channels</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.count_channels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.count_channels" title="Link to this definition">¶</a></dt>
<dd><p>Return total number of energy channels.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.delete_channel">
<span class="sig-name descname"><span class="pre">delete_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.delete_channel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.delete_channel" title="Link to this definition">¶</a></dt>
<dd><p>Delete an energy channel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.delete_channels">
<span class="sig-name descname"><span class="pre">delete_channels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channels</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.delete_channels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.delete_channels" title="Link to this definition">¶</a></dt>
<dd><p>Delete multiple energy channels.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.get_all_channels">
<span class="sig-name descname"><span class="pre">get_all_channels</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.get_all_channels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.get_all_channels" title="Link to this definition">¶</a></dt>
<dd><p>Get lightcurves belonging to all channels.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.get_channel">
<span class="sig-name descname"><span class="pre">get_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.get_channel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.get_channel" title="Link to this definition">¶</a></dt>
<dd><p>Get lightcurve belonging to the energy channel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.get_channels">
<span class="sig-name descname"><span class="pre">get_channels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channels</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.get_channels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.get_channels" title="Link to this definition">¶</a></dt>
<dd><p>Get multiple light curves belonging to the energy channels.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.powerspectrum">
<span class="sig-name descname"><span class="pre">powerspectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seg_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.powerspectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.powerspectrum" title="Link to this definition">¶</a></dt>
<dd><p>Make a powerspectrum of the simulated light curve.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lc</strong><span class="classifier">lightcurve.Lightcurve object OR</span></dt><dd><p>iterable of lightcurve.Lightcurve objects
The light curve data to be Fourier-transformed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>power</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The array of normalized squared absolute values of Fourier
amplitudes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.read">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pickle'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.read" title="Link to this definition">¶</a></dt>
<dd><p>Reads transfer function from a ‘pickle’ file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fmt</strong><span class="classifier">str</span></dt><dd><p>the format of the file to be retrieved - accepts ‘pickle’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">class instance</span></dt><dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransferFunction</span></code> object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.relativistic_ir">
<span class="sig-name descname"><span class="pre">relativistic_ir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.relativistic_ir"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.relativistic_ir" title="Link to this definition">¶</a></dt>
<dd><p>Construct a realistic impulse response considering the relativistic
effects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t1</strong><span class="classifier">int</span></dt><dd><p>primary peak time</p>
</dd>
<dt><strong>t2</strong><span class="classifier">int</span></dt><dd><p>secondary peak time</p>
</dd>
<dt><strong>t3</strong><span class="classifier">int</span></dt><dd><p>end time</p>
</dd>
<dt><strong>p1</strong><span class="classifier">float</span></dt><dd><p>value of primary peak</p>
</dd>
<dt><strong>p2</strong><span class="classifier">float</span></dt><dd><p>value of secondary peak</p>
</dd>
<dt><strong>rise</strong><span class="classifier">float</span></dt><dd><p>slope of rising exponential from primary peak to secondary peak</p>
</dd>
<dt><strong>decay</strong><span class="classifier">float</span></dt><dd><p>slope of decaying exponential from secondary peak to end time</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Constructed impulse response</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.simple_ir">
<span class="sig-name descname"><span class="pre">simple_ir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.simple_ir"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.simple_ir" title="Link to this definition">¶</a></dt>
<dd><p>Construct a simple impulse response using start time,
width and scaling intensity.
To create a delta impulse response, set width to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>start time of impulse response</p>
</dd>
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>width of impulse response</p>
</dd>
<dt><strong>intensity</strong><span class="classifier">float</span></dt><dd><p>scaling parameter to set the intensity of delayed emission
corresponding to direct emission.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Constructed impulse response</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.simulate">
<span class="sig-name descname"><span class="pre">simulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.simulate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.simulate" title="Link to this definition">¶</a></dt>
<dd><p>Simulate light curve generation using power spectrum or
impulse response.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong></dt><dd><p>See examples below.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>lightCurve</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LightCurve</span></code> object</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<ul>
<li><dl>
<dt>x = simulate(beta):</dt><dd><p>For generating a light curve using power law spectrum.</p>
<blockquote>
<div><dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>beta : float
Defines the shape of spectrum</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt>x = simulate(s):</dt><dd><dl>
<dt>For generating a light curve from user-provided spectrum.</dt><dd><p><strong>Note</strong>: In this case, the <code class="xref py py-obj docutils literal notranslate"><span class="pre">red_noise</span></code> parameter is provided.
You can generate a longer light curve by providing a higher
frequency resolution on the input power spectrum.</p>
<blockquote>
<div><dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>s : array-like
power spectrum</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl>
<dt>x = simulate(model):</dt><dd><p>For generating a light curve from pre-defined model</p>
<blockquote>
<div><dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>model : astropy.modeling.Model
the pre-defined model</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt>x = simulate(‘model’, params):</dt><dd><p>For generating a light curve from pre-defined model</p>
<blockquote>
<div><dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>model : string
the pre-defined model</p></li>
<li><p>params : list iterable or dict
the parameters for the pre-defined model</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt>x = simulate(s, h):</dt><dd><p>For generating a light curve using impulse response.</p>
<blockquote>
<div><dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>s : array-like
Underlying variability signal</p></li>
<li><p>h : array-like
Impulse response</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt>x = simulate(s, h, ‘same’):</dt><dd><p>For generating a light curve of same length as input signal,
using impulse response.</p>
<blockquote>
<div><dl class="simple">
<dt>Parameters:</dt><dd><ul class="simple">
<li><p>s : array-like
Underlying variability signal</p></li>
<li><p>h : array-like
Impulse response</p></li>
<li><p>mode : str
mode can be ‘same’, ‘filtered, or ‘full’.
‘same’ indicates that the length of output light
curve is same as that of input signal.
‘filtered’ means that length of output light curve
is len(s) - lag_delay
‘full’ indicates that the length of output light
curve is len(s) + len(h) -1</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.simulate_channel">
<span class="sig-name descname"><span class="pre">simulate_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.simulate_channel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.simulate_channel" title="Link to this definition">¶</a></dt>
<dd><p>Simulate a lightcurve and add it to corresponding energy
channel.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>channel</strong><span class="classifier">str</span></dt><dd><p>range of energy channel (e.g., 3.5-4.5)</p>
</dd>
<dt><strong>*args</strong></dt><dd><p>see description of simulate() for details</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>lightCurve</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LightCurve</span></code> object</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="stingray.simulator.simulator.Simulator.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pickle'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/stingray/simulator/simulator.html#Simulator.write"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.simulator.simulator.Simulator.write" title="Link to this definition">¶</a></dt>
<dd><p>Writes a transfer function to ‘pickle’ file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fmt</strong><span class="classifier">str</span></dt><dd><p>the format of the file to be saved - accepts ‘pickle’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Link to this heading">¶</a></h2>
<p>Some basic Stingray-related errors and exceptions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="stingray.exceptions.StingrayError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">stingray.exceptions.</span></span><span class="sig-name descname"><span class="pre">StingrayError</span></span><a class="reference internal" href="_modules/stingray/exceptions.html#StingrayError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#stingray.exceptions.StingrayError" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">Stingray API</a><ul>
<li><a class="reference internal" href="#base-class">Base Class</a><ul>
<li><a class="reference internal" href="#stingrayobject">StingrayObject</a><ul>
<li><a class="reference internal" href="#stingray.StingrayObject"><code class="docutils literal notranslate"><span class="pre">StingrayObject</span></code></a><ul>
<li><a class="reference internal" href="#stingray.StingrayObject.add"><code class="docutils literal notranslate"><span class="pre">StingrayObject.add()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.apply_mask"><code class="docutils literal notranslate"><span class="pre">StingrayObject.apply_mask()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.array_attrs"><code class="docutils literal notranslate"><span class="pre">StingrayObject.array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.data_attributes"><code class="docutils literal notranslate"><span class="pre">StingrayObject.data_attributes()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.dict"><code class="docutils literal notranslate"><span class="pre">StingrayObject.dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.from_astropy_table"><code class="docutils literal notranslate"><span class="pre">StingrayObject.from_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.from_pandas"><code class="docutils literal notranslate"><span class="pre">StingrayObject.from_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.from_xarray"><code class="docutils literal notranslate"><span class="pre">StingrayObject.from_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.get_meta_dict"><code class="docutils literal notranslate"><span class="pre">StingrayObject.get_meta_dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.internal_array_attrs"><code class="docutils literal notranslate"><span class="pre">StingrayObject.internal_array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.meta_attrs"><code class="docutils literal notranslate"><span class="pre">StingrayObject.meta_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.pretty_print"><code class="docutils literal notranslate"><span class="pre">StingrayObject.pretty_print()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.read"><code class="docutils literal notranslate"><span class="pre">StingrayObject.read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.sub"><code class="docutils literal notranslate"><span class="pre">StingrayObject.sub()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.to_astropy_table"><code class="docutils literal notranslate"><span class="pre">StingrayObject.to_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.to_pandas"><code class="docutils literal notranslate"><span class="pre">StingrayObject.to_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.to_xarray"><code class="docutils literal notranslate"><span class="pre">StingrayObject.to_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayObject.write"><code class="docutils literal notranslate"><span class="pre">StingrayObject.write()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#data-classes">Data Classes</a><ul>
<li><a class="reference internal" href="#stingraytimeseries">StingrayTimeseries</a><ul>
<li><a class="reference internal" href="#stingray.StingrayTimeseries"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries</span></code></a><ul>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.analyze_by_gti"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.analyze_by_gti()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.analyze_segments"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.analyze_segments()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.apply_gtis"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.apply_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.change_mjdref"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.change_mjdref()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.concatenate"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.concatenate()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.estimate_segment_size"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.estimate_segment_size()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.exposure"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.exposure</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.fill_bad_time_intervals"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.fill_bad_time_intervals()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.from_astropy_timeseries"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.from_astropy_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.join"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.join()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.plot"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.plot()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.rebin"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.rebin()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.shift"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.shift()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.sort"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.sort()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.split_by_gti"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.split_by_gti()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.to_astropy_timeseries"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.to_astropy_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.StingrayTimeseries.truncate"><code class="docutils literal notranslate"><span class="pre">StingrayTimeseries.truncate()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#lightcurve">Lightcurve</a><ul>
<li><a class="reference internal" href="#stingray.Lightcurve"><code class="docutils literal notranslate"><span class="pre">Lightcurve</span></code></a><ul>
<li><a class="reference internal" href="#stingray.Lightcurve.analyze_lc_chunks"><code class="docutils literal notranslate"><span class="pre">Lightcurve.analyze_lc_chunks()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.apply_gtis"><code class="docutils literal notranslate"><span class="pre">Lightcurve.apply_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.baseline"><code class="docutils literal notranslate"><span class="pre">Lightcurve.baseline()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.bexvar"><code class="docutils literal notranslate"><span class="pre">Lightcurve.bexvar()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.check_lightcurve"><code class="docutils literal notranslate"><span class="pre">Lightcurve.check_lightcurve()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.estimate_chunk_length"><code class="docutils literal notranslate"><span class="pre">Lightcurve.estimate_chunk_length()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.estimate_segment_size"><code class="docutils literal notranslate"><span class="pre">Lightcurve.estimate_segment_size()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.from_astropy_table"><code class="docutils literal notranslate"><span class="pre">Lightcurve.from_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.from_astropy_timeseries"><code class="docutils literal notranslate"><span class="pre">Lightcurve.from_astropy_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.from_lightkurve"><code class="docutils literal notranslate"><span class="pre">Lightcurve.from_lightkurve()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.join"><code class="docutils literal notranslate"><span class="pre">Lightcurve.join()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.make_lightcurve"><code class="docutils literal notranslate"><span class="pre">Lightcurve.make_lightcurve()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.plot"><code class="docutils literal notranslate"><span class="pre">Lightcurve.plot()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.read"><code class="docutils literal notranslate"><span class="pre">Lightcurve.read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.rebin"><code class="docutils literal notranslate"><span class="pre">Lightcurve.rebin()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.sort"><code class="docutils literal notranslate"><span class="pre">Lightcurve.sort()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.sort_counts"><code class="docutils literal notranslate"><span class="pre">Lightcurve.sort_counts()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.split"><code class="docutils literal notranslate"><span class="pre">Lightcurve.split()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.to_astropy_table"><code class="docutils literal notranslate"><span class="pre">Lightcurve.to_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.to_astropy_timeseries"><code class="docutils literal notranslate"><span class="pre">Lightcurve.to_astropy_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.to_lightkurve"><code class="docutils literal notranslate"><span class="pre">Lightcurve.to_lightkurve()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Lightcurve.truncate"><code class="docutils literal notranslate"><span class="pre">Lightcurve.truncate()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#eventlist">EventList</a><ul>
<li><a class="reference internal" href="#stingray.events.EventList"><code class="docutils literal notranslate"><span class="pre">EventList</span></code></a><ul>
<li><a class="reference internal" href="#stingray.events.EventList.apply_deadtime"><code class="docutils literal notranslate"><span class="pre">EventList.apply_deadtime()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.convert_pi_to_energy"><code class="docutils literal notranslate"><span class="pre">EventList.convert_pi_to_energy()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.filter_energy_range"><code class="docutils literal notranslate"><span class="pre">EventList.filter_energy_range()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.from_lc"><code class="docutils literal notranslate"><span class="pre">EventList.from_lc()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.get_color_evolution"><code class="docutils literal notranslate"><span class="pre">EventList.get_color_evolution()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.get_energy_mask"><code class="docutils literal notranslate"><span class="pre">EventList.get_energy_mask()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.get_intensity_evolution"><code class="docutils literal notranslate"><span class="pre">EventList.get_intensity_evolution()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.join"><code class="docutils literal notranslate"><span class="pre">EventList.join()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.ncounts"><code class="docutils literal notranslate"><span class="pre">EventList.ncounts</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.read"><code class="docutils literal notranslate"><span class="pre">EventList.read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.simulate_energies"><code class="docutils literal notranslate"><span class="pre">EventList.simulate_energies()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.simulate_times"><code class="docutils literal notranslate"><span class="pre">EventList.simulate_times()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.sort"><code class="docutils literal notranslate"><span class="pre">EventList.sort()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.to_binned_timeseries"><code class="docutils literal notranslate"><span class="pre">EventList.to_binned_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.to_lc"><code class="docutils literal notranslate"><span class="pre">EventList.to_lc()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.to_lc_iter"><code class="docutils literal notranslate"><span class="pre">EventList.to_lc_iter()</span></code></a></li>
<li><a class="reference internal" href="#stingray.events.EventList.to_lc_list"><code class="docutils literal notranslate"><span class="pre">EventList.to_lc_list()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#fourier-products">Fourier Products</a><ul>
<li><a class="reference internal" href="#crossspectrum">Crossspectrum</a><ul>
<li><a class="reference internal" href="#stingray.Crossspectrum"><code class="docutils literal notranslate"><span class="pre">Crossspectrum</span></code></a><ul>
<li><a class="reference internal" href="#stingray.Crossspectrum.classical_significances"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.classical_significances()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.coherence"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.coherence()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.deadtime_correct"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.deadtime_correct()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.from_events"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.from_events()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.from_lc_iterable"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.from_lc_iterable()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.from_lightcurve"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.from_lightcurve()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.from_stingray_timeseries"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.from_stingray_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.from_time_array"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.from_time_array()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.initial_checks"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.initial_checks()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.phase_lag"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.phase_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.plot"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.plot()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.rebin"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.rebin()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.rebin_log"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.rebin_log()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.time_lag"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.time_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.to_norm"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.to_norm()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Crossspectrum.type"><code class="docutils literal notranslate"><span class="pre">Crossspectrum.type</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#coherence">Coherence</a><ul>
<li><a class="reference internal" href="#stingray.coherence"><code class="docutils literal notranslate"><span class="pre">coherence()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#powerspectrum">Powerspectrum</a><ul>
<li><a class="reference internal" href="#stingray.Powerspectrum"><code class="docutils literal notranslate"><span class="pre">Powerspectrum</span></code></a><ul>
<li><a class="reference internal" href="#stingray.Powerspectrum._initialize_empty"><code class="docutils literal notranslate"><span class="pre">Powerspectrum._initialize_empty()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum._initialize_from_any_input"><code class="docutils literal notranslate"><span class="pre">Powerspectrum._initialize_from_any_input()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum._normalize_crossspectrum"><code class="docutils literal notranslate"><span class="pre">Powerspectrum._normalize_crossspectrum()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum._operation_with_other_obj"><code class="docutils literal notranslate"><span class="pre">Powerspectrum._operation_with_other_obj()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum._rms_error"><code class="docutils literal notranslate"><span class="pre">Powerspectrum._rms_error()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.add"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.add()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.apply_mask"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.apply_mask()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.array_attrs"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.classical_significances"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.classical_significances()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.coherence"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.coherence()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.compute_rms"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.compute_rms()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.data_attributes"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.data_attributes()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.deadtime_correct"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.deadtime_correct()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.dict"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.from_astropy_table"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.from_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.from_events"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.from_events()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.from_lc_iterable"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.from_lc_iterable()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.from_lightcurve"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.from_lightcurve()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.from_pandas"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.from_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.from_stingray_timeseries"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.from_stingray_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.from_time_array"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.from_time_array()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.from_xarray"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.from_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.get_meta_dict"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.get_meta_dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.initial_checks"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.initial_checks()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.internal_array_attrs"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.internal_array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.meta_attrs"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.meta_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.modulation_upper_limit"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.modulation_upper_limit()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.phase_lag"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.phase_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.plot"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.plot()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.pretty_print"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.pretty_print()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.read"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.rebin"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.rebin()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.rebin_log"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.rebin_log()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.sub"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.sub()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.time_lag"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.time_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.to_astropy_table"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.to_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.to_norm"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.to_norm()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.to_pandas"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.to_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.to_xarray"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.to_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.type"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.type</span></code></a></li>
<li><a class="reference internal" href="#stingray.Powerspectrum.write"><code class="docutils literal notranslate"><span class="pre">Powerspectrum.write()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#averagedcrossspectrum">AveragedCrossspectrum</a><ul>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum</span></code></a><ul>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.add"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.add()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.apply_mask"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.apply_mask()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.array_attrs"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.classical_significances"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.classical_significances()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.coherence"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.coherence()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.data_attributes"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.data_attributes()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.deadtime_correct"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.deadtime_correct()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.dict"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.from_astropy_table"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.from_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.from_events"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.from_events()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.from_lc_iterable"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.from_lc_iterable()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.from_lightcurve"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.from_lightcurve()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.from_pandas"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.from_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.from_stingray_timeseries"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.from_stingray_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.from_time_array"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.from_time_array()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.from_xarray"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.from_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.get_meta_dict"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.get_meta_dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.initial_checks"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.initial_checks()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.internal_array_attrs"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.internal_array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.meta_attrs"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.meta_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.phase_lag"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.phase_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.plot"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.plot()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.pretty_print"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.pretty_print()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.read"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.rebin"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.rebin()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.rebin_log"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.rebin_log()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.sub"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.sub()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.time_lag"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.time_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.to_astropy_table"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.to_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.to_norm"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.to_norm()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.to_pandas"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.to_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.to_xarray"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.to_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.type"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.type</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedCrossspectrum.write"><code class="docutils literal notranslate"><span class="pre">AveragedCrossspectrum.write()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#averagedpowerspectrum">AveragedPowerspectrum</a><ul>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum</span></code></a><ul>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.add"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.add()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.apply_mask"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.apply_mask()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.array_attrs"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.classical_significances"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.classical_significances()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.coherence"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.coherence()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.compute_rms"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.compute_rms()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.data_attributes"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.data_attributes()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.deadtime_correct"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.deadtime_correct()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.dict"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.from_astropy_table"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.from_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.from_events"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.from_events()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.from_lc_iterable"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.from_lc_iterable()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.from_lightcurve"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.from_lightcurve()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.from_pandas"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.from_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.from_stingray_timeseries"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.from_stingray_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.from_time_array"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.from_time_array()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.from_xarray"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.from_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.get_meta_dict"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.get_meta_dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.initial_checks"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.initial_checks()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.internal_array_attrs"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.internal_array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.meta_attrs"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.meta_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.modulation_upper_limit"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.modulation_upper_limit()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.phase_lag"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.phase_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.plot"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.plot()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.pretty_print"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.pretty_print()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.read"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.rebin"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.rebin()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.rebin_log"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.rebin_log()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.sub"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.sub()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.time_lag"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.time_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.to_astropy_table"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.to_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.to_norm"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.to_norm()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.to_pandas"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.to_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.to_xarray"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.to_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.type"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.type</span></code></a></li>
<li><a class="reference internal" href="#stingray.AveragedPowerspectrum.write"><code class="docutils literal notranslate"><span class="pre">AveragedPowerspectrum.write()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#dynamical-powerspectrum">Dynamical Powerspectrum</a><ul>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum</span></code></a><ul>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.add"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.add()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.apply_mask"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.apply_mask()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.array_attrs"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.classical_significances"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.classical_significances()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.coherence"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.coherence()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.compute_rms"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.compute_rms()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.data_attributes"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.data_attributes()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.deadtime_correct"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.deadtime_correct()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.dict"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.from_astropy_table"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.from_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.from_events"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.from_events()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.from_lc_iterable"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.from_lc_iterable()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.from_lightcurve"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.from_lightcurve()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.from_pandas"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.from_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.from_stingray_timeseries"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.from_stingray_timeseries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.from_time_array"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.from_time_array()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.from_xarray"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.from_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.get_meta_dict"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.get_meta_dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.initial_checks"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.initial_checks()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.internal_array_attrs"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.internal_array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.meta_attrs"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.meta_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.phase_lag"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.phase_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.plot"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.plot()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.power_colors"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.power_colors()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.pretty_print"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.pretty_print()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.read"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.rebin"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.rebin()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.rebin_by_n_intervals"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.rebin_by_n_intervals()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.rebin_frequency"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.rebin_frequency()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.rebin_log"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.rebin_log()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.rebin_time"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.rebin_time()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.shift_and_add"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.shift_and_add()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.sub"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.sub()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.time_lag"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.time_lag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.to_astropy_table"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.to_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.to_norm"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.to_norm()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.to_pandas"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.to_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.to_xarray"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.to_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.trace_maximum"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.trace_maximum()</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.type"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.type</span></code></a></li>
<li><a class="reference internal" href="#stingray.DynamicalPowerspectrum.write"><code class="docutils literal notranslate"><span class="pre">DynamicalPowerspectrum.write()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#crosscorrelation">CrossCorrelation</a><ul>
<li><a class="reference internal" href="#stingray.CrossCorrelation"><code class="docutils literal notranslate"><span class="pre">CrossCorrelation</span></code></a><ul>
<li><a class="reference internal" href="#stingray.CrossCorrelation.cal_timeshift"><code class="docutils literal notranslate"><span class="pre">CrossCorrelation.cal_timeshift()</span></code></a></li>
<li><a class="reference internal" href="#stingray.CrossCorrelation.plot"><code class="docutils literal notranslate"><span class="pre">CrossCorrelation.plot()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#autocorrelation">AutoCorrelation</a><ul>
<li><a class="reference internal" href="#stingray.AutoCorrelation"><code class="docutils literal notranslate"><span class="pre">AutoCorrelation</span></code></a><ul>
<li><a class="reference internal" href="#stingray.AutoCorrelation.cal_timeshift"><code class="docutils literal notranslate"><span class="pre">AutoCorrelation.cal_timeshift()</span></code></a></li>
<li><a class="reference internal" href="#stingray.AutoCorrelation.plot"><code class="docutils literal notranslate"><span class="pre">AutoCorrelation.plot()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-stingray.deadtime.fad">Dead-Time Corrections</a><ul>
<li><a class="reference internal" href="#stingray.deadtime.fad.FAD"><code class="docutils literal notranslate"><span class="pre">FAD()</span></code></a></li>
<li><a class="reference internal" href="#stingray.deadtime.fad.calculate_FAD_correction"><code class="docutils literal notranslate"><span class="pre">calculate_FAD_correction()</span></code></a></li>
<li><a class="reference internal" href="#stingray.deadtime.fad.get_periodograms_from_FAD_results"><code class="docutils literal notranslate"><span class="pre">get_periodograms_from_FAD_results()</span></code></a></li>
<li><a class="reference internal" href="#stingray.deadtime.model.check_A"><code class="docutils literal notranslate"><span class="pre">check_A()</span></code></a></li>
<li><a class="reference internal" href="#stingray.deadtime.model.check_B"><code class="docutils literal notranslate"><span class="pre">check_B()</span></code></a></li>
<li><a class="reference internal" href="#stingray.deadtime.model.non_paralyzable_dead_time_model"><code class="docutils literal notranslate"><span class="pre">non_paralyzable_dead_time_model()</span></code></a></li>
<li><a class="reference internal" href="#stingray.deadtime.model.pds_model_zhang"><code class="docutils literal notranslate"><span class="pre">pds_model_zhang()</span></code></a></li>
<li><a class="reference internal" href="#stingray.deadtime.model.r_det"><code class="docutils literal notranslate"><span class="pre">r_det()</span></code></a></li>
<li><a class="reference internal" href="#stingray.deadtime.model.r_in"><code class="docutils literal notranslate"><span class="pre">r_in()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#higher-order-fourier-and-spectral-timing-products">Higher-Order Fourier and Spectral Timing Products</a><ul>
<li><a class="reference internal" href="#bispectrum">Bispectrum</a><ul>
<li><a class="reference internal" href="#stingray.bispectrum.Bispectrum"><code class="docutils literal notranslate"><span class="pre">Bispectrum</span></code></a><ul>
<li><a class="reference internal" href="#stingray.bispectrum.Bispectrum.plot_cum3"><code class="docutils literal notranslate"><span class="pre">Bispectrum.plot_cum3()</span></code></a></li>
<li><a class="reference internal" href="#stingray.bispectrum.Bispectrum.plot_mag"><code class="docutils literal notranslate"><span class="pre">Bispectrum.plot_mag()</span></code></a></li>
<li><a class="reference internal" href="#stingray.bispectrum.Bispectrum.plot_phase"><code class="docutils literal notranslate"><span class="pre">Bispectrum.plot_phase()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#covariancespectrum">Covariancespectrum</a><ul>
<li><a class="reference internal" href="#stingray.Covariancespectrum"><code class="docutils literal notranslate"><span class="pre">Covariancespectrum</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#averagedcovariancespectrum">AveragedCovariancespectrum</a><ul>
<li><a class="reference internal" href="#stingray.AveragedCovariancespectrum"><code class="docutils literal notranslate"><span class="pre">AveragedCovariancespectrum</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#varenergyspectrum">VarEnergySpectrum</a><ul>
<li><a class="reference internal" href="#stingray.varenergyspectrum.VarEnergySpectrum"><code class="docutils literal notranslate"><span class="pre">VarEnergySpectrum</span></code></a><ul>
<li><a class="reference internal" href="#stingray.varenergyspectrum.VarEnergySpectrum.energy"><code class="docutils literal notranslate"><span class="pre">VarEnergySpectrum.energy</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.VarEnergySpectrum.from_astropy_table"><code class="docutils literal notranslate"><span class="pre">VarEnergySpectrum.from_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.VarEnergySpectrum.from_pandas"><code class="docutils literal notranslate"><span class="pre">VarEnergySpectrum.from_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.VarEnergySpectrum.from_xarray"><code class="docutils literal notranslate"><span class="pre">VarEnergySpectrum.from_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.VarEnergySpectrum.main_array_attr"><code class="docutils literal notranslate"><span class="pre">VarEnergySpectrum.main_array_attr</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rmsenergyspectrum">RmsEnergySpectrum</a><ul>
<li><a class="reference internal" href="#stingray.varenergyspectrum.RmsEnergySpectrum"><code class="docutils literal notranslate"><span class="pre">RmsEnergySpectrum</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#lagenergyspectrum">LagEnergySpectrum</a><ul>
<li><a class="reference internal" href="#stingray.varenergyspectrum.LagEnergySpectrum"><code class="docutils literal notranslate"><span class="pre">LagEnergySpectrum</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#excessvariancespectrum">ExcessVarianceSpectrum</a><ul>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum</span></code></a><ul>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.add"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.add()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.apply_mask"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.apply_mask()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.array_attrs"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.data_attributes"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.data_attributes()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.dict"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.energy"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.energy</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.from_astropy_table"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.from_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.from_pandas"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.from_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.from_xarray"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.from_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.get_meta_dict"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.get_meta_dict()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.internal_array_attrs"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.internal_array_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.main_array_attr"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.main_array_attr</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.meta_attrs"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.meta_attrs()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.pretty_print"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.pretty_print()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.read"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.sub"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.sub()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.to_astropy_table"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.to_astropy_table()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.to_pandas"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.to_pandas()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.to_xarray"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.to_xarray()</span></code></a></li>
<li><a class="reference internal" href="#stingray.varenergyspectrum.ExcessVarianceSpectrum.write"><code class="docutils literal notranslate"><span class="pre">ExcessVarianceSpectrum.write()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#utilities">Utilities</a><ul>
<li><a class="reference internal" href="#module-stingray.stats">Statistical Functions</a><ul>
<li><a class="reference internal" href="#stingray.stats.a_from_pf"><code class="docutils literal notranslate"><span class="pre">a_from_pf()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.a_from_ssig"><code class="docutils literal notranslate"><span class="pre">a_from_ssig()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.amplitude_upper_limit"><code class="docutils literal notranslate"><span class="pre">amplitude_upper_limit()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.classical_pvalue"><code class="docutils literal notranslate"><span class="pre">classical_pvalue()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.equivalent_gaussian_Nsigma"><code class="docutils literal notranslate"><span class="pre">equivalent_gaussian_Nsigma()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.fold_detection_level"><code class="docutils literal notranslate"><span class="pre">fold_detection_level()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.fold_profile_logprobability"><code class="docutils literal notranslate"><span class="pre">fold_profile_logprobability()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.fold_profile_probability"><code class="docutils literal notranslate"><span class="pre">fold_profile_probability()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.p_multitrial_from_single_trial"><code class="docutils literal notranslate"><span class="pre">p_multitrial_from_single_trial()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.p_single_trial_from_p_multitrial"><code class="docutils literal notranslate"><span class="pre">p_single_trial_from_p_multitrial()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.pds_detection_level"><code class="docutils literal notranslate"><span class="pre">pds_detection_level()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.pds_probability"><code class="docutils literal notranslate"><span class="pre">pds_probability()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.pf_from_a"><code class="docutils literal notranslate"><span class="pre">pf_from_a()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.pf_from_ssig"><code class="docutils literal notranslate"><span class="pre">pf_from_ssig()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.pf_upper_limit"><code class="docutils literal notranslate"><span class="pre">pf_upper_limit()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.phase_dispersion_detection_level"><code class="docutils literal notranslate"><span class="pre">phase_dispersion_detection_level()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.phase_dispersion_logprobability"><code class="docutils literal notranslate"><span class="pre">phase_dispersion_logprobability()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.phase_dispersion_probability"><code class="docutils literal notranslate"><span class="pre">phase_dispersion_probability()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.power_confidence_limits"><code class="docutils literal notranslate"><span class="pre">power_confidence_limits()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.power_upper_limit"><code class="docutils literal notranslate"><span class="pre">power_upper_limit()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.ssig_from_a"><code class="docutils literal notranslate"><span class="pre">ssig_from_a()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.ssig_from_pf"><code class="docutils literal notranslate"><span class="pre">ssig_from_pf()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.z2_n_detection_level"><code class="docutils literal notranslate"><span class="pre">z2_n_detection_level()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.z2_n_logprobability"><code class="docutils literal notranslate"><span class="pre">z2_n_logprobability()</span></code></a></li>
<li><a class="reference internal" href="#stingray.stats.z2_n_probability"><code class="docutils literal notranslate"><span class="pre">z2_n_probability()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-stingray.gti">GTI Functionality</a><ul>
<li><a class="reference internal" href="#stingray.gti.append_gtis"><code class="docutils literal notranslate"><span class="pre">append_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.bin_intervals_from_gtis"><code class="docutils literal notranslate"><span class="pre">bin_intervals_from_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.check_gtis"><code class="docutils literal notranslate"><span class="pre">check_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.check_separate"><code class="docutils literal notranslate"><span class="pre">check_separate()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.create_gti_from_condition"><code class="docutils literal notranslate"><span class="pre">create_gti_from_condition()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.create_gti_mask"><code class="docutils literal notranslate"><span class="pre">create_gti_mask()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.create_gti_mask_complete"><code class="docutils literal notranslate"><span class="pre">create_gti_mask_complete()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.create_gti_mask_jit"><code class="docutils literal notranslate"><span class="pre">create_gti_mask_jit()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.cross_gtis"><code class="docutils literal notranslate"><span class="pre">cross_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.cross_two_gtis"><code class="docutils literal notranslate"><span class="pre">cross_two_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.generate_indices_of_gti_boundaries"><code class="docutils literal notranslate"><span class="pre">generate_indices_of_gti_boundaries()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.generate_indices_of_segment_boundaries_binned"><code class="docutils literal notranslate"><span class="pre">generate_indices_of_segment_boundaries_binned()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.generate_indices_of_segment_boundaries_unbinned"><code class="docutils literal notranslate"><span class="pre">generate_indices_of_segment_boundaries_unbinned()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.get_btis"><code class="docutils literal notranslate"><span class="pre">get_btis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.get_gti_extensions_from_pattern"><code class="docutils literal notranslate"><span class="pre">get_gti_extensions_from_pattern()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.get_gti_from_all_extensions"><code class="docutils literal notranslate"><span class="pre">get_gti_from_all_extensions()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.get_gti_from_hdu"><code class="docutils literal notranslate"><span class="pre">get_gti_from_hdu()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.get_gti_lengths"><code class="docutils literal notranslate"><span class="pre">get_gti_lengths()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.get_total_gti_length"><code class="docutils literal notranslate"><span class="pre">get_total_gti_length()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.gti_border_bins"><code class="docutils literal notranslate"><span class="pre">gti_border_bins()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.join_gtis"><code class="docutils literal notranslate"><span class="pre">join_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.load_gtis"><code class="docutils literal notranslate"><span class="pre">load_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.gti.time_intervals_from_gtis"><code class="docutils literal notranslate"><span class="pre">time_intervals_from_gtis()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-stingray.io">I/O Functionality</a><ul>
<li><a class="reference internal" href="#stingray.io.common_name"><code class="docutils literal notranslate"><span class="pre">common_name()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.get_file_extension"><code class="docutils literal notranslate"><span class="pre">get_file_extension()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.get_key_from_mission_info"><code class="docutils literal notranslate"><span class="pre">get_key_from_mission_info()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.high_precision_keyword_read"><code class="docutils literal notranslate"><span class="pre">high_precision_keyword_read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.lcurve_from_fits"><code class="docutils literal notranslate"><span class="pre">lcurve_from_fits()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.load_events_and_gtis"><code class="docutils literal notranslate"><span class="pre">load_events_and_gtis()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.mkdir_p"><code class="docutils literal notranslate"><span class="pre">mkdir_p()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.pi_to_energy"><code class="docutils literal notranslate"><span class="pre">pi_to_energy()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.read_header_key"><code class="docutils literal notranslate"><span class="pre">read_header_key()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.read_rmf"><code class="docutils literal notranslate"><span class="pre">read_rmf()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.ref_mjd"><code class="docutils literal notranslate"><span class="pre">ref_mjd()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.savefig"><code class="docutils literal notranslate"><span class="pre">savefig()</span></code></a></li>
<li><a class="reference internal" href="#stingray.io.split_numbers"><code class="docutils literal notranslate"><span class="pre">split_numbers()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-stingray.mission_support.missions">Mission-specific I/O</a><ul>
<li><a class="reference internal" href="#stingray.mission_support.missions.get_rough_conversion_function"><code class="docutils literal notranslate"><span class="pre">get_rough_conversion_function()</span></code></a></li>
<li><a class="reference internal" href="#stingray.mission_support.missions.mission_specific_event_interpretation"><code class="docutils literal notranslate"><span class="pre">mission_specific_event_interpretation()</span></code></a></li>
<li><a class="reference internal" href="#stingray.mission_support.missions.read_mission_info"><code class="docutils literal notranslate"><span class="pre">read_mission_info()</span></code></a></li>
<li><a class="reference internal" href="#stingray.mission_support.missions.rough_calibration"><code class="docutils literal notranslate"><span class="pre">rough_calibration()</span></code></a></li>
<li><a class="reference internal" href="#stingray.mission_support.rxte.pca_calibration_func"><code class="docutils literal notranslate"><span class="pre">pca_calibration_func()</span></code></a></li>
<li><a class="reference internal" href="#stingray.mission_support.rxte.rxte_calibration_func"><code class="docutils literal notranslate"><span class="pre">rxte_calibration_func()</span></code></a></li>
<li><a class="reference internal" href="#stingray.mission_support.rxte.rxte_pca_event_file_interpretation"><code class="docutils literal notranslate"><span class="pre">rxte_pca_event_file_interpretation()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-stingray.utils">Other Utility Functions</a><ul>
<li><a class="reference internal" href="#stingray.utils.baseline_als"><code class="docutils literal notranslate"><span class="pre">baseline_als()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.check_isallfinite"><code class="docutils literal notranslate"><span class="pre">check_isallfinite()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.contiguous_regions"><code class="docutils literal notranslate"><span class="pre">contiguous_regions()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.create_window"><code class="docutils literal notranslate"><span class="pre">create_window()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.excess_variance"><code class="docutils literal notranslate"><span class="pre">excess_variance()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.find_nearest"><code class="docutils literal notranslate"><span class="pre">find_nearest()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.get_random_state"><code class="docutils literal notranslate"><span class="pre">get_random_state()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.heaviside"><code class="docutils literal notranslate"><span class="pre">heaviside()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.is_int"><code class="docutils literal notranslate"><span class="pre">is_int()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.is_iterable"><code class="docutils literal notranslate"><span class="pre">is_iterable()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.is_string"><code class="docutils literal notranslate"><span class="pre">is_string()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.look_for_array_in_array"><code class="docutils literal notranslate"><span class="pre">look_for_array_in_array()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.make_dictionary_lowercase"><code class="docutils literal notranslate"><span class="pre">make_dictionary_lowercase()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.nearest_power_of_two"><code class="docutils literal notranslate"><span class="pre">nearest_power_of_two()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.optimal_bin_time"><code class="docutils literal notranslate"><span class="pre">optimal_bin_time()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.order_list_of_arrays"><code class="docutils literal notranslate"><span class="pre">order_list_of_arrays()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.poisson_symmetrical_errors"><code class="docutils literal notranslate"><span class="pre">poisson_symmetrical_errors()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.rebin_data"><code class="docutils literal notranslate"><span class="pre">rebin_data()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.rebin_data_log"><code class="docutils literal notranslate"><span class="pre">rebin_data_log()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.simon"><code class="docutils literal notranslate"><span class="pre">simon()</span></code></a></li>
<li><a class="reference internal" href="#stingray.utils.standard_error"><code class="docutils literal notranslate"><span class="pre">standard_error()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#modeling">Modeling</a><ul>
<li><a class="reference internal" href="#log-likelihood-classes">Log-Likelihood Classes</a><ul>
<li><a class="reference internal" href="#stingray.modeling.LogLikelihood"><code class="docutils literal notranslate"><span class="pre">LogLikelihood</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.LogLikelihood.evaluate"><code class="docutils literal notranslate"><span class="pre">LogLikelihood.evaluate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.GaussianLogLikelihood"><code class="docutils literal notranslate"><span class="pre">GaussianLogLikelihood</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.GaussianLogLikelihood.evaluate"><code class="docutils literal notranslate"><span class="pre">GaussianLogLikelihood.evaluate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.PoissonLogLikelihood"><code class="docutils literal notranslate"><span class="pre">PoissonLogLikelihood</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.PoissonLogLikelihood.evaluate"><code class="docutils literal notranslate"><span class="pre">PoissonLogLikelihood.evaluate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.PSDLogLikelihood"><code class="docutils literal notranslate"><span class="pre">PSDLogLikelihood</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.PSDLogLikelihood.evaluate"><code class="docutils literal notranslate"><span class="pre">PSDLogLikelihood.evaluate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.LaplaceLogLikelihood"><code class="docutils literal notranslate"><span class="pre">LaplaceLogLikelihood</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.LaplaceLogLikelihood.evaluate"><code class="docutils literal notranslate"><span class="pre">LaplaceLogLikelihood.evaluate()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#posterior-classes">Posterior Classes</a><ul>
<li><a class="reference internal" href="#stingray.modeling.Posterior"><code class="docutils literal notranslate"><span class="pre">Posterior</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.Posterior.logposterior"><code class="docutils literal notranslate"><span class="pre">Posterior.logposterior()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.GaussianPosterior"><code class="docutils literal notranslate"><span class="pre">GaussianPosterior</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.GaussianPosterior.logposterior"><code class="docutils literal notranslate"><span class="pre">GaussianPosterior.logposterior()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.PoissonPosterior"><code class="docutils literal notranslate"><span class="pre">PoissonPosterior</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.PoissonPosterior.logposterior"><code class="docutils literal notranslate"><span class="pre">PoissonPosterior.logposterior()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.PSDPosterior"><code class="docutils literal notranslate"><span class="pre">PSDPosterior</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.PSDPosterior.logposterior"><code class="docutils literal notranslate"><span class="pre">PSDPosterior.logposterior()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.LaplacePosterior"><code class="docutils literal notranslate"><span class="pre">LaplacePosterior</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.LaplacePosterior.logposterior"><code class="docutils literal notranslate"><span class="pre">LaplacePosterior.logposterior()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#parameter-estimation-classes">Parameter Estimation Classes</a><ul>
<li><a class="reference internal" href="#stingray.modeling.ParameterEstimation"><code class="docutils literal notranslate"><span class="pre">ParameterEstimation</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.ParameterEstimation.calibrate_lrt"><code class="docutils literal notranslate"><span class="pre">ParameterEstimation.calibrate_lrt()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.ParameterEstimation.compute_lrt"><code class="docutils literal notranslate"><span class="pre">ParameterEstimation.compute_lrt()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.ParameterEstimation.fit"><code class="docutils literal notranslate"><span class="pre">ParameterEstimation.fit()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.ParameterEstimation.sample"><code class="docutils literal notranslate"><span class="pre">ParameterEstimation.sample()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.ParameterEstimation.simulate_lrts"><code class="docutils literal notranslate"><span class="pre">ParameterEstimation.simulate_lrts()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.PSDParEst"><code class="docutils literal notranslate"><span class="pre">PSDParEst</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.PSDParEst.calibrate_highest_outlier"><code class="docutils literal notranslate"><span class="pre">PSDParEst.calibrate_highest_outlier()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.PSDParEst.calibrate_lrt"><code class="docutils literal notranslate"><span class="pre">PSDParEst.calibrate_lrt()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.PSDParEst.compute_lrt"><code class="docutils literal notranslate"><span class="pre">PSDParEst.compute_lrt()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.PSDParEst.fit"><code class="docutils literal notranslate"><span class="pre">PSDParEst.fit()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.PSDParEst.plotfits"><code class="docutils literal notranslate"><span class="pre">PSDParEst.plotfits()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.PSDParEst.sample"><code class="docutils literal notranslate"><span class="pre">PSDParEst.sample()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.PSDParEst.simulate_highest_outlier"><code class="docutils literal notranslate"><span class="pre">PSDParEst.simulate_highest_outlier()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.PSDParEst.simulate_lrts"><code class="docutils literal notranslate"><span class="pre">PSDParEst.simulate_lrts()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#auxiliary-classes">Auxiliary Classes</a><ul>
<li><a class="reference internal" href="#stingray.modeling.OptimizationResults"><code class="docutils literal notranslate"><span class="pre">OptimizationResults</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.OptimizationResults._compute_covariance"><code class="docutils literal notranslate"><span class="pre">OptimizationResults._compute_covariance()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.OptimizationResults._compute_criteria"><code class="docutils literal notranslate"><span class="pre">OptimizationResults._compute_criteria()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.OptimizationResults._compute_model"><code class="docutils literal notranslate"><span class="pre">OptimizationResults._compute_model()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.OptimizationResults._compute_statistics"><code class="docutils literal notranslate"><span class="pre">OptimizationResults._compute_statistics()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.OptimizationResults.print_summary"><code class="docutils literal notranslate"><span class="pre">OptimizationResults.print_summary()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#stingray.modeling.SamplingResults"><code class="docutils literal notranslate"><span class="pre">SamplingResults</span></code></a><ul>
<li><a class="reference internal" href="#stingray.modeling.SamplingResults._check_convergence"><code class="docutils literal notranslate"><span class="pre">SamplingResults._check_convergence()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.SamplingResults._compute_rhat"><code class="docutils literal notranslate"><span class="pre">SamplingResults._compute_rhat()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.SamplingResults._infer"><code class="docutils literal notranslate"><span class="pre">SamplingResults._infer()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.SamplingResults.plot_results"><code class="docutils literal notranslate"><span class="pre">SamplingResults.plot_results()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.SamplingResults.print_results"><code class="docutils literal notranslate"><span class="pre">SamplingResults.print_results()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#convenience-functions">Convenience Functions</a><ul>
<li><a class="reference internal" href="#stingray.modeling.set_logprior"><code class="docutils literal notranslate"><span class="pre">set_logprior()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.scripts.fit_crossspectrum"><code class="docutils literal notranslate"><span class="pre">fit_crossspectrum()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.scripts.fit_lorentzians"><code class="docutils literal notranslate"><span class="pre">fit_lorentzians()</span></code></a></li>
<li><a class="reference internal" href="#stingray.modeling.scripts.fit_powerspectrum"><code class="docutils literal notranslate"><span class="pre">fit_powerspectrum()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#pulsar">Pulsar</a><ul>
<li><a class="reference internal" href="#stingray.pulse.SincSquareModel"><code class="docutils literal notranslate"><span class="pre">SincSquareModel</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.ef_profile_stat"><code class="docutils literal notranslate"><span class="pre">ef_profile_stat()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.epoch_folding_search"><code class="docutils literal notranslate"><span class="pre">epoch_folding_search()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.fftfit"><code class="docutils literal notranslate"><span class="pre">fftfit()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.fit_gaussian"><code class="docutils literal notranslate"><span class="pre">fit_gaussian()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.fit_sinc"><code class="docutils literal notranslate"><span class="pre">fit_sinc()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.fold_events"><code class="docutils literal notranslate"><span class="pre">fold_events()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.get_TOA"><code class="docutils literal notranslate"><span class="pre">get_TOA()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.get_orbital_correction_from_ephemeris_file"><code class="docutils literal notranslate"><span class="pre">get_orbital_correction_from_ephemeris_file()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.htest"><code class="docutils literal notranslate"><span class="pre">htest()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.p_to_f"><code class="docutils literal notranslate"><span class="pre">p_to_f()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.pdm_profile_stat"><code class="docutils literal notranslate"><span class="pre">pdm_profile_stat()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.phase_dispersion_search"><code class="docutils literal notranslate"><span class="pre">phase_dispersion_search()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.phase_exposure"><code class="docutils literal notranslate"><span class="pre">phase_exposure()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.phaseogram"><code class="docutils literal notranslate"><span class="pre">phaseogram()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.plot_phaseogram"><code class="docutils literal notranslate"><span class="pre">plot_phaseogram()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.plot_profile"><code class="docutils literal notranslate"><span class="pre">plot_profile()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.pulse_phase"><code class="docutils literal notranslate"><span class="pre">pulse_phase()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.search_best_peaks"><code class="docutils literal notranslate"><span class="pre">search_best_peaks()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.sinc_square_deriv"><code class="docutils literal notranslate"><span class="pre">sinc_square_deriv()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.sinc_square_model"><code class="docutils literal notranslate"><span class="pre">sinc_square_model()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.test"><code class="docutils literal notranslate"><span class="pre">test()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.z_n"><code class="docutils literal notranslate"><span class="pre">z_n()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.z_n_binned_events"><code class="docutils literal notranslate"><span class="pre">z_n_binned_events()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.z_n_binned_events_all"><code class="docutils literal notranslate"><span class="pre">z_n_binned_events_all()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.z_n_events"><code class="docutils literal notranslate"><span class="pre">z_n_events()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.z_n_events_all"><code class="docutils literal notranslate"><span class="pre">z_n_events_all()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.z_n_gauss"><code class="docutils literal notranslate"><span class="pre">z_n_gauss()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.z_n_gauss_all"><code class="docutils literal notranslate"><span class="pre">z_n_gauss_all()</span></code></a></li>
<li><a class="reference internal" href="#stingray.pulse.z_n_search"><code class="docutils literal notranslate"><span class="pre">z_n_search()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#simulator">Simulator</a><ul>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator"><code class="docutils literal notranslate"><span class="pre">Simulator</span></code></a><ul>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.count_channels"><code class="docutils literal notranslate"><span class="pre">Simulator.count_channels()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.delete_channel"><code class="docutils literal notranslate"><span class="pre">Simulator.delete_channel()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.delete_channels"><code class="docutils literal notranslate"><span class="pre">Simulator.delete_channels()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.get_all_channels"><code class="docutils literal notranslate"><span class="pre">Simulator.get_all_channels()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.get_channel"><code class="docutils literal notranslate"><span class="pre">Simulator.get_channel()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.get_channels"><code class="docutils literal notranslate"><span class="pre">Simulator.get_channels()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.powerspectrum"><code class="docutils literal notranslate"><span class="pre">Simulator.powerspectrum()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.read"><code class="docutils literal notranslate"><span class="pre">Simulator.read()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.relativistic_ir"><code class="docutils literal notranslate"><span class="pre">Simulator.relativistic_ir()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.simple_ir"><code class="docutils literal notranslate"><span class="pre">Simulator.simple_ir()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.simulate"><code class="docutils literal notranslate"><span class="pre">Simulator.simulate()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.simulate_channel"><code class="docutils literal notranslate"><span class="pre">Simulator.simulate_channel()</span></code></a></li>
<li><a class="reference internal" href="#stingray.simulator.simulator.Simulator.write"><code class="docutils literal notranslate"><span class="pre">Simulator.write()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#exceptions">Exceptions</a><ul>
<li><a class="reference internal" href="#stingray.exceptions.StingrayError"><code class="docutils literal notranslate"><span class="pre">StingrayError</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right">
    <a href="_sources/api.rst.txt"
       rel="nofollow">Page Source</a> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, [{&#39;name&#39;: &#39;Stingray Developers&#39;, &#39;email&#39;: &#39;spectraltiming-stingray@googlegroups.com&#39;}].<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 8.0.2. &nbsp;
    Last built 09 Oct 2024. <br/>
  </p>
</footer>
  </body>
</html>