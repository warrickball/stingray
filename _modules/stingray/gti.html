<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>stingray.gti &#8212; stingray v</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-astropy.css?v=9d21690f" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=2afd17ea" />
    
    <script src="../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <link rel="icon" href="../../_static/stingray_logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../index.html">stingray v</a>
	 &#187;
      </li>
      <li><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for stingray.gti</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">contiguous_regions</span><span class="p">,</span> <span class="n">jit</span><span class="p">,</span> <span class="n">HAS_NUMBA</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">assign_value_if_none</span><span class="p">,</span> <span class="n">apply_function_if_none</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">check_iterables_close</span><span class="p">,</span> <span class="n">is_sorted</span>
<span class="kn">from</span> <span class="nn">stingray.exceptions</span> <span class="kn">import</span> <span class="n">StingrayError</span>
<span class="kn">from</span> <span class="nn">stingray.loggingconfig</span> <span class="kn">import</span> <span class="n">setup_logger</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;load_gtis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;check_gtis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_gti_mask_jit&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_gti_mask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_gti_mask_complete&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_gti_from_condition&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cross_two_gtis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cross_gtis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_btis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_gti_extensions_from_pattern&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_gti_from_all_extensions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_gti_from_hdu&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_gti_lengths&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_total_gti_length&quot;</span><span class="p">,</span>
    <span class="s2">&quot;check_separate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;append_gtis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;join_gtis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;generate_indices_of_gti_boundaries&quot;</span><span class="p">,</span>
    <span class="s2">&quot;time_intervals_from_gtis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;bin_intervals_from_gtis&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gti_border_bins&quot;</span><span class="p">,</span>
    <span class="s2">&quot;generate_indices_of_segment_boundaries_unbinned&quot;</span><span class="p">,</span>
    <span class="s2">&quot;generate_indices_of_segment_boundaries_binned&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">gti_len</span><span class="p">(</span><span class="n">gti</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated, will be removed in version 2.0. Use get_total_gti_length.&quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;This function is deprecated. Use get_total_gti_length &quot;</span> <span class="s2">&quot;instead&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">get_total_gti_length</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="n">minlen</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<div class="viewcode-block" id="get_gti_lengths">
<a class="viewcode-back" href="../../api.html#stingray.gti.get_gti_lengths">[docs]</a>
<span class="k">def</span> <span class="nf">get_gti_lengths</span><span class="p">(</span><span class="n">gti</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the length of each Good Time Interval.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti : [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        The list of good time intervals.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lengths : `np.ndarray`</span>
<span class="sd">        List of GTI lengths.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gti = [[0, 1000], [1000, 1001], [3000, 3020]]</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(get_gti_lengths(gti), [1000, 1, 20])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>



<div class="viewcode-block" id="get_total_gti_length">
<a class="viewcode-back" href="../../api.html#stingray.gti.get_total_gti_length">[docs]</a>
<span class="k">def</span> <span class="nf">get_total_gti_length</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="n">minlen</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the total exposure during Good Time Intervals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti : [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        The list of good time intervals.</span>
<span class="sd">    minlen : float</span>
<span class="sd">        Minimum GTI length to consider.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    length : float</span>
<span class="sd">        The total exposure during GTIs.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gti = [[0, 1000], [1000, 1001], [3000, 3020]]</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(get_total_gti_length(gti), 1021)</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(get_total_gti_length(gti, minlen=5), 1020)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="n">get_gti_lengths</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">lengths</span> <span class="o">&gt;=</span> <span class="n">minlen</span><span class="p">])</span></div>



<div class="viewcode-block" id="load_gtis">
<a class="viewcode-back" href="../../api.html#stingray.gti.load_gtis">[docs]</a>
<span class="k">def</span> <span class="nf">load_gtis</span><span class="p">(</span><span class="n">fits_file</span><span class="p">,</span> <span class="n">gtistring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load Good Time Intervals (GTIs) from ``HDU EVENTS`` of file ``fits_file``.</span>
<span class="sd">    File is expected to be in FITS format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fits_file : str</span>
<span class="sd">        File name and path for the FITS file with the GTIs to be loaded.</span>

<span class="sd">    gtistring : str</span>
<span class="sd">        If the name of the FITS extension with the GTIs is not ``GTI``, the</span>
<span class="sd">        alternative name can be set with this parameter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gti_list : list</span>
<span class="sd">        A list of GTI ``(start, stop)`` pairs extracted from the FITS file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gtistring</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">gtistring</span><span class="p">,</span> <span class="s2">&quot;GTI&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading GTIS from file </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fits_file</span><span class="p">)</span>
    <span class="n">lchdulist</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fits_file</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_missing_end</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">lchdulist</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="s2">&quot;warn&quot;</span><span class="p">)</span>

    <span class="n">gtitable</span> <span class="o">=</span> <span class="n">lchdulist</span><span class="p">[</span><span class="n">gtistring</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">gti_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gtitable</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;START&quot;</span><span class="p">),</span> <span class="n">gtitable</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s2">&quot;STOP&quot;</span><span class="p">))],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">lchdulist</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">gti_list</span></div>



<div class="viewcode-block" id="get_gti_extensions_from_pattern">
<a class="viewcode-back" href="../../api.html#stingray.gti.get_gti_extensions_from_pattern">[docs]</a>
<span class="k">def</span> <span class="nf">get_gti_extensions_from_pattern</span><span class="p">(</span><span class="n">lchdulist</span><span class="p">,</span> <span class="n">name_pattern</span><span class="o">=</span><span class="s2">&quot;GTI&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the GTI extensions that match a given pattern.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lchdulist: `:class:astropy.io.fits.HDUList` object</span>
<span class="sd">        The full content of a FITS file.</span>
<span class="sd">    name_pattern: str</span>
<span class="sd">        Pattern indicating all the GTI extensions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ext_list: list</span>
<span class="sd">        List of GTI extension numbers whose name matches the input pattern.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy.io import fits</span>
<span class="sd">    &gt;&gt;&gt; start = np.arange(0, 300, 100)</span>
<span class="sd">    &gt;&gt;&gt; stop = start + 50.</span>
<span class="sd">    &gt;&gt;&gt; s1 = fits.Column(name=&#39;START&#39;, array=start, format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s2 = fits.Column(name=&#39;STOP&#39;, array=stop, format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; hdu1 = fits.TableHDU.from_columns([s1, s2], name=&#39;GTI005XX&#39;)</span>
<span class="sd">    &gt;&gt;&gt; hdu2 = fits.TableHDU.from_columns([s1, s2], name=&#39;GTI00501&#39;)</span>
<span class="sd">    &gt;&gt;&gt; lchdulist = fits.HDUList([hdu1])</span>
<span class="sd">    &gt;&gt;&gt; gtiextn = get_gti_extensions_from_pattern(</span>
<span class="sd">    ...     lchdulist, name_pattern=&#39;GTI005[0-9]+&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(gtiextn, [1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hdunames</span> <span class="o">=</span> <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">lchdulist</span><span class="p">]</span>
    <span class="n">pattern_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;^&quot;</span> <span class="o">+</span> <span class="n">name_pattern</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span>
    <span class="n">gtiextn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">extname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hdunames</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pattern_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">extname</span><span class="p">):</span>
            <span class="n">gtiextn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gtiextn</span></div>



<span class="k">def</span> <span class="nf">hdu_contains_gti</span><span class="p">(</span><span class="n">hdu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test if a given FITS HDU contains a list of GTIs.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy.io import fits</span>
<span class="sd">    &gt;&gt;&gt; start = np.arange(0, 300, 100)</span>
<span class="sd">    &gt;&gt;&gt; stop = start + 50.</span>
<span class="sd">    &gt;&gt;&gt; s1 = fits.Column(name=&#39;START&#39;, array=start, format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s2 = fits.Column(name=&#39;STOP&#39;, array=stop, format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; hdu1 = fits.TableHDU.from_columns([s1, s2], name=&#39;BLABLA&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert hdu_contains_gti(hdu1)</span>
<span class="sd">    &gt;&gt;&gt; s2 = fits.Column(name=&#39;blabla&#39;, array=stop, format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; hdu1 = fits.TableHDU.from_columns([s1, s2], name=&#39;BLABLA&#39;)</span>
<span class="sd">    &gt;&gt;&gt; hdu_contains_gti(hdu1)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">colnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
    <span class="k">return</span> <span class="s2">&quot;start&quot;</span> <span class="ow">in</span> <span class="n">colnames</span> <span class="ow">and</span> <span class="s2">&quot;stop&quot;</span> <span class="ow">in</span> <span class="n">colnames</span>


<div class="viewcode-block" id="get_gti_from_hdu">
<a class="viewcode-back" href="../../api.html#stingray.gti.get_gti_from_hdu">[docs]</a>
<span class="k">def</span> <span class="nf">get_gti_from_hdu</span><span class="p">(</span><span class="n">gtihdu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the GTIs from a given FITS extension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gtihdu: `:class:astropy.io.fits.TableHDU` object</span>
<span class="sd">        The GTI HDU.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gti_list: [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        List of good time intervals.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy.io import fits</span>
<span class="sd">    &gt;&gt;&gt; start = np.arange(0, 300, 100)</span>
<span class="sd">    &gt;&gt;&gt; stop = start + 50.</span>
<span class="sd">    &gt;&gt;&gt; s1 = fits.Column(name=&#39;START&#39;, array=start, format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s2 = fits.Column(name=&#39;STOP&#39;, array=stop, format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; hdu1 = fits.TableHDU.from_columns([s1, s2], name=&#39;GTI00501&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gti = get_gti_from_hdu(hdu1)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(gti, [[0, 50], [100, 150], [200, 250]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gtitable</span> <span class="o">=</span> <span class="n">gtihdu</span><span class="o">.</span><span class="n">data</span>

    <span class="n">colnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gtitable</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="c1"># Default: NuSTAR: START, STOP. Otherwise, try RXTE: Start, Stop</span>
    <span class="k">if</span> <span class="s2">&quot;START&quot;</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
        <span class="n">startstr</span><span class="p">,</span> <span class="n">stopstr</span> <span class="o">=</span> <span class="s2">&quot;START&quot;</span><span class="p">,</span> <span class="s2">&quot;STOP&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">startstr</span><span class="p">,</span> <span class="n">stopstr</span> <span class="o">=</span> <span class="s2">&quot;Start&quot;</span><span class="p">,</span> <span class="s2">&quot;Stop&quot;</span>

    <span class="n">gtistart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gtitable</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">startstr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">)</span>
    <span class="n">gtistop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gtitable</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">stopstr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">)</span>
    <span class="n">gti_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">gtistart</span><span class="p">,</span> <span class="n">gtistop</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">gti_list</span></div>



<div class="viewcode-block" id="get_gti_from_all_extensions">
<a class="viewcode-back" href="../../api.html#stingray.gti.get_gti_from_all_extensions">[docs]</a>
<span class="k">def</span> <span class="nf">get_gti_from_all_extensions</span><span class="p">(</span><span class="n">lchdulist</span><span class="p">,</span> <span class="n">accepted_gtistrings</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;GTI&quot;</span><span class="p">],</span> <span class="n">det_numbers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intersect the GTIs from the all accepted extensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lchdulist: `:class:astropy.io.fits.HDUList` object</span>
<span class="sd">        The full content of a FITS file.</span>
<span class="sd">    accepted_gtistrings: list of str</span>
<span class="sd">        Base strings of GTI extensions. For missions adding the detector number</span>
<span class="sd">        to GTI extensions like, e.g., XMM and Chandra, this function</span>
<span class="sd">        automatically adds the detector number and looks for all matching</span>
<span class="sd">        GTI extensions (e.g. &quot;STDGTI&quot; will also retrieve &quot;STDGTI05&quot;; &quot;GTI0&quot;</span>
<span class="sd">        will also retrieve &quot;GTI00501&quot;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gti_list: [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        List of good time intervals, as the intersection of all matching GTIs.</span>
<span class="sd">        If there are two matching extensions, with GTIs [[0, 50], [100, 200]]</span>
<span class="sd">        and [[40, 70]] respectively, this function will return [[40, 50]].</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy.io import fits</span>
<span class="sd">    &gt;&gt;&gt; s1 = fits.Column(name=&#39;START&#39;, array=[0, 100, 200], format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s2 = fits.Column(name=&#39;STOP&#39;, array=[50, 150, 250], format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; hdu1 = fits.TableHDU.from_columns([s1, s2], name=&#39;GTI00501&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s1 = fits.Column(name=&#39;START&#39;, array=[200, 300], format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s2 = fits.Column(name=&#39;STOP&#39;, array=[250, 350], format=&#39;D&#39;)</span>
<span class="sd">    &gt;&gt;&gt; hdu2 = fits.TableHDU.from_columns([s1, s2], name=&#39;STDGTI05&#39;)</span>
<span class="sd">    &gt;&gt;&gt; lchdulist = fits.HDUList([hdu1, hdu2])</span>
<span class="sd">    &gt;&gt;&gt; gti = get_gti_from_all_extensions(</span>
<span class="sd">    ...     lchdulist, accepted_gtistrings=[&#39;GTI0&#39;, &#39;STDGTI&#39;],</span>
<span class="sd">    ...     det_numbers=[5])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(gti, [[200, 250]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">acc_gti_strs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">accepted_gtistrings</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">det_numbers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">det_numbers</span><span class="p">:</span>
            <span class="n">acc_gti_strs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:02d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">accepted_gtistrings</span><span class="p">]</span>
            <span class="n">acc_gti_strs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:02d}</span><span class="s2">.*&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">accepted_gtistrings</span><span class="p">]</span>
    <span class="n">gtiextn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">acc_gti_strs</span><span class="p">:</span>
        <span class="n">gtiextn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_gti_extensions_from_pattern</span><span class="p">(</span><span class="n">lchdulist</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span>
    <span class="n">gtiextn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">gtiextn</span><span class="p">))</span>
    <span class="n">gti_lists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">extn</span> <span class="ow">in</span> <span class="n">gtiextn</span><span class="p">:</span>
        <span class="n">gtihdu</span> <span class="o">=</span> <span class="n">lchdulist</span><span class="p">[</span><span class="n">extn</span><span class="p">]</span>
        <span class="n">gti_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_gti_from_hdu</span><span class="p">(</span><span class="n">gtihdu</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cross_gtis</span><span class="p">(</span><span class="n">gti_lists</span><span class="p">)</span></div>



<div class="viewcode-block" id="check_gtis">
<a class="viewcode-back" href="../../api.html#stingray.gti.check_gtis">[docs]</a>
<span class="k">def</span> <span class="nf">check_gtis</span><span class="p">(</span><span class="n">gti</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if GTIs are well-behaved.</span>

<span class="sd">    Check that:</span>

<span class="sd">    1. the shape of the GTI array is correct;</span>
<span class="sd">    2. no start &gt; end</span>
<span class="sd">    3. no overlaps.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti : list</span>
<span class="sd">        A list of GTI ``(start, stop)`` pairs extracted from the FITS file.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If GTIs are of the wrong shape</span>
<span class="sd">    ValueError</span>
<span class="sd">        If GTIs have overlapping or displaced values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty GTIs.&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gti</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Please check the formatting of the GTIs. They need to be&quot;</span>
                <span class="s2">&quot; provided as [[gti00, gti01], [gti10, gti11], ...].&quot;</span>
            <span class="p">)</span>

    <span class="n">gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span>
    <span class="n">gti_start</span> <span class="o">=</span> <span class="n">gti</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">gti_end</span> <span class="o">=</span> <span class="n">gti</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Check that GTIs are well-behaved</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">gti_end</span> <span class="o">&gt;=</span> <span class="n">gti_start</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The GTI end times must be larger than the &quot;</span> <span class="s2">&quot;GTI start times.&quot;</span><span class="p">)</span>

    <span class="c1"># Check that there are no overlaps in GTIs</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">gti_start</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">gti_end</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This GTI has overlaps.&quot;</span><span class="p">)</span>

    <span class="k">return</span></div>



<div class="viewcode-block" id="create_gti_mask_jit">
<a class="viewcode-back" href="../../api.html#stingray.gti.create_gti_mask_jit">[docs]</a>
<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">create_gti_mask_jit</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">gtis</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">gti_mask</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compiled and fast function to create GTI mask.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : numpy.ndarray</span>
<span class="sd">        An array of time stamps</span>

<span class="sd">    gtis : iterable of ``(start, stop)`` pairs</span>
<span class="sd">        The list of GTIs.</span>

<span class="sd">    mask : numpy.ndarray</span>
<span class="sd">        A pre-assigned array of zeros of the same shape as ``time``</span>
<span class="sd">        Records whether a time stamp is part of the GTIs.</span>

<span class="sd">    gti_mask : numpy.ndarray</span>
<span class="sd">        A pre-assigned array zeros in the same shape as ``time``; records</span>
<span class="sd">        start/stop of GTIs.</span>

<span class="sd">    min_length : float</span>
<span class="sd">        An optional minimum length for the GTIs to be applied. Only GTIs longer</span>
<span class="sd">        than ``min_length`` will be considered when creating the mask.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gti_el</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">next_gti</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">gtis</span><span class="p">[</span><span class="n">gti_el</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">next_gti</span><span class="p">:</span>
            <span class="n">gti_el</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">gti_el</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">gtis</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">limmin</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[</span><span class="n">gti_el</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">limmax</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[</span><span class="n">gti_el</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">limmax</span> <span class="o">-</span> <span class="n">limmin</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">min_length</span><span class="p">:</span>
                <span class="n">next_gti</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>
            <span class="n">next_gti</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">gti_mask</span><span class="p">[</span><span class="n">gti_el</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">limmin</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">limmin</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">limmax</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">gti_mask</span></div>



<div class="viewcode-block" id="create_gti_mask">
<a class="viewcode-back" href="../../api.html#stingray.gti.create_gti_mask">[docs]</a>
<span class="k">def</span> <span class="nf">create_gti_mask</span><span class="p">(</span>
    <span class="n">time</span><span class="p">,</span> <span class="n">gtis</span><span class="p">,</span> <span class="n">safe_interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_new_gtis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.001</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create GTI mask.</span>

<span class="sd">    Assumes that no overlaps are present between GTIs</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : numpy.ndarray</span>
<span class="sd">        An array of time stamps</span>

<span class="sd">    gtis : ``[[g0_0, g0_1], [g1_0, g1_1], ...]``, float array-like</span>
<span class="sd">        The list of GTIs</span>


<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    safe_interval : float or ``[float, float]``, default None</span>
<span class="sd">        A safe interval to exclude at both ends (if single float) or the start</span>
<span class="sd">        and the end (if pair of values) of GTIs. If None, no safe interval</span>
<span class="sd">        is applied to data.</span>

<span class="sd">    min_length : float</span>
<span class="sd">        An optional minimum length for the GTIs to be applied. Only GTIs longer</span>
<span class="sd">        than ``min_length`` will be considered when creating the mask.</span>

<span class="sd">    return_new_gtis : bool</span>
<span class="sd">        If ``True```, return the list of new GTIs (if ``min_length &gt; 0``)</span>

<span class="sd">    dt : float</span>
<span class="sd">        Time resolution of the data, i.e. the interval between time stamps.</span>

<span class="sd">    epsilon : float</span>
<span class="sd">        Fraction of ``dt`` that is tolerated at the borders of a GTI.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : bool array</span>
<span class="sd">        A mask labelling all time stamps that are included in the GTIs versus</span>
<span class="sd">        those that are not.</span>

<span class="sd">    new_gtis : ``Nx2`` array</span>
<span class="sd">        An array of new GTIs created by this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passing an empty time array to create_gti_mask&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">gtis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passing an empty GTI array to create_gti_mask&quot;</span><span class="p">)</span>
    <span class="n">gtis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gtis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">min_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">gtis</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">lengths</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">min_length</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">good</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No GTIs longer than &quot;</span> <span class="s2">&quot;min_length </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_length</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">mask</span>
        <span class="n">gtis</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_NUMBA</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">create_gti_mask_complete</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">gtis</span><span class="p">,</span>
            <span class="n">safe_interval</span><span class="o">=</span><span class="n">safe_interval</span><span class="p">,</span>
            <span class="n">min_length</span><span class="o">=</span><span class="n">min_length</span><span class="p">,</span>
            <span class="n">return_new_gtis</span><span class="o">=</span><span class="n">return_new_gtis</span><span class="p">,</span>
            <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">apply_function_if_none</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">dt_start</span> <span class="o">=</span> <span class="n">dt_stop</span> <span class="o">=</span> <span class="n">dt</span>
    <span class="n">epsilon_times_dt_start</span> <span class="o">=</span> <span class="n">epsilon_times_dt_stop</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">gtis</span><span class="p">)</span>
        <span class="n">idxs</span><span class="p">[</span><span class="n">idxs</span> <span class="o">==</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">dt_start</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="n">idxs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">dt_stop</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="n">idxs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">epsilon_times_dt_start</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">dt_start</span>
        <span class="n">epsilon_times_dt_stop</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">dt_stop</span>

    <span class="n">gtis_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span>
    <span class="n">gti_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gtis</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">safe_interval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">safe_interval</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">safe_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">safe_interval</span><span class="p">,</span> <span class="n">safe_interval</span><span class="p">])</span>
        <span class="c1"># These are the gtis that will be returned (filtered!). They are only</span>
        <span class="c1"># modified by the safe intervals</span>
        <span class="n">gtis_new</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">safe_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gtis_new</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">safe_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># These are false gtis, they contain a few boundary modifications</span>
    <span class="c1"># in order to simplify the calculation of the mask, but they will _not_</span>
    <span class="c1"># be returned.</span>
    <span class="n">gtis_to_mask</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gtis_new</span><span class="p">)</span>
    <span class="n">gtis_to_mask</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtis_new</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">epsilon_times_dt_start</span> <span class="o">+</span> <span class="n">dt_start</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">gtis_to_mask</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gtis_new</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">epsilon_times_dt_stop</span> <span class="o">-</span> <span class="n">dt_stop</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dt_stop</span> <span class="o">-</span> <span class="n">dt_start</span><span class="p">))</span>

    <span class="n">mask</span><span class="p">,</span> <span class="n">gtimask</span> <span class="o">=</span> <span class="n">create_gti_mask_jit</span><span class="p">(</span>
        <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
        <span class="p">(</span><span class="n">gtis_to_mask</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
        <span class="n">mask</span><span class="p">,</span>
        <span class="n">gti_mask</span><span class="o">=</span><span class="n">gti_mask</span><span class="p">,</span>
        <span class="n">min_length</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">min_length</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_new_gtis</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">gtis_new</span><span class="p">[</span><span class="n">gtimask</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">mask</span></div>



<div class="viewcode-block" id="create_gti_mask_complete">
<a class="viewcode-back" href="../../api.html#stingray.gti.create_gti_mask_complete">[docs]</a>
<span class="k">def</span> <span class="nf">create_gti_mask_complete</span><span class="p">(</span>
    <span class="n">time</span><span class="p">,</span> <span class="n">gtis</span><span class="p">,</span> <span class="n">safe_interval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_new_gtis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.001</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create GTI mask, allowing for non-constant ``dt``.</span>

<span class="sd">    Assumes that no overlaps are present between GTIs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : numpy.ndarray</span>
<span class="sd">        An array of time stamps.</span>

<span class="sd">    gtis : ``[[g0_0, g0_1], [g1_0, g1_1], ...]``, float array-like</span>
<span class="sd">        The list of GTIs.</span>


<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    safe_interval : float or [float, float]</span>
<span class="sd">        A safe interval to exclude at both ends (if single float) or the start</span>
<span class="sd">        and the end (if pair of values) of GTIs.</span>

<span class="sd">    min_length : float</span>
<span class="sd">        An optional minimum length for the GTIs to be applied. Only GTIs longer</span>
<span class="sd">        than ``min_length`` will be considered when creating the mask.</span>

<span class="sd">    return_new_gtis : bool</span>
<span class="sd">        If ``True``, return the list of new GTIs (if ``min_length &gt; 0``).</span>

<span class="sd">    dt : float</span>
<span class="sd">        Time resolution of the data, i.e. the interval between time stamps.</span>

<span class="sd">    epsilon : float</span>
<span class="sd">        Fraction of ``dt`` that is tolerated at the borders of a GTI.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : bool array</span>
<span class="sd">        A mask labelling all time stamps that are included in the GTIs versus</span>
<span class="sd">        those that are not.</span>

<span class="sd">    new_gtis : Nx2 array</span>
<span class="sd">        An array of new GTIs created by this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">time</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">epsilon_times_dt</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">safe_interval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">safe_interval</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">safe_interval</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">safe_interval</span> <span class="o">=</span> <span class="p">[</span><span class="n">safe_interval</span><span class="p">,</span> <span class="n">safe_interval</span><span class="p">]</span>

    <span class="n">newgtis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span>
    <span class="c1"># Whose GTIs, including safe intervals, are longer than min_length</span>
    <span class="n">newgtimask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newgtis</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ig</span><span class="p">,</span> <span class="n">gti</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gtis</span><span class="p">):</span>
        <span class="n">limmin</span><span class="p">,</span> <span class="n">limmax</span> <span class="o">=</span> <span class="n">gti</span>
        <span class="n">limmin</span> <span class="o">+=</span> <span class="n">safe_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">limmax</span> <span class="o">-=</span> <span class="n">safe_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">limmax</span> <span class="o">-</span> <span class="n">limmin</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">:</span>
            <span class="n">newgtis</span><span class="p">[</span><span class="n">ig</span><span class="p">][:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">limmin</span><span class="p">,</span> <span class="n">limmax</span><span class="p">]</span>
            <span class="n">cond1</span> <span class="o">=</span> <span class="n">time</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">limmin</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">epsilon_times_dt</span><span class="p">)</span>
            <span class="n">cond2</span> <span class="o">=</span> <span class="n">time</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">limmax</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">epsilon_times_dt</span><span class="p">)</span>

            <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">newgtimask</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="k">if</span> <span class="n">return_new_gtis</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span><span class="p">,</span> <span class="n">newgtis</span><span class="p">[</span><span class="n">newgtimask</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="create_gti_from_condition">
<a class="viewcode-back" href="../../api.html#stingray.gti.create_gti_from_condition">[docs]</a>
<span class="k">def</span> <span class="nf">create_gti_from_condition</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">safe_interval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a GTI list from a time array and a boolean mask (``condition``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : array-like</span>
<span class="sd">        Array containing time stamps.</span>

<span class="sd">    condition : array-like</span>
<span class="sd">        An array of bools, of the same length of time.</span>
<span class="sd">        A possible condition can be, e.g., the result of ``lc &gt; 0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gtis : ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">        The newly created GTIs.</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    safe_interval : float or ``[float, float]``</span>
<span class="sd">        A safe interval to exclude at both ends (if single float) or the start</span>
<span class="sd">        and the end (if pair of values) of GTIs.</span>
<span class="sd">    dt : float</span>
<span class="sd">        The width (in sec) of each bin of the time array. Can be irregular.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">StingrayError</span><span class="p">(</span><span class="s2">&quot;The length of the condition and &quot;</span> <span class="s2">&quot;time arrays must be the same.&quot;</span><span class="p">)</span>

    <span class="n">idxs</span> <span class="o">=</span> <span class="n">contiguous_regions</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">safe_interval</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">safe_interval</span> <span class="o">=</span> <span class="p">[</span><span class="n">safe_interval</span><span class="p">,</span> <span class="n">safe_interval</span><span class="p">]</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">gtis</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">startidx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stopidx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">startidx</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">[</span><span class="n">startidx</span><span class="p">]</span> <span class="o">+</span> <span class="n">safe_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">stopidx</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">[</span><span class="n">stopidx</span><span class="p">]</span> <span class="o">-</span> <span class="n">safe_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">gtis</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span></div>



<div class="viewcode-block" id="cross_two_gtis">
<a class="viewcode-back" href="../../api.html#stingray.gti.cross_two_gtis">[docs]</a>
<span class="k">def</span> <span class="nf">cross_two_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract the common intervals from two GTI lists *EXACTLY*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti0 : iterable of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">    gti1 : iterable of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">        The two lists of GTIs to be crossed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gtis : ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">        The newly created GTIs.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cross_gtis : From multiple GTI lists, extract common intervals *EXACTLY*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gti1 = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; gti2 = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; newgti = cross_two_gtis(gti1, gti2)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(newgti, [[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; gti1 = np.array([[1, 4]])</span>
<span class="sd">    &gt;&gt;&gt; gti2 = np.array([[1, 2], [2, 4]])</span>
<span class="sd">    &gt;&gt;&gt; newgti = cross_two_gtis(gti1, gti2)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(newgti, [[1, 4]])</span>
<span class="sd">    &gt;&gt;&gt; gti1 = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; gti2 = np.array([[2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; newgti = cross_two_gtis(gti1, gti2)</span>
<span class="sd">    &gt;&gt;&gt; len(newgti)</span>
<span class="sd">    0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gti0</span> <span class="o">=</span> <span class="n">join_equal_gti_boundaries</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti0</span><span class="p">))</span>
    <span class="n">gti1</span> <span class="o">=</span> <span class="n">join_equal_gti_boundaries</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti1</span><span class="p">))</span>
    <span class="c1"># Check GTIs</span>
    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">)</span>
    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gti1</span><span class="p">)</span>

    <span class="n">gti0_start</span> <span class="o">=</span> <span class="n">gti0</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">gti0_end</span> <span class="o">=</span> <span class="n">gti0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">gti1_start</span> <span class="o">=</span> <span class="n">gti1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">gti1_end</span> <span class="o">=</span> <span class="n">gti1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Create a list that references to the two start and end series</span>
    <span class="n">gti_start</span> <span class="o">=</span> <span class="p">[</span><span class="n">gti0_start</span><span class="p">,</span> <span class="n">gti1_start</span><span class="p">]</span>
    <span class="n">gti_end</span> <span class="o">=</span> <span class="p">[</span><span class="n">gti0_end</span><span class="p">,</span> <span class="n">gti1_end</span><span class="p">]</span>

    <span class="c1"># Concatenate the series, while keeping track of the correct origin of</span>
    <span class="c1"># each start and end time</span>
    <span class="n">gti0_tag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gti0_start</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">gti1_tag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gti1_start</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">conc_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gti0_start</span><span class="p">,</span> <span class="n">gti1_start</span><span class="p">))</span>
    <span class="n">conc_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gti0_end</span><span class="p">,</span> <span class="n">gti1_end</span><span class="p">))</span>
    <span class="n">conc_tag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gti0_tag</span><span class="p">,</span> <span class="n">gti1_tag</span><span class="p">))</span>

    <span class="c1"># Put in time order</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">conc_end</span><span class="p">)</span>
    <span class="n">conc_start</span> <span class="o">=</span> <span class="n">conc_start</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
    <span class="n">conc_end</span> <span class="o">=</span> <span class="n">conc_end</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
    <span class="n">conc_tag</span> <span class="o">=</span> <span class="n">conc_tag</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="n">last_end</span> <span class="o">=</span> <span class="n">conc_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span>

    <span class="c1"># The maximum end must not be larger than the second last end!</span>
    <span class="n">max_end</span> <span class="o">=</span> <span class="n">conc_end</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">final_gti</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ie</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conc_end</span><span class="p">):</span>
        <span class="c1"># Is this ending in series 0 or 1?</span>
        <span class="n">this_series</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">conc_tag</span><span class="p">[</span><span class="n">ie</span><span class="p">])</span>
        <span class="n">other_series</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_series</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Check that this closes intervals in both series.</span>
        <span class="c1"># 1. Check that there is an opening in both series 0 and 1 lower than e</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">st_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">gti_start</span><span class="p">[</span><span class="n">this_series</span><span class="p">][</span><span class="n">gti_start</span><span class="p">[</span><span class="n">this_series</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">])</span>
            <span class="n">so_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">gti_start</span><span class="p">[</span><span class="n">other_series</span><span class="p">][</span><span class="n">gti_start</span><span class="p">[</span><span class="n">other_series</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">])</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">gti_start</span><span class="p">[</span><span class="n">this_series</span><span class="p">][</span><span class="n">st_pos</span><span class="p">]</span>
            <span class="n">so</span> <span class="o">=</span> <span class="n">gti_start</span><span class="p">[</span><span class="n">other_series</span><span class="p">][</span><span class="n">so_pos</span><span class="p">]</span>

            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">st</span><span class="p">,</span> <span class="n">so</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">continue</span>

        <span class="c1"># If this start is inside the last interval (It can happen for equal</span>
        <span class="c1"># GTI start times between the two series), then skip!</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">last_end</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># 2. Check that there is no closing before e in the &quot;other series&quot;,</span>
        <span class="c1"># from intervals starting either after s, or starting and ending</span>
        <span class="c1"># between the last closed interval and this one</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">gti_end</span><span class="p">[</span><span class="n">other_series</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gti_end</span><span class="p">[</span><span class="n">other_series</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="n">gti_end</span><span class="p">[</span><span class="n">other_series</span><span class="p">][</span><span class="n">so_pos</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">s</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="n">max_end</span><span class="p">:</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Also, the last closed interval in the other series must be before e</span>
        <span class="c1"># Well, if none of the conditions at point 2 apply, then you can</span>
        <span class="c1"># create the new gti!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">condition</span><span class="p">:</span>
            <span class="n">final_gti</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">])</span>
            <span class="n">last_end</span> <span class="o">=</span> <span class="n">e</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_gti</span><span class="p">)</span></div>



<div class="viewcode-block" id="cross_gtis">
<a class="viewcode-back" href="../../api.html#stingray.gti.cross_gtis">[docs]</a>
<span class="k">def</span> <span class="nf">cross_gtis</span><span class="p">(</span><span class="n">gti_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From multiple GTI lists, extract the common intervals *EXACTLY*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti_list : array-like</span>
<span class="sd">        List of GTI arrays, each one in the usual format</span>
<span class="sd">        ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gti0: 2-d float array</span>
<span class="sd">        ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">        The newly created GTIs.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cross_two_gtis : Extract the common intervals from two GTI lists *EXACTLY*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gti1 = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; gti2 = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; newgti = cross_gtis([gti1, gti2])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(newgti, [[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; gti1 = np.array([[1, 4]])</span>
<span class="sd">    &gt;&gt;&gt; gti2 = np.array([[1, 2], [2, 4]])</span>
<span class="sd">    &gt;&gt;&gt; newgti = cross_gtis([gti1, gti2])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(newgti, [[1, 4]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gti_list</span><span class="p">:</span>
        <span class="n">check_gtis</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="n">ninst</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gti_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ninst</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gti_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">gti0</span> <span class="o">=</span> <span class="n">gti_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">gti</span> <span class="ow">in</span> <span class="n">gti_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">gti0</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gti0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">gti0</span></div>



<div class="viewcode-block" id="get_btis">
<a class="viewcode-back" href="../../api.html#stingray.gti.get_btis">[docs]</a>
<span class="k">def</span> <span class="nf">get_btis</span><span class="p">(</span><span class="n">gtis</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From GTIs, obtain bad time intervals, i.e. the intervals *not* covered</span>
<span class="sd">    by the GTIs.</span>

<span class="sd">    GTIs have to be well-behaved, in the sense that they have to pass</span>
<span class="sd">    ``check_gtis``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gtis : iterable</span>
<span class="sd">        A list of GTIs.</span>

<span class="sd">    start_time : float</span>
<span class="sd">        Optional start time of the overall observation (e.g. can be earlier</span>
<span class="sd">        than the first time stamp in ``gtis``).</span>

<span class="sd">    stop_time : float</span>
<span class="sd">        Optional stop time of the overall observation (e.g. can be later than</span>
<span class="sd">        the last time stamp in``gtis``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    btis : numpy.ndarray</span>
<span class="sd">        A list of bad time intervals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check GTIs</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">stop_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty GTI and no valid start_time &quot;</span> <span class="s2">&quot;and stop_time. BAD!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">([[</span><span class="n">start_time</span><span class="p">,</span> <span class="n">stop_time</span><span class="p">]])</span>
    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">gtis</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">stop_time</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">stop_time</span><span class="p">,</span> <span class="n">gtis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">gtis</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start_time</span><span class="p">:</span>
        <span class="n">btis</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">btis</span> <span class="o">=</span> <span class="p">[[</span><span class="n">start_time</span><span class="p">,</span> <span class="n">gtis</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]]</span>
    <span class="c1"># Transform GTI list in</span>
    <span class="n">flat_gtis</span> <span class="o">=</span> <span class="n">gtis</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">new_flat_btis</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flat_gtis</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">flat_gtis</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">btis</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_flat_btis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stop_time</span> <span class="o">&gt;</span> <span class="n">gtis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">btis</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="n">gtis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">stop_time</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">btis</span><span class="p">)</span></div>



<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_check_separate</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-compiled core of ``check_separate``.&quot;&quot;&quot;</span>
    <span class="n">gti0_start</span> <span class="o">=</span> <span class="n">gti0</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">gti0_end</span> <span class="o">=</span> <span class="n">gti0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">gti1_start</span> <span class="o">=</span> <span class="n">gti1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">gti1_end</span> <span class="o">=</span> <span class="n">gti1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">gti0_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">gti1_start</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">gti1_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">gti0_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gti1</span><span class="o">.</span><span class="n">flatten</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">g0</span><span class="p">,</span> <span class="n">g1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gti0</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">gti0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">&lt;=</span> <span class="n">g1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">g</span> <span class="o">&gt;=</span> <span class="n">g0</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gti0</span><span class="o">.</span><span class="n">flatten</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">g0</span><span class="p">,</span> <span class="n">g1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gti1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">gti1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">&lt;=</span> <span class="n">g1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">g</span> <span class="o">&gt;=</span> <span class="n">g0</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="check_separate">
<a class="viewcode-back" href="../../api.html#stingray.gti.check_separate">[docs]</a>
<span class="k">def</span> <span class="nf">check_separate</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if two GTIs do not overlap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti0: 2-d float array</span>
<span class="sd">        List of GTIs of form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``.</span>

<span class="sd">    gti1: 2-d float array</span>
<span class="sd">        List of GTIs of form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    separate: bool</span>
<span class="sd">        ``True`` if GTIs are mutually exclusive, ``False`` if not.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gti0 = [[0, 10]]</span>
<span class="sd">    &gt;&gt;&gt; gti1 = [[20, 30]]</span>
<span class="sd">    &gt;&gt;&gt; assert check_separate(gti0, gti1)</span>
<span class="sd">    &gt;&gt;&gt; gti0 = [[0, 10]]</span>
<span class="sd">    &gt;&gt;&gt; gti1 = [[0, 10]]</span>
<span class="sd">    &gt;&gt;&gt; check_separate(gti0, gti1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; gti0 = [[0, 10]]</span>
<span class="sd">    &gt;&gt;&gt; gti1 = [[10, 20]]</span>
<span class="sd">    &gt;&gt;&gt; assert check_separate(gti0, gti1)</span>
<span class="sd">    &gt;&gt;&gt; gti0 = [[0, 11]]</span>
<span class="sd">    &gt;&gt;&gt; gti1 = [[10, 20]]</span>
<span class="sd">    &gt;&gt;&gt; check_separate(gti0, gti1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; gti0 = [[0, 11]]</span>
<span class="sd">    &gt;&gt;&gt; gti1 = [[10, 20]]</span>
<span class="sd">    &gt;&gt;&gt; check_separate(gti1, gti0)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; gti0 = [[0, 10], [30, 40]]</span>
<span class="sd">    &gt;&gt;&gt; gti1 = [[11, 28]]</span>
<span class="sd">    &gt;&gt;&gt; assert check_separate(gti0, gti1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gti0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti0</span><span class="p">)</span>
    <span class="n">gti1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gti0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gti1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Check if independently GTIs are well behaved</span>
    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">)</span>
    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gti1</span><span class="p">)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">gti0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">gti1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">_check_separate</span><span class="p">((</span><span class="n">gti0</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="p">(</span><span class="n">gti1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">))</span></div>



<span class="k">def</span> <span class="nf">join_equal_gti_boundaries</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If the start of a GTI and the end of the previous one is within a certain time value, join them.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti: 2-d float array</span>
<span class="sd">        List of GTIs of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``.</span>

<span class="sd">    threshold: float number (units sec)</span>
<span class="sd">        Maximum time interval to join two adjacent GTIs</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gti: 2-d float array</span>
<span class="sd">        The newly created GTI array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_gtis</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">gti</span><span class="p">:</span>
        <span class="n">new_gtis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="n">touching</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gti</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">gti</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;=</span> <span class="n">threshold</span>
    <span class="n">ng</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">touching</span><span class="p">[</span><span class="n">count</span><span class="p">]:</span>
            <span class="n">new_gtis</span><span class="p">[</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_gtis</span><span class="p">[</span><span class="n">count</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_gtis</span><span class="p">[</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ng</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_gtis</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">ng</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_gtis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">merge_gtis</span><span class="p">(</span><span class="n">gti_list</span><span class="p">,</span> <span class="n">strategy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge a list of GTIs using the specified method.</span>

<span class="sd">    Invalid GTI lists (None or empty) are ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti_list : list of 2-d float arrays</span>
<span class="sd">        List of GTIs.</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    strategy : {&quot;intersection&quot;, &quot;union&quot;, &quot;append&quot;, &quot;infer&quot;, &quot;none&quot;}</span>
<span class="sd">        Method to use to merge the GTIs. If &quot;intersection&quot;, the GTIs are merged</span>
<span class="sd">        using the intersection of the GTIs. If &quot;union&quot;, the GTIs are merged</span>
<span class="sd">        using the union of the GTIs. If &quot;none&quot;, a single GTI with the minimum and</span>
<span class="sd">        the maximum time stamps of all GTIs is returned. If &quot;infer&quot;, the strategy</span>
<span class="sd">        is decided based on the GTIs. If there are no overlaps, &quot;union&quot; is used,</span>
<span class="sd">        otherwise &quot;intersection&quot; is used. If &quot;append&quot;, the GTIs are simply appended</span>
<span class="sd">        but they must be mutually exclusive.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gti1 = np.array([[1, 2], [3, 4], [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; gti2 = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; gti3 = np.array([[4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; gti = merge_gtis([gti1, gti2], &quot;intersection&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(gti, [[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; assert merge_gtis([gti1, gti2, gti3], &quot;intersection&quot;) is None</span>
<span class="sd">    &gt;&gt;&gt; assert merge_gtis([gti2, gti3], &quot;intersection&quot;) is None</span>
<span class="sd">    &gt;&gt;&gt; gti = merge_gtis([gti1, gti2], &quot;infer&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(gti, [[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; gti = merge_gtis([gti2, gti3], &quot;infer&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(gti, [[1, 2], [4, 5]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_gti_lists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">global_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">gti</span> <span class="ow">in</span> <span class="n">gti_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gti</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">all_gti_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span>
        <span class="n">global_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">global_min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">gti</span><span class="p">))</span>
        <span class="n">global_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">global_max</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gti</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_gti_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">([[</span><span class="n">global_min</span><span class="p">,</span> <span class="n">global_max</span><span class="p">]])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_gti_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">all_gti_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">cross</span> <span class="o">=</span> <span class="n">cross_gtis</span><span class="p">(</span><span class="n">all_gti_lists</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cross</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;infer&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="s2">&quot;union&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="s2">&quot;intersection&quot;</span>

    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;intersection&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cross</span>

    <span class="n">gti0</span> <span class="o">=</span> <span class="n">all_gti_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">gti</span> <span class="ow">in</span> <span class="n">all_gti_lists</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;union&quot;</span><span class="p">:</span>
            <span class="n">gti0</span> <span class="o">=</span> <span class="n">join_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;append&quot;</span><span class="p">:</span>
            <span class="n">gti0</span> <span class="o">=</span> <span class="n">append_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gti0</span>


<div class="viewcode-block" id="append_gtis">
<a class="viewcode-back" href="../../api.html#stingray.gti.append_gtis">[docs]</a>
<span class="k">def</span> <span class="nf">append_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Union of two non-overlapping GTIs.</span>

<span class="sd">    If the two GTIs &quot;touch&quot;, this is tolerated and the touching GTIs are</span>
<span class="sd">    joined in a single one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti0: 2-d float array</span>
<span class="sd">        List of GTIs of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``.</span>

<span class="sd">    gti1: 2-d float array</span>
<span class="sd">        List of GTIs of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gti: 2-d float array</span>
<span class="sd">        The newly created GTI array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(append_gtis([[0, 1]], [[2, 3]]), [[0, 1], [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(append_gtis([[0, 1], [4, 5]], [[2, 3]]),</span>
<span class="sd">    ...             [[0, 1], [2, 3], [4, 5]])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(append_gtis([[0, 1]], [[1, 3]]), [[0, 3]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gti0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti0</span><span class="p">)</span>
    <span class="n">gti1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti1</span><span class="p">)</span>
    <span class="c1"># Check if independently GTIs are well behaved.</span>
    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">)</span>
    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gti1</span><span class="p">)</span>

    <span class="c1"># Check if GTIs are mutually exclusive.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">check_separate</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;In order to append, GTIs must be mutually exclusive.&quot;</span><span class="p">)</span>

    <span class="n">new_gtis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">])</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">new_gtis</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">join_equal_gti_boundaries</span><span class="p">(</span><span class="n">new_gtis</span><span class="p">[</span><span class="n">order</span><span class="p">])</span></div>



<div class="viewcode-block" id="join_gtis">
<a class="viewcode-back" href="../../api.html#stingray.gti.join_gtis">[docs]</a>
<span class="k">def</span> <span class="nf">join_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Union of two GTIs.</span>

<span class="sd">    If GTIs are mutually exclusive, it calls ``append_gtis``. Otherwise we put</span>
<span class="sd">    the extremes of partially overlapping GTIs on an ideal line and look at the</span>
<span class="sd">    number of opened and closed intervals. When the number of closed and opened</span>
<span class="sd">    intervals is the same, the full GTI is complete and we close it.</span>

<span class="sd">    In practice, we assign to each opening time of a GTI the value ``-1``, and</span>
<span class="sd">    the value ``1`` to each closing time; when the cumulative sum is zero, the</span>
<span class="sd">    GTI has ended. The timestamp after each closed GTI is the start of a new</span>
<span class="sd">    one.</span>

<span class="sd">    ::</span>

<span class="sd">        (g_all)    0     1     2     3     4     5     6     7     8     9</span>
<span class="sd">        (cumsum)   -1   -2    -1     0    -1    -2     -1   -2    -1     0</span>
<span class="sd">        GTI A      |-----:-----|     :     |-----:-----|     |-----:-----|</span>
<span class="sd">        FINAL GTI  |-----:-----------|     |-----:-----------------:-----|</span>
<span class="sd">        GTI B            |-----------|           |-----------------|</span>

<span class="sd">    In case one GTI ends exactly where another one starts, the cumulative sum is 0</span>
<span class="sd">    but we do not want to close. In this case, we make a check that the next element</span>
<span class="sd">    of the sequence is not equal to the one where we would close.</span>

<span class="sd">    ::</span>

<span class="sd">        (g_all)    0    1,1         3,3          5</span>
<span class="sd">        (cumsum)   -1   0,-1       -1,-2         0</span>
<span class="sd">        GTI A      |-----|           |-----------|</span>
<span class="sd">        FINAL GTI  |-----------------------------|</span>
<span class="sd">        GTI B            |-----------|</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gti0: 2-d float array</span>
<span class="sd">        List of GTIs of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>

<span class="sd">    gti1: 2-d float array</span>
<span class="sd">        List of GTIs of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gti: 2-d float array</span>
<span class="sd">        The newly created GTI</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gti0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti0</span><span class="p">)</span>
    <span class="n">gti1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti1</span><span class="p">)</span>

    <span class="c1"># Check if independently GTIs are well behaved.</span>
    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">)</span>
    <span class="n">check_gtis</span><span class="p">(</span><span class="n">gti1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_separate</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">append_gtis</span><span class="p">(</span><span class="n">gti0</span><span class="p">,</span> <span class="n">gti1</span><span class="p">)</span>

    <span class="n">g0</span> <span class="o">=</span> <span class="n">gti0</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="c1"># Opening GTI: type = 1; Closing: type = -1</span>
    <span class="n">g0_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
    <span class="p">)</span>
    <span class="n">g1</span> <span class="o">=</span> <span class="n">gti1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">g1_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
    <span class="p">)</span>

    <span class="n">g_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g0</span><span class="p">,</span> <span class="n">g1</span><span class="p">)</span>
    <span class="n">g_type_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g0_type</span><span class="p">,</span> <span class="n">g1_type</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">g_all</span><span class="p">)</span>
    <span class="n">g_all</span> <span class="o">=</span> <span class="n">g_all</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
    <span class="n">g_type_all</span> <span class="o">=</span> <span class="n">g_type_all</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="n">sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">g_type_all</span><span class="p">)</span>

    <span class="c1"># Where the cumulative sum is zero, we close the GTI.</span>
    <span class="c1"># But pay attention! If one GTI ends exactly where another one starts,</span>
    <span class="c1"># the cumulative sum is zero, but we do not want to close the GTI.</span>
    <span class="c1"># So we check that the next element of g_all is not equal to the one where</span>
    <span class="c1"># we would close.</span>
    <span class="n">closing_bins</span> <span class="o">=</span> <span class="p">(</span><span class="n">sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g_all</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">g_all</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># The next element in the sequence is the start of the new GTI. In the case</span>
    <span class="c1"># of the last element, the next is the first. Numpy.roll gives this for</span>
    <span class="c1"># free.</span>
    <span class="n">starting_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">closing_bins</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">starting_times</span> <span class="o">=</span> <span class="n">g_all</span><span class="p">[</span><span class="n">starting_bins</span><span class="p">]</span>
    <span class="n">closing_times</span> <span class="o">=</span> <span class="n">g_all</span><span class="p">[</span><span class="n">closing_bins</span><span class="p">]</span>

    <span class="n">final_gti</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starting_times</span><span class="p">,</span> <span class="n">closing_times</span><span class="p">):</span>
        <span class="n">final_gti</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">final_gti</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="time_intervals_from_gtis">
<a class="viewcode-back" href="../../api.html#stingray.gti.time_intervals_from_gtis">[docs]</a>
<span class="k">def</span> <span class="nf">time_intervals_from_gtis</span><span class="p">(</span><span class="n">gtis</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute start/stop times of equal time intervals, compatible with GTIs.</span>

<span class="sd">    Used to start each FFT/PDS/cospectrum from the start of a GTI,</span>
<span class="sd">    and stop before the next gap in data (end of GTI).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gtis : 2-d float array</span>
<span class="sd">        List of GTIs of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>

<span class="sd">    segment_size : float</span>
<span class="sd">        Length of the time segments</span>

<span class="sd">    fraction_step : float</span>
<span class="sd">        If the step is not a full ``segment_size`` but less (e.g. a moving</span>
<span class="sd">        window), this indicates the ratio between step step and</span>
<span class="sd">        ``segment_size`` (e.g. ``0.5`` means that the window shifts by half</span>
<span class="sd">        ``segment_size``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum_start_times : array-like</span>
<span class="sd">        List of starting times to use in the spectral calculations.</span>

<span class="sd">    spectrum_stop_times : array-like</span>
<span class="sd">        List of end times to use in the spectral calculations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spectrum_start_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gtis</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">epsilon</span> <span class="o">&lt;</span> <span class="n">segment_size</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">newtimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">segment_size</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">(</span><span class="n">segment_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">fraction_step</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">spectrum_start_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectrum_start_times</span><span class="p">,</span> <span class="n">newtimes</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrum_start_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No GTIs are equal to or longer than segment_size.&quot;</span>
    <span class="k">return</span> <span class="n">spectrum_start_times</span><span class="p">,</span> <span class="n">spectrum_start_times</span> <span class="o">+</span> <span class="n">segment_size</span></div>



<span class="k">def</span> <span class="nf">calculate_segment_bin_start</span><span class="p">(</span><span class="n">startbin</span><span class="p">,</span> <span class="n">stopbin</span><span class="p">,</span> <span class="n">nbin</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the starting indices of intervals of equal length.</span>

<span class="sd">    A bit like `np.arange`, but checks that the last number is</span>
<span class="sd">    at least ``nbin`` less than ``stopbin``. Useful when getting</span>
<span class="sd">    starting intervals of equal chunks of a binned light curve.</span>

<span class="sd">    It is possible to make these intervals sliding, through the</span>
<span class="sd">    ``fraction_step`` parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    startbin : int</span>
<span class="sd">        Starting bin of the interval.</span>

<span class="sd">    stopbin : int</span>
<span class="sd">        Last bin of the interval.</span>

<span class="sd">    nbin : int</span>
<span class="sd">        Number of bins in each interval.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    fraction_step : float</span>
<span class="sd">        If the step is not a full ``nbin`` but less (e.g. a moving window),</span>
<span class="sd">        this indicates the ratio between the step and ``nbin`` (e.g.</span>
<span class="sd">        ``0.5`` means that the window shifts by half ``nbin``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum_start_bins : array-like</span>
<span class="sd">        List of starting bins in the original time array to use in spectral</span>
<span class="sd">        calculations.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; st = calculate_segment_bin_start(0, 10000, 10000)</span>
<span class="sd">    &gt;&gt;&gt; int(st[-1])</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; st = calculate_segment_bin_start(0, 5, 2)</span>
<span class="sd">    &gt;&gt;&gt; int(st[-1])</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; st = calculate_segment_bin_start(0, 6, 2)</span>
<span class="sd">    &gt;&gt;&gt; int(st[-1])</span>
<span class="sd">    4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">startbin</span><span class="p">,</span> <span class="n">stopbin</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbin</span> <span class="o">*</span> <span class="n">fraction_step</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nbin</span> <span class="o">&gt;</span> <span class="n">stopbin</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">st</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">st</span>


<div class="viewcode-block" id="bin_intervals_from_gtis">
<a class="viewcode-back" href="../../api.html#stingray.gti.bin_intervals_from_gtis">[docs]</a>
<span class="k">def</span> <span class="nf">bin_intervals_from_gtis</span><span class="p">(</span><span class="n">gtis</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute start/stop times of equal time intervals, compatible with GTIs,</span>
<span class="sd">    and map them to the indices of an array of time stamps.</span>

<span class="sd">    Used to start each FFT/PDS/cospectrum from the start of a GTI,</span>
<span class="sd">    and stop before the next gap in data (end of GTI).</span>
<span class="sd">    In this case, it is necessary to specify the time array containing the</span>
<span class="sd">    times of the light curve bins.</span>
<span class="sd">    Returns start and stop bins of the intervals to use for the PDS.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gtis : 2-d float array</span>
<span class="sd">        List of GTIs of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``.</span>

<span class="sd">    segment_size : float</span>
<span class="sd">        Length of each time segment.</span>

<span class="sd">    time : array-like</span>
<span class="sd">        Array of time stamps.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    dt : float, default median(diff(time))</span>
<span class="sd">        Time resolution of the light curve.</span>

<span class="sd">    epsilon : float, default 0.001</span>
<span class="sd">        The tolerance, in fraction of ``dt``, for the comparisons at the</span>
<span class="sd">        borders.</span>

<span class="sd">    fraction_step : float</span>
<span class="sd">        If the step is not a full ``segment_size`` but less (e.g. a moving</span>
<span class="sd">        window), this indicates the ratio between step step and</span>
<span class="sd">        ``segment_size`` (e.g. ``0.5`` means that the window shifts by half</span>
<span class="sd">        ``segment_size``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum_start_bins : array-like</span>
<span class="sd">        List of starting bins in the original time array to use in spectral</span>
<span class="sd">        calculations.</span>

<span class="sd">    spectrum_stop_bins : array-like</span>
<span class="sd">        List of end bins to use in the spectral calculations.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; time = np.arange(0.5, 13.5)</span>

<span class="sd">    &gt;&gt;&gt; gtis = [[0, 5], [6, 8], [9, 10]]</span>

<span class="sd">    &gt;&gt;&gt; segment_size = 2</span>

<span class="sd">    &gt;&gt;&gt; start_bins, stop_bins = bin_intervals_from_gtis(gtis,segment_size,time)</span>

<span class="sd">    &gt;&gt;&gt; assert np.allclose(start_bins, [0, 2, 6])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(stop_bins, [2, 4, 8])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(time[start_bins[0]:stop_bins[0]], [0.5, 1.5])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(time[start_bins[1]:stop_bins[1]], [2.5, 3.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">gtis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>

    <span class="n">epsilon_times_dt</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">nbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">segment_size</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span> <span class="ow">or</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gtis</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid time interval for the given GTIs&quot;</span><span class="p">)</span>

    <span class="n">spectrum_start_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">gti_low</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">epsilon_times_dt</span>
    <span class="n">gti_up</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">epsilon_times_dt</span>

    <span class="k">for</span> <span class="n">g0</span><span class="p">,</span> <span class="n">g1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gti_low</span><span class="p">,</span> <span class="n">gti_up</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">g1</span> <span class="o">-</span> <span class="n">g0</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">epsilon_times_dt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">segment_size</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">startbin</span><span class="p">,</span> <span class="n">stopbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="n">g0</span><span class="p">,</span> <span class="n">g1</span><span class="p">],</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">stopbin</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">stopbin</span> <span class="o">&gt;</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">stopbin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="n">startbin</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">g0</span><span class="p">:</span>
            <span class="n">startbin</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Would be g[1] - dt/2, but stopbin is the end of an interval</span>
        <span class="c1"># so one has to add one bin</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="n">stopbin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">g1</span><span class="p">:</span>
            <span class="n">stopbin</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">newbins</span> <span class="o">=</span> <span class="n">calculate_segment_bin_start</span><span class="p">(</span><span class="n">startbin</span><span class="p">,</span> <span class="n">stopbin</span><span class="p">,</span> <span class="n">nbin</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="n">fraction_step</span><span class="p">)</span>
        <span class="n">spectrum_start_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectrum_start_bins</span><span class="p">,</span> <span class="n">newbins</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrum_start_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No GTIs are equal to or longer than segment_size.&quot;</span>
    <span class="k">return</span> <span class="n">spectrum_start_bins</span><span class="p">,</span> <span class="n">spectrum_start_bins</span> <span class="o">+</span> <span class="n">nbin</span></div>



<div class="viewcode-block" id="gti_border_bins">
<a class="viewcode-back" href="../../api.html#stingray.gti.gti_border_bins">[docs]</a>
<span class="k">def</span> <span class="nf">gti_border_bins</span><span class="p">(</span><span class="n">gtis</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the indices in a time array corresponding to the borders of GTIs.</span>

<span class="sd">    GTIs shorter than the bin time are not returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gtis : 2-d float array</span>
<span class="sd">        List of GTIs of the form ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``.</span>

<span class="sd">    time : array-like</span>
<span class="sd">        Array of time stamps.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    dt : float or array of floats. Default median(diff(time))</span>
<span class="sd">        Time resolution of the light curve. Can be an array of the same dimension</span>
<span class="sd">        as ``time``</span>

<span class="sd">    epsilon : float, default 0.001</span>
<span class="sd">        The tolerance, in fraction of ``dt``, for the comparisons at the</span>
<span class="sd">        borders.</span>

<span class="sd">    fraction_step : float</span>
<span class="sd">        If the step is not a full ``segment_size`` but less (e.g. a moving</span>
<span class="sd">        window), this indicates the ratio between step step and</span>
<span class="sd">        ``segment_size`` (e.g. ``0.5`` means that the window shifts by half</span>
<span class="sd">        ``segment_size``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum_start_bins : array-like</span>
<span class="sd">        List of starting bins of each GTI</span>

<span class="sd">    spectrum_stop_bins : array-like</span>
<span class="sd">        List of stop bins of each GTI. The elements corresponding to these bins</span>
<span class="sd">        should *not* be included.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; times = np.arange(0.5, 13.5)</span>

<span class="sd">    &gt;&gt;&gt; gti_border_bins([[16., 18.]], times)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: Invalid time interval for the given GTIs</span>

<span class="sd">    &gt;&gt;&gt; start_bins, stop_bins = gti_border_bins(</span>
<span class="sd">    ...    [[0, 5], [6, 8]], times)</span>

<span class="sd">    &gt;&gt;&gt; assert np.allclose(start_bins, [0, 6])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(stop_bins, [5, 8])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(times[start_bins[0]:stop_bins[0]], [0.5, 1.5, 2.5, 3.5, 4.5])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(times[start_bins[1]:stop_bins[1]], [6.5, 7.5])</span>

<span class="sd">    &gt;&gt;&gt; start_bins, stop_bins = gti_border_bins(</span>
<span class="sd">    ...    [[0, 5], [6, 13]], times, dt=np.ones_like(times))</span>

<span class="sd">    &gt;&gt;&gt; assert np.allclose(start_bins, [0, 6])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(stop_bins, [5, 13])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(times[start_bins[0]:stop_bins[0]], [0.5, 1.5, 2.5, 3.5, 4.5])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(times[start_bins[1]:stop_bins[1]], [6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5])</span>
<span class="sd">    True&quot;&quot;&quot;</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">gtis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>

    <span class="n">dt_start</span> <span class="o">=</span> <span class="n">dt_stop</span> <span class="o">=</span> <span class="n">dt</span>
    <span class="n">epsilon_times_dt_start</span> <span class="o">=</span> <span class="n">epsilon_times_dt_stop</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">gtis</span><span class="p">)</span>
        <span class="n">idxs</span><span class="p">[</span><span class="n">idxs</span> <span class="o">==</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">dt_start</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="n">idxs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">dt_stop</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="n">idxs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">epsilon_times_dt_start</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">dt_start</span>
        <span class="n">epsilon_times_dt_stop</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">dt_stop</span>

    <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">gtis</span><span class="p">)</span> <span class="ow">or</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gtis</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid time interval for the given GTIs&quot;</span><span class="p">)</span>

    <span class="n">spectrum_start_bins</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spectrum_stop_bins</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">gti_low</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt_start</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">epsilon_times_dt_start</span>
    <span class="n">gti_up</span> <span class="o">=</span> <span class="n">gtis</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt_stop</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">epsilon_times_dt_stop</span>

    <span class="k">for</span> <span class="n">g0</span><span class="p">,</span> <span class="n">g1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gti_low</span><span class="p">,</span> <span class="n">gti_up</span><span class="p">):</span>
        <span class="n">startbin</span><span class="p">,</span> <span class="n">stopbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="n">g0</span><span class="p">,</span> <span class="n">g1</span><span class="p">],</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">stopbin</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">stopbin</span> <span class="o">&gt;</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">stopbin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="n">startbin</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">g0</span><span class="p">:</span>
            <span class="n">startbin</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Would be g[1] - dt/2, but stopbin is the end of an interval</span>
        <span class="c1"># so one has to add one bin</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="n">stopbin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">g1</span><span class="p">:</span>
            <span class="n">stopbin</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">spectrum_start_bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startbin</span><span class="p">)</span>
        <span class="n">spectrum_stop_bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stopbin</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spectrum_start_bins</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spectrum_stop_bins</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">generate_indices_of_boundaries</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get index boundaries and times from different parts of the observation.</span>

<span class="sd">    It wraps around `generate_indices_of_gti_boundaries`,</span>
<span class="sd">    `generate_indices_of_segment_boundaries_binned`, and</span>
<span class="sd">    `generate_indices_of_segment_boundaries_unbinned` depending on:</span>

<span class="sd">    + ``segment_size`` being ``None`` (give GTI boundaries, segment boundaries</span>
<span class="sd">      otherwise)</span>
<span class="sd">    + ``dt`` being 0 or nonzero (unevenly sampled, evenly sampled otherwise)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; times = [0.1, 0.2, 0.5, 0.8, 1.1]</span>
<span class="sd">    &gt;&gt;&gt; gtis = [[0, 0.55], [0.6, 2.1]]</span>
<span class="sd">    &gt;&gt;&gt; vals0 = generate_indices_of_boundaries(times, gtis, segment_size=None)</span>
<span class="sd">    &gt;&gt;&gt; vals1 = generate_indices_of_gti_boundaries(times, gtis)</span>
<span class="sd">    &gt;&gt;&gt; assert check_iterables_close(vals0, vals1)</span>
<span class="sd">    &gt;&gt;&gt; vals0 = generate_indices_of_boundaries(times, gtis, segment_size=0.5)</span>
<span class="sd">    &gt;&gt;&gt; vals1 = generate_indices_of_segment_boundaries_unbinned(times, gtis, segment_size=0.5)</span>
<span class="sd">    &gt;&gt;&gt; assert check_iterables_close(vals0, vals1)</span>
<span class="sd">    &gt;&gt;&gt; times = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]</span>
<span class="sd">    &gt;&gt;&gt; gtis = [[0.05, 0.55]]</span>
<span class="sd">    &gt;&gt;&gt; vals0 = generate_indices_of_boundaries(times, gtis, segment_size=0.5, dt=0.1)</span>
<span class="sd">    &gt;&gt;&gt; vals1 = generate_indices_of_segment_boundaries_binned(times, gtis, 0.5, dt=0.1)</span>
<span class="sd">    &gt;&gt;&gt; assert check_iterables_close(vals0, vals1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">segment_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">segment_iter</span> <span class="o">=</span> <span class="n">generate_indices_of_segment_boundaries_unbinned</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">segment_iter</span> <span class="o">=</span> <span class="n">generate_indices_of_segment_boundaries_binned</span><span class="p">(</span>
                <span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">segment_iter</span> <span class="o">=</span> <span class="n">generate_indices_of_gti_boundaries</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">segment_iter</span>


<div class="viewcode-block" id="generate_indices_of_gti_boundaries">
<a class="viewcode-back" href="../../api.html#stingray.gti.generate_indices_of_gti_boundaries">[docs]</a>
<span class="k">def</span> <span class="nf">generate_indices_of_gti_boundaries</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the indices of events from different GTIs of the observation.</span>

<span class="sd">    This is a generator, yielding the boundaries of each GTI and the</span>
<span class="sd">    corresponding indices in the time array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : float `np.array`</span>
<span class="sd">        Array of times.</span>
<span class="sd">    gti : [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        Good time intervals.</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    dt : float</span>
<span class="sd">        If times are uniformly binned, this is the binning time.</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    g0: float</span>
<span class="sd">        Start time of current GTI.</span>
<span class="sd">    g1: float</span>
<span class="sd">        End time of current GTI.</span>
<span class="sd">    startidx: int</span>
<span class="sd">        Start index of the current GTI in the time array.</span>
<span class="sd">    stopidx: int</span>
<span class="sd">        End index of the current GTI in the time array. Note that this is</span>
<span class="sd">        larger by one, so that `time[startidx:stopidx]` returns the correct</span>
<span class="sd">        time interval.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; times = [0.1, 0.2, 0.5, 0.8, 1.1]</span>
<span class="sd">    &gt;&gt;&gt; gtis = [[0, 0.55], [0.6, 2.1]]</span>
<span class="sd">    &gt;&gt;&gt; vals = generate_indices_of_gti_boundaries(times, gtis)</span>
<span class="sd">    &gt;&gt;&gt; v0 = next(vals)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(v0[:2], gtis[0])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(v0[2:], [0, 3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    <span class="n">startidx</span><span class="p">,</span> <span class="n">stopidx</span> <span class="o">=</span> <span class="n">gti_border_bins</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gti</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">gti</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">startidx</span><span class="p">,</span> <span class="n">stopidx</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span></div>



<div class="viewcode-block" id="generate_indices_of_segment_boundaries_unbinned">
<a class="viewcode-back" href="../../api.html#stingray.gti.generate_indices_of_segment_boundaries_unbinned">[docs]</a>
<span class="k">def</span> <span class="nf">generate_indices_of_segment_boundaries_unbinned</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">check_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the indices of events from different segments of the observation.</span>

<span class="sd">    This is a generator, yielding the boundaries of each segment and the</span>
<span class="sd">    corresponding indices in the time array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : float `np.array`</span>
<span class="sd">        Array of times.</span>
<span class="sd">    gti : [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        Good time intervals.</span>
<span class="sd">    segment_size : float</span>
<span class="sd">        Length of segments.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    check_sorted : bool, default True</span>
<span class="sd">        If True, checks that the time array is sorted.</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    t0: float</span>
<span class="sd">        Start time of current segment.</span>
<span class="sd">    t1: float</span>
<span class="sd">        End time of current segment.</span>
<span class="sd">    startidx: int</span>
<span class="sd">        Start index of the current segment in the time array.</span>
<span class="sd">    stopidx: int</span>
<span class="sd">        End index of the current segment in the time array. Note that this is</span>
<span class="sd">        larger by one, so that `time[startidx:stopidx]` returns the correct</span>
<span class="sd">        time interval.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; times = [0.1, 0.2, 0.5, 0.8, 1.1]</span>
<span class="sd">    &gt;&gt;&gt; gtis = [[0, 0.55], [0.6, 2.1]]</span>
<span class="sd">    &gt;&gt;&gt; vals = generate_indices_of_segment_boundaries_unbinned(</span>
<span class="sd">    ...    times, gtis, 0.5)</span>
<span class="sd">    &gt;&gt;&gt; v0 = next(vals)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(v0[:2], [0, 0.5])</span>
<span class="sd">    &gt;&gt;&gt; # Note: 0.5 is not included in the interval</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(v0[2:], [0, 2])</span>
<span class="sd">    &gt;&gt;&gt; v1 = next(vals)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(v1[:2], [0.6, 1.1])</span>
<span class="sd">    &gt;&gt;&gt; # Again: 1.1 is not included in the interval</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(v1[2:], [3, 4])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

    <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">time_intervals_from_gtis</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_sorted</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">is_sorted</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="s2">&quot;Array is not sorted&quot;</span>

    <span class="n">all_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>  <span class="c1"># Wrap in a numpy array</span>
            <span class="nb">list</span><span class="p">(</span>  <span class="c1"># Transform into a proper iterable. Set is not recognized by np.array</span>
                <span class="nb">set</span><span class="p">(</span>  <span class="c1"># Only unique values. Start and stop have a lot of overlap</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">])</span>  <span class="c1"># Concatenate start and stop</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">idxs</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">all_times</span><span class="p">)</span>
    <span class="n">idx_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_times</span><span class="p">,</span> <span class="n">idxs</span><span class="p">)])</span>
    <span class="n">startidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">([</span><span class="n">idx_dict</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">start</span><span class="p">])</span>
    <span class="n">stopidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">([</span><span class="n">idx_dict</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stop</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">startidx</span><span class="p">,</span> <span class="n">stopidx</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span></div>



<div class="viewcode-block" id="generate_indices_of_segment_boundaries_binned">
<a class="viewcode-back" href="../../api.html#stingray.gti.generate_indices_of_segment_boundaries_binned">[docs]</a>
<span class="k">def</span> <span class="nf">generate_indices_of_segment_boundaries_binned</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the indices of binned times from different segments of the observation.</span>

<span class="sd">    This is a generator, yielding the boundaries of each segment and the</span>
<span class="sd">    corresponding indices in the time array</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : float `np.array`</span>
<span class="sd">        Array of times, uniformly sampled</span>
<span class="sd">    gti : [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        good time intervals</span>
<span class="sd">    segment_size : float</span>
<span class="sd">        length of segments</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    t0: float</span>
<span class="sd">        First time value, from the time array, in the current segment</span>
<span class="sd">    t1: float</span>
<span class="sd">        Last time value, from the time array, in the current segment</span>
<span class="sd">    startidx: int</span>
<span class="sd">        Start index of the current segment in the time array</span>
<span class="sd">    stopidx: int</span>
<span class="sd">        End index of the current segment in the time array. Note that this is</span>
<span class="sd">        larger by one, so that `time[startidx:stopidx]` returns the correct</span>
<span class="sd">        time interval.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; times = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]</span>
<span class="sd">    &gt;&gt;&gt; gtis = [[0.05, 0.55]]</span>
<span class="sd">    &gt;&gt;&gt; vals = generate_indices_of_segment_boundaries_binned(times, gtis, 0.5, dt=0.1)</span>
<span class="sd">    &gt;&gt;&gt; v0 = next(vals)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(v0[:2], [0.05, 0.55])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(v0[2:], [0, 5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    <span class="n">startidx</span><span class="p">,</span> <span class="n">stopidx</span> <span class="o">=</span> <span class="n">bin_intervals_from_gtis</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">startidx</span><span class="p">,</span> <span class="n">stopidx</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">times</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">times</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, [{&#39;name&#39;: &#39;Stingray Developers&#39;, &#39;email&#39;: &#39;spectraltiming-stingray@googlegroups.com&#39;}].<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 8.0.2. &nbsp;
    Last built 09 Oct 2024. <br/>
  </p>
</footer>
  </body>
</html>