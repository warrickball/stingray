<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>stingray.utils &#8212; stingray v</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-astropy.css?v=9d21690f" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=2afd17ea" />
    
    <script src="../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <link rel="icon" href="../../_static/stingray_logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../index.html">stingray v</a>
	 &#187;
      </li>
      <li><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for stingray.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">histogram</span> <span class="k">as</span> <span class="n">histogram_np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">histogram2d</span> <span class="k">as</span> <span class="n">histogram2d_np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">histogramdd</span> <span class="k">as</span> <span class="n">histogramdd_np</span>
<span class="kn">from</span> <span class="nn">.loggingconfig</span> <span class="kn">import</span> <span class="n">setup_logger</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">()</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pyfftw</span>
    <span class="kn">from</span> <span class="nn">pyfftw.interfaces.numpy_fft</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">ifft</span><span class="p">,</span>
        <span class="n">fft</span><span class="p">,</span>
        <span class="n">fftfreq</span><span class="p">,</span>
        <span class="n">fftn</span><span class="p">,</span>
        <span class="n">ifftn</span><span class="p">,</span>
        <span class="n">fftshift</span><span class="p">,</span>
        <span class="n">fft2</span><span class="p">,</span>
        <span class="n">ifftshift</span><span class="p">,</span>
        <span class="n">rfft</span><span class="p">,</span>
        <span class="n">rfftfreq</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">pyfftw</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="n">HAS_PYFFTW</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using PyFFTW&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">ifft</span><span class="p">,</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftfreq</span><span class="p">,</span> <span class="n">fftn</span><span class="p">,</span> <span class="n">ifftn</span><span class="p">,</span> <span class="n">fftshift</span><span class="p">,</span> <span class="n">fft2</span><span class="p">,</span> <span class="n">ifftshift</span><span class="p">,</span> <span class="n">rfft</span><span class="p">,</span> <span class="n">rfftfreq</span>

    <span class="n">HAS_PYFFTW</span> <span class="o">=</span> <span class="kc">False</span>


<span class="c1"># If numba is installed, import jit. Otherwise, define an empty decorator with</span>
<span class="c1"># the same name.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>

    <span class="n">HAS_NUMBA</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">,</span> <span class="n">float32</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">int32</span><span class="p">,</span> <span class="n">int64</span>
    <span class="kn">from</span> <span class="nn">numba.core.errors</span> <span class="kn">import</span> <span class="n">NumbaValueError</span><span class="p">,</span> <span class="n">NumbaNotImplementedError</span><span class="p">,</span> <span class="n">TypingError</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Numba not installed. Faking it&quot;</span><span class="p">)</span>
    <span class="n">HAS_NUMBA</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">NumbaValueError</span> <span class="o">=</span> <span class="n">NumbaNotImplementedError</span> <span class="o">=</span> <span class="n">TypingError</span> <span class="o">=</span> <span class="ne">Exception</span>

    <span class="k">def</span> <span class="nf">njit</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span>

        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">decorator</span>

    <span class="n">jit</span> <span class="o">=</span> <span class="n">njit</span>

    <span class="k">def</span> <span class="nf">vectorize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">decorator</span>

    <span class="k">def</span> <span class="nf">generic</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">float32</span> <span class="o">=</span> <span class="n">float64</span> <span class="o">=</span> <span class="n">int32</span> <span class="o">=</span> <span class="n">int64</span> <span class="o">=</span> <span class="n">generic</span>

    <span class="k">def</span> <span class="nf">prange</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> <span class="k">as</span> <span class="n">show_progress</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">show_progress</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">statsmodels.robust</span> <span class="kn">import</span> <span class="n">mad</span> <span class="k">as</span> <span class="n">mad</span>  <span class="c1"># pylint: disable=unused-import</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">mad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.6745</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mean Absolute Deviation (MAD) along an axis.</span>

<span class="sd">        Straight from statsmodels&#39;s source code, adapted</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : iterable</span>
<span class="sd">            The data along which to calculate the MAD</span>

<span class="sd">        c : float, optional</span>
<span class="sd">            The normalization constant. Defined as</span>
<span class="sd">            ``scipy.stats.norm.ppf(3/4.)``, which is approximately ``.6745``.</span>

<span class="sd">        axis : int, optional, default ``0``</span>
<span class="sd">            Axis along which to calculate ``mad``. Default is ``0``, can also</span>
<span class="sd">            be ``None``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">center</span><span class="p">))</span> <span class="o">/</span> <span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;simon&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rebin_data&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rebin_data_log&quot;</span><span class="p">,</span>
    <span class="s2">&quot;look_for_array_in_array&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_string&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_iterable&quot;</span><span class="p">,</span>
    <span class="s2">&quot;order_list_of_arrays&quot;</span><span class="p">,</span>
    <span class="s2">&quot;optimal_bin_time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;contiguous_regions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_int&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_random_state&quot;</span><span class="p">,</span>
    <span class="s2">&quot;baseline_als&quot;</span><span class="p">,</span>
    <span class="s2">&quot;excess_variance&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_window&quot;</span><span class="p">,</span>
    <span class="s2">&quot;poisson_symmetrical_errors&quot;</span><span class="p">,</span>
    <span class="s2">&quot;standard_error&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nearest_power_of_two&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_nearest&quot;</span><span class="p">,</span>
    <span class="s2">&quot;check_isallfinite&quot;</span><span class="p">,</span>
    <span class="s2">&quot;heaviside&quot;</span><span class="p">,</span>
    <span class="s2">&quot;make_dictionary_lowercase&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="make_dictionary_lowercase">
<a class="viewcode-back" href="../../api.html#stingray.utils.make_dictionary_lowercase">[docs]</a>
<span class="k">def</span> <span class="nf">make_dictionary_lowercase</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make all keys of a dictionary lowercase.</span>

<span class="sd">    Optionally, if some values are dictionaries, they can be made lowercase too.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dictionary : dict</span>
<span class="sd">        The dictionary to be made lowercase</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    recursive : bool</span>
<span class="sd">        If ``True``, make all keys of nested dictionaries lowercase too.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; d1 = {&quot;A&quot;: 1, &quot;B&quot;: 2, &quot;C&quot;: {&quot;D&quot;: 3, &quot;E&quot;: {&quot;F&quot;: 4}}}</span>
<span class="sd">    &gt;&gt;&gt; d2 = make_dictionary_lowercase(d1)</span>
<span class="sd">    &gt;&gt;&gt; assert d2 == {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: {&quot;D&quot;: 3, &quot;E&quot;: {&quot;F&quot;: 4}}}</span>
<span class="sd">    &gt;&gt;&gt; d3 = make_dictionary_lowercase(d1, recursive=True)</span>
<span class="sd">    &gt;&gt;&gt; assert d3 == {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: {&quot;d&quot;: 3, &quot;e&quot;: {&quot;f&quot;: 4}}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">recursive</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">make_dictionary_lowercase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">new_dict</span></div>



<span class="k">def</span> <span class="nf">force_array</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an input to a numpy array.</span>

<span class="sd">    If it is not iterable, convert to a 1-element array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : iterable or number</span>
<span class="sd">        The input to be converted</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : numpy.ndarray</span>
<span class="sd">        The input converted to a numpy array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(force_array(1), np.ndarray)</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(force_array([1]), np.ndarray)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<div class="viewcode-block" id="heaviside">
<a class="viewcode-back" href="../../api.html#stingray.utils.heaviside">[docs]</a>
<span class="nd">@njit</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">heaviside</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Heaviside function. Returns 1 if x&gt;0, and 0 otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; heaviside(2)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; heaviside(-1)</span>
<span class="sd">    0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>



<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">any_complex_in_array</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if any element of an array is complex.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; any_complex_in_array(np.array([1, 2, 3]))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; assert any_complex_in_array(np.array([1, 2 + 1.j, 3]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">make_nd_into_arrays</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;If an array is n-dimensional, make it into many 1-dimensional arrays.</span>

<span class="sd">    Call additional dimensions, e.g. ``_dimN_M``. See examples below.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `np.ndarray`</span>
<span class="sd">        Input data</span>
<span class="sd">    label : `str`</span>
<span class="sd">        Label for the array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : `dict`</span>
<span class="sd">        Dictionary of arrays. Defaults to ``{label: array}`` if ``array`` is 1-dimensional,</span>
<span class="sd">        otherwise, e.g.: ``{label_dim1_2_3: array[1, 2, 3], ... }``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a1, a2, a3 = np.arange(3), np.arange(3, 6), np.arange(6, 9)</span>
<span class="sd">    &gt;&gt;&gt; A = np.array([a1, a2, a3]).T</span>
<span class="sd">    &gt;&gt;&gt; data = make_nd_into_arrays(A, &quot;test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(data[&quot;test_dim0&quot;], a1)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(data[&quot;test_dim1&quot;], a2)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(data[&quot;test_dim2&quot;], a3)</span>
<span class="sd">    &gt;&gt;&gt; A3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]</span>
<span class="sd">    &gt;&gt;&gt; data = make_nd_into_arrays(A3, &quot;test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(data[&quot;test_dim0_0&quot;], [1, 5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">new_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_dim</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="s2">&quot;_dim&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">label</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">dumdata</span> <span class="o">=</span> <span class="n">make_nd_into_arrays</span><span class="p">(</span><span class="n">array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="n">new_label</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dumdata</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">get_dimensions_from_list_of_column_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the dimensions of a multi-dimensional array from a list of column labels.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; labels = [&#39;test_dim0_0&#39;, &#39;test_dim0_1&#39;, &#39;test_dim0_2&#39;,</span>
<span class="sd">    ...           &#39;test_dim1_0&#39;, &#39;test_dim1_1&#39;, &#39;test_dim1_2&#39;, &#39;test&#39;, &#39;bu&#39;]</span>
<span class="sd">    &gt;&gt;&gt; keys, dimensions = get_dimensions_from_list_of_column_labels(labels, &quot;test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; for key0, key1 in zip(labels[:6], keys): assert key0 == key1</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(dimensions, [2, 3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">count_dimensions</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^&quot;</span> <span class="o">+</span> <span class="n">label</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;_dim([0-9]+(_[0-9]+)*)&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">all_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">new_count_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">count_dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">count_dimensions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_count_dimensions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count_dimensions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">count_dimensions</span><span class="p">,</span> <span class="n">new_count_dimensions</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_keys</span><span class="p">),</span> <span class="n">count_dimensions</span> <span class="o">+</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">make_1d_arrays_into_nd</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Literally the opposite of make_nd_into_arrays.</span>

<span class="sd">    Call additional dimensions, e.g. ``_dimN_M``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : dict</span>
<span class="sd">        Input data</span>
<span class="sd">    label : `str`</span>
<span class="sd">        Label for the array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array : `np.array`</span>
<span class="sd">        N-dimensional array that was stored in the data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a1, a2, a3 = np.arange(3), np.arange(3, 6), np.arange(6, 9)</span>
<span class="sd">    &gt;&gt;&gt; A = np.array([a1, a2, a3]).T</span>
<span class="sd">    &gt;&gt;&gt; data = make_nd_into_arrays(A, &quot;test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; A_ret = make_1d_arrays_into_nd(data, &quot;test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(A, A_ret)</span>
<span class="sd">    &gt;&gt;&gt; A = np.array([[[1, 2, 12], [3, 4, 34]],</span>
<span class="sd">    ...               [[5, 6, 56], [7, 8, 78]],</span>
<span class="sd">    ...               [[9, 10, 910], [11, 12, 1112]],</span>
<span class="sd">    ...               [[13, 14, 1314], [15, 16, 1516]]])</span>
<span class="sd">    &gt;&gt;&gt; data = make_nd_into_arrays(A, &quot;_test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; A_ret = make_1d_arrays_into_nd(data, &quot;_test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(A, A_ret)</span>
<span class="sd">    &gt;&gt;&gt; data = make_nd_into_arrays(a1, &quot;_test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; A_ret = make_1d_arrays_into_nd(data, &quot;_test&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(a1, A_ret)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>

    <span class="c1"># Get the dimensionality of the data</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">all_keys</span><span class="p">,</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="n">get_dimensions_from_list_of_column_labels</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">label</span><span class="p">)</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">arrays</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>


<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_check_isallfinite_numba</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if all elements of an array are finite.</span>

<span class="sd">    This is faster than ``np.isfinite`` for large arrays, because it</span>
<span class="sd">    exits at the first occurrence of a non-finite value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; assert _check_isallfinite_numba(np.array([1., 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; _check_isallfinite_numba(np.array([1., np.inf, 3.]))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="check_isallfinite">
<a class="viewcode-back" href="../../api.html#stingray.utils.check_isallfinite">[docs]</a>
<span class="k">def</span> <span class="nf">check_isallfinite</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if all elements of an array are finite.</span>

<span class="sd">    Calls ``_check_isallfinite_numba`` if numba is installed, otherwise</span>
<span class="sd">    it uses ``np.isfinite``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; assert check_isallfinite([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; check_isallfinite([1, np.inf, 3])</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; check_isallfinite([1, np.nan, 3])</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">HAS_NUMBA</span><span class="p">:</span>
        <span class="c1"># Numba is very picky about the type of the input array. If an exception</span>
        <span class="c1"># occurs in the numba-compiled function, use the default Numpy implementation.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_check_isallfinite_numba</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">array</span><span class="p">)))</span></div>



<span class="k">def</span> <span class="nf">is_sorted</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if an array is sorted.</span>

<span class="sd">    Checks if an array has extended precision before calling the</span>
<span class="sd">    ``is_sorted`` numba-compiled function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : iterable</span>
<span class="sd">        The array to be checked</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_sorted : bool</span>
<span class="sd">        True if the array is sorted, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="c1"># If the array is empty or has only one element, it is sorted</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># If Numba is not installed, use numpy&#39;s implementation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_NUMBA</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Test if value is compatible with Numba&#39;s type system</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_is_sorted_numba</span><span class="p">(</span><span class="n">array</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">except</span> <span class="n">NumbaValueError</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_is_sorted_numba</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>


<span class="nd">@njit</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_is_sorted_numba</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if an array is sorted.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The array cannot have extended precision.</span>
<span class="sd">        This function should always be wrapped into a function that</span>
<span class="sd">        checks the type of the array and converts it to float if needed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : iterable</span>
<span class="sd">        The array to be checked</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_sorted : bool</span>
<span class="sd">        True if the array is sorted, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_root_squared_mean</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">array</span><span class="o">.</span><span class="n">size</span>


<div class="viewcode-block" id="simon">
<a class="viewcode-back" href="../../api.html#stingray.utils.simon">[docs]</a>
<span class="k">def</span> <span class="nf">simon</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The Statistical Interpretation MONitor.</span>

<span class="sd">    A warning system designed to always remind the user that Simon</span>
<span class="sd">    is watching him/her.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    message : string</span>
<span class="sd">        The message that is thrown</span>

<span class="sd">    kwargs : dict</span>
<span class="sd">        The rest of the arguments that are passed to ``warnings.warn``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;SIMON says: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="rebin_data">
<a class="viewcode-back" href="../../api.html#stingray.utils.rebin_data">[docs]</a>
<span class="k">def</span> <span class="nf">rebin_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx_new</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rebin some data to an arbitrary new data resolution. Either sum</span>
<span class="sd">    the data points in the new bins or average them.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: iterable</span>
<span class="sd">        The dependent variable with some resolution, which can vary throughout</span>
<span class="sd">        the time series.</span>

<span class="sd">    y: iterable</span>
<span class="sd">        The independent variable to be binned</span>

<span class="sd">    dx_new: float</span>
<span class="sd">        The new resolution of the dependent variable ``x``</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    yerr: iterable, optional</span>
<span class="sd">        The uncertainties of ``y``, to be propagated during binning.</span>

<span class="sd">    method: {``sum`` | ``average`` | ``mean``}, optional, default ``sum``</span>
<span class="sd">        The method to be used in binning. Either sum the samples ``y`` in</span>
<span class="sd">        each new bin of ``x``, or take the arithmetic mean.</span>

<span class="sd">    dx: float</span>
<span class="sd">        The old resolution (otherwise, calculated from difference between</span>
<span class="sd">        time bins)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xbin: numpy.ndarray</span>
<span class="sd">        The midpoints of the new bins in ``x``</span>

<span class="sd">    ybin: numpy.ndarray</span>
<span class="sd">        The binned quantity ``y``</span>

<span class="sd">    ybin_err: numpy.ndarray</span>
<span class="sd">        The uncertainties of the binned values of ``y``.</span>

<span class="sd">    step_size: float</span>
<span class="sd">        The size of the binning step</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(0, 100, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; y = np.ones(x.size)</span>
<span class="sd">    &gt;&gt;&gt; yerr = np.ones(x.size)</span>
<span class="sd">    &gt;&gt;&gt; xbin, ybin, ybinerr, step_size = rebin_data(</span>
<span class="sd">    ...     x, y, 4, yerr=yerr, method=&#39;sum&#39;, dx=0.01)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(ybin, 400)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(ybinerr, 20)</span>
<span class="sd">    &gt;&gt;&gt; xbin, ybin, ybinerr, step_size = rebin_data(</span>
<span class="sd">    ...     x, y, 4, yerr=yerr, method=&#39;mean&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(ybin, 1)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(ybinerr, 0.05)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">yerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">dx_old</span> <span class="o">=</span> <span class="n">dx</span>
    <span class="k">elif</span> <span class="n">dx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dx_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dx_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dx_new</span> <span class="o">&lt;</span> <span class="n">dx_old</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;New frequency resolution must be larger than &quot;</span> <span class="s2">&quot;old frequency resolution.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># left and right bin edges</span>
    <span class="c1"># assumes that the points given in `x` correspond to</span>
    <span class="c1"># the left bin edges</span>
    <span class="n">xedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx_old</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

    <span class="c1"># new regularly binned resolution</span>
    <span class="n">xbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx_new</span><span class="p">,</span> <span class="n">dx_new</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xbin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">outputerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xbin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">yerr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">step_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xbin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">all_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="n">xbin</span><span class="p">)</span>
    <span class="n">min_inds</span> <span class="o">=</span> <span class="n">all_x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">max_inds</span> <span class="o">=</span> <span class="n">all_x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">xmins</span> <span class="o">=</span> <span class="n">xbin</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xmaxs</span> <span class="o">=</span> <span class="n">xbin</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">min_ind</span><span class="p">,</span> <span class="n">max_ind</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xmins</span><span class="p">,</span> <span class="n">xmaxs</span><span class="p">,</span> <span class="n">min_inds</span><span class="p">,</span> <span class="n">max_inds</span><span class="p">)):</span>
        <span class="n">filtered_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">min_ind</span> <span class="p">:</span> <span class="n">max_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">filtered_yerr</span> <span class="o">=</span> <span class="n">yerr</span><span class="p">[</span><span class="n">min_ind</span> <span class="p">:</span> <span class="n">max_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">filtered_y</span><span class="p">)</span>
        <span class="n">outputerr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">filtered_yerr</span><span class="p">)</span>
        <span class="n">step_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_ind</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">min_ind</span>

        <span class="n">prev_dx</span> <span class="o">=</span> <span class="n">xedges</span><span class="p">[</span><span class="n">min_ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">xedges</span><span class="p">[</span><span class="n">min_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">prev_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">xedges</span><span class="p">[</span><span class="n">min_ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">prev_dx</span>
        <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">y</span><span class="p">[</span><span class="n">min_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">prev_frac</span>
        <span class="n">outputerr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">yerr</span><span class="p">[</span><span class="n">min_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">prev_frac</span>
        <span class="n">step_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">prev_frac</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">max_ind</span> <span class="o">==</span> <span class="n">xedges</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">dx_post</span> <span class="o">=</span> <span class="n">xedges</span><span class="p">[</span><span class="n">max_ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">xedges</span><span class="p">[</span><span class="n">max_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">post_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xedges</span><span class="p">[</span><span class="n">max_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx_post</span>
            <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">y</span><span class="p">[</span><span class="n">max_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">post_frac</span>
            <span class="n">outputerr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">yerr</span><span class="p">[</span><span class="n">max_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">post_frac</span>
            <span class="n">step_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">post_frac</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;avg&quot;</span><span class="p">,</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="s2">&quot;arithmetic mean&quot;</span><span class="p">]:</span>
        <span class="n">ybin</span> <span class="o">=</span> <span class="n">output</span> <span class="o">/</span> <span class="n">step_size</span>
        <span class="n">ybinerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">outputerr</span><span class="p">)</span> <span class="o">/</span> <span class="n">step_size</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
        <span class="n">ybin</span> <span class="o">=</span> <span class="n">output</span>
        <span class="n">ybinerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">outputerr</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Method for summing or averaging not recognized. &quot;</span>
            <span class="s2">&quot;Please enter either &#39;sum&#39; or &#39;mean&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="n">tseg</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx_old</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tseg</span> <span class="o">/</span> <span class="n">dx_new</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ybin</span> <span class="o">=</span> <span class="n">ybin</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ybinerr</span> <span class="o">=</span> <span class="n">ybinerr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">dx_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dx_old</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dx_old</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dx_old</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">dx_var</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">new_x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dx_old</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">dx_new</span><span class="p">)</span>
    <span class="n">xbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ybin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">dx_new</span> <span class="o">+</span> <span class="n">new_x0</span>

    <span class="k">return</span> <span class="n">xbin</span><span class="p">,</span> <span class="n">ybin</span><span class="p">,</span> <span class="n">ybinerr</span><span class="p">,</span> <span class="n">step_size</span></div>



<div class="viewcode-block" id="rebin_data_log">
<a class="viewcode-back" href="../../api.html#stingray.utils.rebin_data_log">[docs]</a>
<span class="k">def</span> <span class="nf">rebin_data_log</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">y_err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Logarithmic re-bin of some data. Particularly useful for the power</span>
<span class="sd">    spectrum.</span>

<span class="sd">    The new dependent variable depends on the previous dependent variable</span>
<span class="sd">    modified by a factor f:</span>

<span class="sd">    .. math::</span>

<span class="sd">        d\\nu_j = d\\nu_{j-1} (1+f)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: iterable</span>
<span class="sd">        The dependent variable with some resolution ``dx_old = x[1]-x[0]``</span>

<span class="sd">    y: iterable</span>
<span class="sd">        The independent variable to be binned</span>

<span class="sd">    f: float</span>
<span class="sd">        The factor of increase of each bin wrt the previous one.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    yerr: iterable, optional</span>
<span class="sd">        The uncertainties of ``y`` to be propagated during binning.</span>

<span class="sd">    method: {``sum`` | ``average`` | ``mean``}, optional, default ``sum``</span>
<span class="sd">        The method to be used in binning. Either sum the samples ``y`` in</span>
<span class="sd">        each new bin of ``x`` or take the arithmetic mean.</span>

<span class="sd">    dx: float, optional</span>
<span class="sd">        The binning step of the initial ``x``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xbin: numpy.ndarray</span>
<span class="sd">        The midpoints of the new bins in ``x``</span>

<span class="sd">    ybin: numpy.ndarray</span>
<span class="sd">        The binned quantity ``y``</span>

<span class="sd">    ybin_err: numpy.ndarray</span>
<span class="sd">        The uncertainties of the binned values of ``y``</span>

<span class="sd">    step_size: float</span>
<span class="sd">        The size of the binning step</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dx_init</span> <span class="o">=</span> <span class="n">apply_function_if_none</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">y_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">apply_function_if_none</span><span class="p">(</span><span class="n">y_err</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be of the same length!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y_err</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y and y_err must be of the same length!&quot;</span><span class="p">)</span>

    <span class="n">minx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span>  <span class="c1"># frequency to start from</span>
    <span class="n">maxx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># maximum frequency to end</span>
    <span class="n">binx_for_stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">minx</span><span class="p">,</span> <span class="n">minx</span> <span class="o">+</span> <span class="n">dx_init</span><span class="p">]</span>  <span class="c1"># first</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">dx_init</span>  <span class="c1"># the frequency resolution of the first bin</span>

    <span class="c1"># until we reach the maximum frequency, increase the width of each</span>
    <span class="c1"># frequency bin by f</span>
    <span class="k">while</span> <span class="n">binx_for_stats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">maxx</span><span class="p">:</span>
        <span class="n">binx_for_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binx_for_stats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">f</span><span class="p">))</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">binx_for_stats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">binx_for_stats</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">binx_for_stats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">binx_for_stats</span><span class="p">)</span>

    <span class="n">real</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">real</span>
    <span class="n">real_err</span> <span class="o">=</span> <span class="n">y_err</span><span class="o">.</span><span class="n">real</span>
    <span class="c1"># compute the mean of the ys that fall into each new frequency bin.</span>
    <span class="c1"># we cast to np.double due to scipy&#39;s bad handling of longdoubles</span>
    <span class="n">binx</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">binno</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">binned_statistic</span><span class="p">(</span>
        <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binx_for_stats</span>
    <span class="p">)</span>

    <span class="n">biny</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">binno</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">binned_statistic</span><span class="p">(</span>
        <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">real</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binx_for_stats</span>
    <span class="p">)</span>

    <span class="n">biny_err</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">binno</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">binned_statistic</span><span class="p">(</span>
        <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span>
        <span class="n">real_err</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span>
        <span class="n">statistic</span><span class="o">=</span><span class="n">_root_squared_mean</span><span class="p">,</span>
        <span class="n">bins</span><span class="o">=</span><span class="n">binx_for_stats</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="n">imag</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">biny_imag</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">binno</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">binned_statistic</span><span class="p">(</span>
            <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">imag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">statistic</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binx_for_stats</span>
        <span class="p">)</span>

        <span class="n">biny</span> <span class="o">=</span> <span class="n">biny</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">biny_imag</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">y_err</span><span class="p">):</span>
        <span class="n">imag_err</span> <span class="o">=</span> <span class="n">y_err</span><span class="o">.</span><span class="n">imag</span>

        <span class="n">biny_err_imag</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">binno</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">binned_statistic</span><span class="p">(</span>
            <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span>
            <span class="n">imag_err</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span>
            <span class="n">statistic</span><span class="o">=</span><span class="n">_root_squared_mean</span><span class="p">,</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">binx_for_stats</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">biny_err</span> <span class="o">=</span> <span class="n">biny_err</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">biny_err_imag</span>

    <span class="c1"># compute the number of powers in each frequency bin</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">binno</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">binno</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">binno</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">,</span> <span class="n">biny_err</span><span class="p">,</span> <span class="n">nsamples</span></div>



<span class="k">def</span> <span class="nf">apply_function_if_none</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign a function value to a variable if that variable has value ``None`` on input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variable : object</span>
<span class="sd">        A variable with either some assigned value, or ``None``</span>

<span class="sd">    value : object</span>
<span class="sd">        A variable to go into the function</span>

<span class="sd">    func : function</span>
<span class="sd">        Function to apply to ``value``. Result is assigned to ``variable``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        new_value : object</span>
<span class="sd">            The new value of ``variable``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; var = 4</span>
<span class="sd">    &gt;&gt;&gt; value = np.zeros(10)</span>
<span class="sd">    &gt;&gt;&gt; apply_function_if_none(var, value, np.mean)</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; var = None</span>
<span class="sd">    &gt;&gt;&gt; apply_function_if_none(var, value, lambda y: float(np.mean(y)))</span>
<span class="sd">    0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">variable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">variable</span>


<span class="k">def</span> <span class="nf">assign_value_if_none</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign a value to a variable if that variable has value ``None`` on input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : object</span>
<span class="sd">        A variable with either some assigned value, or ``None``</span>

<span class="sd">    default : object The value to assign to the variable ``value`` if</span>
<span class="sd">    ``value is None`` returns ``True``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        new_value : object</span>
<span class="sd">            The new value of ``value``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">default</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">value</span>


<div class="viewcode-block" id="look_for_array_in_array">
<a class="viewcode-back" href="../../api.html#stingray.utils.look_for_array_in_array">[docs]</a>
<span class="k">def</span> <span class="nf">look_for_array_in_array</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a subset of values in an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array1 : iterable</span>
<span class="sd">        An array with values to be searched</span>

<span class="sd">    array2 : iterable</span>
<span class="sd">        A second array which potentially contains a subset of values</span>
<span class="sd">        also contained in ``array1``</span>

<span class="sd">    Returns ------- array3 : iterable An array with the subset of values</span>
<span class="sd">    contained in both ``array1`` and ``array2``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array1</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array2</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_string">
<a class="viewcode-back" href="../../api.html#stingray.utils.is_string">[docs]</a>
<span class="k">def</span> <span class="nf">is_string</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Portable function to answer whether a variable is a string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : object</span>
<span class="sd">        An object that is potentially a string</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    isstring : bool</span>
<span class="sd">        A boolean decision on whether ``s`` is a string or not</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_iterable">
<a class="viewcode-back" href="../../api.html#stingray.utils.is_iterable">[docs]</a>
<span class="k">def</span> <span class="nf">is_iterable</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test if a variable  is an iterable.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    var : object</span>
<span class="sd">        The variable to be tested for iterably-ness</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_iter : bool</span>
<span class="sd">        Returns ``True`` if ``var`` is an ``Iterable``, ``False`` otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span></div>



<div class="viewcode-block" id="order_list_of_arrays">
<a class="viewcode-back" href="../../api.html#stingray.utils.order_list_of_arrays">[docs]</a>
<span class="k">def</span> <span class="nf">order_list_of_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sort an array according to the specified order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : iterable</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : list or dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="n">order</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
    <span class="k">elif</span> <span class="n">is_iterable</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="n">order</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="optimal_bin_time">
<a class="viewcode-back" href="../../api.html#stingray.utils.optimal_bin_time">[docs]</a>
<span class="k">def</span> <span class="nf">optimal_bin_time</span><span class="p">(</span><span class="n">fftlen</span><span class="p">,</span> <span class="n">tbin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Vary slightly the bin time to have a power of two number of bins.</span>

<span class="sd">    Given an FFT length and a proposed bin time, return a bin time</span>
<span class="sd">    slightly shorter than the original, that will produce a power-of-two number</span>
<span class="sd">    of FFT bins.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fftlen : int</span>
<span class="sd">        Number of positive frequencies in a proposed Fourier spectrum</span>

<span class="sd">    tbin : float</span>
<span class="sd">        The proposed time resolution of a light curve</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : float</span>
<span class="sd">        A time resolution that will produce a Fourier spectrum with ``fftlen`` frequencies and</span>
<span class="sd">        a number of FFT bins that are a power of two</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">fftlen</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">fftlen</span> <span class="o">/</span> <span class="n">tbin</span><span class="p">)))</span></div>



<div class="viewcode-block" id="contiguous_regions">
<a class="viewcode-back" href="../../api.html#stingray.utils.contiguous_regions">[docs]</a>
<span class="k">def</span> <span class="nf">contiguous_regions</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find contiguous ``True`` regions of the boolean array ``condition``.</span>

<span class="sd">    Return a 2D array where the first column is the start index of the region</span>
<span class="sd">    and the second column is the end index, found on [so-contiguous]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : bool array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idx : ``[[i0_0, i0_1], [i1_0, i1_1], ...]``</span>
<span class="sd">        A list of integer couples, with the start and end of each ``True`` blocks</span>
<span class="sd">        in the original array</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. [so-contiguous] http://stackoverflow.com/questions/4494404/find-large-number-of-consecutive-values-fulfilling-condition-in-a-numpy-array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the indices of changes in &quot;condition&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">condition</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">condition</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">(</span><span class="n">idx</span><span class="p">,)</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="c1"># We need to start things after the change in &quot;condition&quot;. Therefore,</span>
    <span class="c1"># we&#39;ll shift the index by 1 to the right.</span>
    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># If the start of condition is True prepend a 0</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># If the end of condition is True, append the length of the array</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">condition</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
    <span class="c1"># Reshape the result into two columns</span>
    <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">idx</span></div>



<div class="viewcode-block" id="is_int">
<a class="viewcode-back" href="../../api.html#stingray.utils.is_int">[docs]</a>
<span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test if object is an integer.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span></div>



<div class="viewcode-block" id="get_random_state">
<a class="viewcode-back" href="../../api.html#stingray.utils.get_random_state">[docs]</a>
<span class="k">def</span> <span class="nf">get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Mersenne Twister pseudo-random number generator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seed : integer or ``numpy.random.RandomState``, optional, default ``None``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    random_state : mtrand.RandomState object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">random_state</span><span class="p">:</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">mtrand</span><span class="o">.</span><span class="n">_rand</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_int</span><span class="p">(</span><span class="n">random_state</span><span class="p">):</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{value}</span><span class="s2"> can&#39;t be used to generate a numpy.random.RandomState&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">random_state</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">random_state</span></div>



<span class="k">def</span> <span class="nf">_offset</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">off</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An offset.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">off</span>


<span class="k">def</span> <span class="nf">offset_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">offset_start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fit a constant offset to the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">    y : array-like</span>
<span class="sd">    offset_start : float</span>
<span class="sd">        Constant offset, initial value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    offset : float</span>
<span class="sd">        Fitted offset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

    <span class="n">par</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">_offset</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">offset_start</span><span class="p">],</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">6000</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_als</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Baseline Correction with Asymmetric Least Squares Smoothing.</span>

<span class="sd">    Modifications to the routine from Eilers &amp; Boelens 2005 [eilers-2005]_.</span>
<span class="sd">    The Python translation is partly from [so-als]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array-like</span>
<span class="sd">        the data series corresponding to ``x``</span>
<span class="sd">    lam : float</span>
<span class="sd">        the lambda parameter of the ALS method. This control how much the</span>
<span class="sd">        baseline can adapt to local changes. A higher value corresponds to a</span>
<span class="sd">        stiffer baseline</span>
<span class="sd">    p : float</span>
<span class="sd">        the asymmetry parameter of the ALS method. This controls the overall</span>
<span class="sd">        slope tollerated for the baseline. A higher value correspond to a</span>
<span class="sd">        higher possible slope</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    niter : int</span>
<span class="sd">        The number of iterations to perform</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : array-like, same size as ``y``</span>
<span class="sd">        Fitted baseline.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [eilers-2005] https://www.researchgate.net/publication/228961729_Technical_Report_Baseline_Correction_with_Asymmetric_Least_Squares_Smoothing</span>
<span class="sd">    .. [so-als] http://stackoverflow.com/questions/29156532/python-baseline-correction-library</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>

    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span>


<span class="k">def</span> <span class="nf">fix_segment_size_to_integer_samples</span><span class="p">(</span><span class="n">segment_size</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fix segment size to an integer number of bins.</span>

<span class="sd">    In the most common case, it will be reduced to an integer number of bins,</span>
<span class="sd">    approximating to the lower integer. However, when it is close to the next</span>
<span class="sd">    integer, it will be approximated to the higher integer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    segment_size : float</span>
<span class="sd">        The segment size in seconds</span>
<span class="sd">    dt : float</span>
<span class="sd">        The sample time in seconds</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    tolerance : float</span>
<span class="sd">        The tolerance to consider when approximating to the higher integer</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    segment_size : float</span>
<span class="sd">        The segment size in seconds, fixed to an integer number of bins</span>
<span class="sd">    n_bin : int</span>
<span class="sd">        The number of bins in the segment</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; seg, n = fix_segment_size_to_integer_samples(1.0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; assert seg == 1.0, n == 10</span>
<span class="sd">    &gt;&gt;&gt; seg, n = fix_segment_size_to_integer_samples(0.999, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; assert seg == 1.0, n == 10</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_bin_float</span> <span class="o">=</span> <span class="n">segment_size</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="n">n_bin_down</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">segment_size</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">n_bin_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">segment_size</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">n_bin</span> <span class="o">=</span> <span class="n">n_bin_down</span>

    <span class="k">if</span> <span class="n">n_bin_up</span> <span class="o">-</span> <span class="n">n_bin_float</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">n_bin_up</span>

    <span class="n">segment_size</span> <span class="o">=</span> <span class="n">n_bin</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="k">return</span> <span class="n">segment_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_bin</span><span class="p">)</span>


<div class="viewcode-block" id="baseline_als">
<a class="viewcode-back" href="../../api.html#stingray.utils.baseline_als">[docs]</a>
<span class="k">def</span> <span class="nf">baseline_als</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">return_baseline</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">offset_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Baseline Correction with Asymmetric Least Squares Smoothing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">        the sample time/number/position</span>
<span class="sd">    y : array-like</span>
<span class="sd">        the data series corresponding to ``x``</span>
<span class="sd">    lam : float</span>
<span class="sd">        the lambda parameter of the ALS method. This control how much the</span>
<span class="sd">        baseline can adapt to local changes. A higher value corresponds to a</span>
<span class="sd">        stiffer baseline</span>
<span class="sd">    p : float</span>
<span class="sd">        the asymmetry parameter of the ALS method. This controls the overall</span>
<span class="sd">        slope tolerated for the baseline. A higher value correspond to a</span>
<span class="sd">        higher possible slope</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    niter : int</span>
<span class="sd">        The number of iterations to perform</span>
<span class="sd">    return_baseline : bool</span>
<span class="sd">        return the baseline?</span>
<span class="sd">    offset_correction : bool</span>
<span class="sd">        also correct for an offset to align with the running mean of the scan</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y_subtracted : array-like, same size as ``y``</span>
<span class="sd">        The initial time series, subtracted from the trend</span>
<span class="sd">    baseline : array-like, same size as ``y``</span>
<span class="sd">        Fitted baseline. Only returned if return_baseline is ``True``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(0, 10, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; y = np.zeros_like(x) + 10</span>
<span class="sd">    &gt;&gt;&gt; ysub = baseline_als(x, y)</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(ysub &lt; 0.001)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">lam</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="mf">1e11</span>
    <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">0.001</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">_als</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">)</span>

    <span class="n">ysub</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">offset_correction</span><span class="p">:</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">mad</span><span class="p">(</span><span class="n">ysub</span><span class="p">)</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ysub</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">std</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">good</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Too few bins to perform baseline offset correction&quot;</span> <span class="s2">&quot; precisely. Beware of results&quot;</span>
            <span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_fit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">good</span><span class="p">],</span> <span class="n">ysub</span><span class="p">[</span><span class="n">good</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_baseline</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ysub</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">offset</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ysub</span> <span class="o">-</span> <span class="n">offset</span></div>



<div class="viewcode-block" id="excess_variance">
<a class="viewcode-back" href="../../api.html#stingray.utils.excess_variance">[docs]</a>
<span class="k">def</span> <span class="nf">excess_variance</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="s2">&quot;fvar&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the excess variance.</span>

<span class="sd">    Vaughan et al. 2003, MNRAS 345, 1271 give three measurements of source</span>
<span class="sd">    intrinsic variance: if a light curve has a total variance of :math:`S^2`,</span>
<span class="sd">    and each point has an error bar :math:`\sigma_{err}`, the *excess variance*</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math:: \sigma_{XS} = S^2 - \overline{\sigma_{err}}^2;</span>

<span class="sd">    the *normalized excess variance* is the excess variance divided by the</span>
<span class="sd">    square of the mean intensity:</span>

<span class="sd">    .. math:: \sigma_{NXS} = \dfrac{\sigma_{XS}}{\overline{x}^2};</span>

<span class="sd">    the *fractional mean square variability amplitude*, or</span>
<span class="sd">    :math:`F_{var}`, is finally defined as</span>

<span class="sd">    .. math:: F_{var} = \sqrt{\dfrac{\sigma_{XS}}{\overline{x}^2}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc : a :class:`Lightcurve` object</span>
<span class="sd">    normalization : str</span>
<span class="sd">        if ``fvar``, return the fractional mean square variability :math:`F_{var}`.</span>
<span class="sd">        If ``none``, return the unnormalized excess variance variance</span>
<span class="sd">        :math:`\sigma_{XS}`. If ``norm_xs``, return the normalized excess variance</span>
<span class="sd">        :math:`\sigma_{XS}`</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    var_xs : float</span>
<span class="sd">    var_xs_err : float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lc_mean_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">counts_err</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">lc_actual_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>
    <span class="n">var_xs</span> <span class="o">=</span> <span class="n">lc_actual_var</span> <span class="o">-</span> <span class="n">lc_mean_var</span>
    <span class="n">mean_lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>
    <span class="n">mean_ctvar</span> <span class="o">=</span> <span class="n">mean_lc</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">var_nxs</span> <span class="o">=</span> <span class="n">var_xs</span> <span class="o">/</span> <span class="n">mean_lc</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">fvar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_xs</span> <span class="o">/</span> <span class="n">mean_ctvar</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>
    <span class="n">var_nxs_err_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">lc_mean_var</span> <span class="o">/</span> <span class="n">mean_lc</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">var_nxs_err_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lc_mean_var</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">fvar</span> <span class="o">/</span> <span class="n">mean_lc</span>
    <span class="n">var_nxs_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_nxs_err_A</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">var_nxs_err_B</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">fvar_err</span> <span class="o">=</span> <span class="n">var_nxs_err</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fvar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalization</span> <span class="o">==</span> <span class="s2">&quot;fvar&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fvar</span><span class="p">,</span> <span class="n">fvar_err</span>
    <span class="k">elif</span> <span class="n">normalization</span> <span class="o">==</span> <span class="s2">&quot;norm_xs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">var_nxs</span><span class="p">,</span> <span class="n">var_nxs_err</span>
    <span class="k">elif</span> <span class="n">normalization</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span> <span class="ow">or</span> <span class="n">normalization</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">var_xs</span><span class="p">,</span> <span class="n">var_nxs_err</span> <span class="o">*</span> <span class="n">mean_lc</span><span class="o">**</span><span class="mi">2</span></div>



<div class="viewcode-block" id="create_window">
<a class="viewcode-back" href="../../api.html#stingray.utils.create_window">[docs]</a>
<span class="k">def</span> <span class="nf">create_window</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">window_type</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A method to create window functions commonly used in signal processing.</span>

<span class="sd">    Windows supported are:</span>
<span class="sd">    Hamming, Hanning, uniform (rectangular window), triangular window,</span>
<span class="sd">    blackmann window among others.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Total number of data points in window. If negative, abs is taken.</span>
<span class="sd">    window_type : {``uniform``, ``parzen``, ``hamming``, ``hanning``, ``triangular``,\</span>
<span class="sd">                 ``welch``, ``blackmann``, ``flat-top``}, optional, default ``uniform``</span>
<span class="sd">        Type of window to create.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    window: numpy.ndarray</span>
<span class="sd">        Window function of length ``N``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;N (window length) must be an integer&quot;</span><span class="p">)</span>

    <span class="n">windows</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parzen&quot;</span><span class="p">,</span>
        <span class="s2">&quot;hamming&quot;</span><span class="p">,</span>
        <span class="s2">&quot;hanning&quot;</span><span class="p">,</span>
        <span class="s2">&quot;triangular&quot;</span><span class="p">,</span>
        <span class="s2">&quot;welch&quot;</span><span class="p">,</span>
        <span class="s2">&quot;blackmann&quot;</span><span class="p">,</span>
        <span class="s2">&quot;flat-top&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;type of window must be specified as string!&quot;</span><span class="p">)</span>

    <span class="n">window_type</span> <span class="o">=</span> <span class="n">window_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">window_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong window type specified or window function is not available&quot;</span><span class="p">)</span>

    <span class="c1"># Return empty array as window if N = 0</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="n">window</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Window samples index</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Constants</span>
    <span class="n">N_minus_1</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">N_by_2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">N_minus_1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>

    <span class="c1"># Create Windows</span>
    <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s2">&quot;parzen&quot;</span><span class="p">:</span>
        <span class="n">N_parzen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">N2_plus_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">N_parzen</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_parzen</span><span class="p">)</span>
        <span class="n">windlag0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N2_plus_1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N_parzen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">windlag1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N2_plus_1</span><span class="p">,</span> <span class="n">N_parzen</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N_parzen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">window</span><span class="p">[:</span><span class="n">N2_plus_1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">windlag0</span><span class="p">)</span> <span class="o">*</span> <span class="n">windlag0</span> <span class="o">*</span> <span class="n">windlag0</span> <span class="o">*</span> <span class="mi">6</span>
        <span class="n">window</span><span class="p">[</span><span class="n">N2_plus_1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">windlag1</span> <span class="o">*</span> <span class="n">windlag1</span> <span class="o">*</span> <span class="n">windlag1</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">lagindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_parzen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">window</span><span class="p">[</span><span class="n">lagindex</span><span class="p">],</span> <span class="n">window</span><span class="p">))</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">window</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s2">&quot;hamming&quot;</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="mf">0.54</span> <span class="o">-</span> <span class="mf">0.46</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_minus_1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s2">&quot;hanning&quot;</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">N_minus_1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s2">&quot;triangular&quot;</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">N_by_2</span><span class="p">))</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s2">&quot;welch&quot;</span><span class="p">:</span>
        <span class="n">N_minus_1_by_2</span> <span class="o">=</span> <span class="n">N_minus_1</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">window</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">N_minus_1_by_2</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_minus_1_by_2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s2">&quot;blackmann&quot;</span><span class="p">:</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="mf">0.42659</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mf">0.49656</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="mf">0.076849</span>
        <span class="n">window</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">a0</span> <span class="o">-</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_minus_1</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_minus_1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s2">&quot;flat-top&quot;</span><span class="p">:</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mf">1.93</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="mf">1.29</span>
        <span class="n">a3</span> <span class="o">=</span> <span class="mf">0.388</span>
        <span class="n">a4</span> <span class="o">=</span> <span class="mf">0.028</span>
        <span class="n">window</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">a0</span>
            <span class="o">-</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_minus_1</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_minus_1</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">a3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_minus_1</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">a4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">N_minus_1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">window</span></div>



<div class="viewcode-block" id="poisson_symmetrical_errors">
<a class="viewcode-back" href="../../api.html#stingray.utils.poisson_symmetrical_errors">[docs]</a>
<span class="k">def</span> <span class="nf">poisson_symmetrical_errors</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Optimized version of frequentist symmetrical errors.</span>

<span class="sd">    Uses a lookup table in order to limit the calls to poisson_conf_interval</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    counts : iterable</span>
<span class="sd">        An array of Poisson-distributed numbers</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    err : numpy.ndarray</span>
<span class="sd">        An array of uncertainties associated with the Poisson counts in</span>
<span class="sd">        ``counts``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy.stats import poisson_conf_interval</span>
<span class="sd">    &gt;&gt;&gt; counts = np.random.randint(0, 1000, 100)</span>
<span class="sd">    &gt;&gt;&gt; # ---- Do it without the lookup table ----</span>
<span class="sd">    &gt;&gt;&gt; err_low, err_high = poisson_conf_interval(np.asanyarray(counts),</span>
<span class="sd">    ...                 interval=&#39;frequentist-confidence&#39;, sigma=1)</span>
<span class="sd">    &gt;&gt;&gt; err_low -= np.asanyarray(counts)</span>
<span class="sd">    &gt;&gt;&gt; err_high -= np.asanyarray(counts)</span>
<span class="sd">    &gt;&gt;&gt; err = (np.absolute(err_low) + np.absolute(err_high))/2.0</span>
<span class="sd">    &gt;&gt;&gt; # Do it with this function</span>
<span class="sd">    &gt;&gt;&gt; err_thisfun = poisson_symmetrical_errors(counts)</span>
<span class="sd">    &gt;&gt;&gt; # Test that results are always the same</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(err_thisfun, err)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">astropy.stats</span> <span class="kn">import</span> <span class="n">poisson_conf_interval</span>

    <span class="n">counts_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">count_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">counts_int</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">err_low</span><span class="p">,</span> <span class="n">err_high</span> <span class="o">=</span> <span class="n">poisson_conf_interval</span><span class="p">(</span>
        <span class="n">count_values</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="s2">&quot;frequentist-confidence&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="c1"># calculate approximately symmetric uncertainties</span>
    <span class="n">err_low</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">count_values</span><span class="p">)</span>
    <span class="n">err_high</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">count_values</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">err_low</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">err_high</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">count_values</span><span class="p">,</span> <span class="n">counts_int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span></div>



<div class="viewcode-block" id="standard_error">
<a class="viewcode-back" href="../../api.html#stingray.utils.standard_error">[docs]</a>
<span class="k">def</span> <span class="nf">standard_error</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">mean</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the standard error of the mean (SEM) of an array of arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xs : 2-d float array</span>
<span class="sd">        List of data point arrays.</span>

<span class="sd">    mean : 1-d float array</span>
<span class="sd">        Average of the data points.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    standard_error : 1-d float array</span>
<span class="sd">        Standard error of the mean (SEM).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_seg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xs_diff_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">standard_deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xs_diff_sq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_seg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">standard_deviation</span> <span class="o">/</span> <span class="n">n_seg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">error</span></div>



<div class="viewcode-block" id="nearest_power_of_two">
<a class="viewcode-back" href="../../api.html#stingray.utils.nearest_power_of_two">[docs]</a>
<span class="k">def</span> <span class="nf">nearest_power_of_two</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a number which is nearest to `x` and is the integral power of two.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : int, float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_nearest : int</span>
<span class="sd">        Number closest to `x` and is the integral power of two.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_lower</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
    <span class="n">x_upper</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
    <span class="n">x_nearest</span> <span class="o">=</span> <span class="n">x_lower</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_lower</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">x_upper</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x_upper</span>
    <span class="k">return</span> <span class="n">x_nearest</span></div>



<div class="viewcode-block" id="find_nearest">
<a class="viewcode-back" href="../../api.html#stingray.utils.find_nearest">[docs]</a>
<span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the array value that is closest to the input value (Abigail Stevens:</span>
<span class="sd">    Thanks StackOverflow!)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : np.array of ints or floats</span>
<span class="sd">        1-D array of numbers to search through. Should already be sorted</span>
<span class="sd">        from low values to high values.</span>

<span class="sd">    value : int or float</span>
<span class="sd">        The value you want to find the closest to in the array.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    side : str</span>
<span class="sd">        Look at the ``numpy.searchsorted`` documentation for more information.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array[idx] : int or float</span>
<span class="sd">        The array value that is closest to the input value.</span>

<span class="sd">    idx : int</span>
<span class="sd">        The index of the array of the closest value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">idx</span></div>



<span class="k">def</span> <span class="nf">check_iterables_close</span><span class="p">(</span><span class="n">iter0</span><span class="p">,</span> <span class="n">iter1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check that the values produced by iterables are equal.</span>

<span class="sd">    Uses `np.isclose` if the iterables produce single values per iteration,</span>
<span class="sd">    `np.allclose` otherwise.</span>

<span class="sd">    Additional keyword arguments are passed to `np.allclose`</span>
<span class="sd">    and `np.isclose`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    iter0 : iterable</span>
<span class="sd">    iter1 : iterable</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; iter0 = [0, 1]</span>
<span class="sd">    &gt;&gt;&gt; iter1 = [0, 2]</span>
<span class="sd">    &gt;&gt;&gt; check_iterables_close(iter0, iter1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; iter0 = [(0, 0), (0, 1)]</span>
<span class="sd">    &gt;&gt;&gt; iter1 = [(0, 0.), (0, 1.)]</span>
<span class="sd">    &gt;&gt;&gt; assert check_iterables_close(iter0, iter1)</span>
<span class="sd">    &gt;&gt;&gt; iter1 = [(0, 0.), (0, 3.)]</span>
<span class="sd">    &gt;&gt;&gt; check_iterables_close(iter0, iter1)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iter0</span><span class="p">,</span> <span class="n">iter1</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">check_allclose_and_print</span><span class="p">(</span>
    <span class="n">v1</span><span class="p">,</span>
    <span class="n">v2</span><span class="p">,</span>
    <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check that the values in the array v1 and v2 are equal.</span>
<span class="sd">    It prints the values that are different.</span>

<span class="sd">    Uses `np.allclose` and it has the option to specify rtol and atol</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v1 : array</span>
<span class="sd">    v2 : array</span>
<span class="sd">    rtol : The relative tolerance parameter</span>
<span class="sd">    atol : The absolute tolerance parameter</span>

<span class="sd">    If the following equation element-wise True, then allclose returns True.</span>
<span class="sd">    absolute(a - b) &lt;= (atol + rtol * absolute(b))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v2</span><span class="p">))</span>

        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Different values in the arrays check by allclose: </span><span class="se">\</span>
<span class="s2">                        </span><span class="si">{</span><span class="n">v1</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">v2</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span><span class="si">}</span><span class="s2">, indices are </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="n">bad</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\</span>
<span class="s2">                        and </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">v2</span><span class="p">[</span><span class="n">bad</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">compute_bin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a list of bin edges, get what bin will a number end up to</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        The value to insert</span>
<span class="sd">    bin_edges: array</span>
<span class="sd">        The list of bin edges</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bin : int</span>
<span class="sd">        The bin number. None if outside bin edges.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; bin_edges = np.array([0, 5, 10])</span>
<span class="sd">    &gt;&gt;&gt; compute_bin(1, bin_edges)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; compute_bin(5, bin_edges)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; compute_bin(10, bin_edges)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; assert compute_bin(11, bin_edges) is None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># assuming uniform bins for now</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">a_min</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a_max</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># special case to mirror NumPy behavior for last bin</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a_max</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># a_max always in last bin</span>

    <span class="nb">bin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">a_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a_max</span> <span class="o">-</span> <span class="n">a_min</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">bin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">bin</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="nb">bin</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_hist1d_numba_seq</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tracks</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">bins</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">:</span>
            <span class="n">H</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">H</span>


<span class="k">def</span> <span class="nf">_allocate_array_or_memmap</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Allocate an array. If very big and user asks for it, allocate a memory map.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : tuple</span>
<span class="sd">        Shape of the output array</span>
<span class="sd">    dtype : str or anything compatible with `np.dtype`</span>
<span class="sd">        Type of the output array</span>
<span class="sd">    use_memmap : bool</span>
<span class="sd">        If ``True`` and the number of bins is above 10 million,</span>
<span class="sd">        the histogram is created into a memory-mapped Numpy array</span>
<span class="sd">    tmp : str, default None</span>
<span class="sd">        Temporary file name for the memory map (only relevant if</span>
<span class="sd">        ``use_memmap`` is ``True``). A temporary file with random</span>
<span class="sd">        name is allocated if this is not specified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    H : array</span>
<span class="sd">        The output array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_memmap</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tmp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s2">&quot;w+&quot;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.npy&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">open_memmap</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w+&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span>


<span class="k">def</span> <span class="nf">hist1d_numba_seq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-compiled 1-d histogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like</span>
<span class="sd">        Input array, to be histogrammed</span>
<span class="sd">    bins : integer</span>
<span class="sd">        number of bins in the final histogram</span>
<span class="sd">    range : [min, max]</span>
<span class="sd">        Minimum and maximum value of the histogram</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    use_memmap : bool</span>
<span class="sd">        If ``True`` and the number of bins is above 10 million,</span>
<span class="sd">        the histogram is created into a memory-mapped Numpy array</span>
<span class="sd">    tmp : str</span>
<span class="sd">        Temporary file name for the memory map (only relevant if</span>
<span class="sd">        ``use_memmap`` is ``True``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    histogram: array-like</span>
<span class="sd">        Histogrammed values of a, in ``bins`` bins.</span>

<span class="sd">    From https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; if os.path.exists(&#39;out.npy&#39;): os.unlink(&#39;out.npy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; H, xedges = np.histogram(x, bins=5, range=[0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist1d_numba_seq(x, bins=5, range=[0., 1.], tmp=&#39;out.npy&#39;,</span>
<span class="sd">    ...                       use_memmap=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &gt;&gt;&gt; # The number of bins is small, memory map was not used!</span>
<span class="sd">    &gt;&gt;&gt; assert not os.path.exists(&#39;out.npy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; H, xedges = np.histogram(x, bins=10**8, range=[0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist1d_numba_seq(x, bins=10**8, range=[0., 1.],</span>
<span class="sd">    ...                       use_memmap=True, tmp=&#39;out.npy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &gt;&gt;&gt; assert os.path.exists(&#39;out.npy&#39;)  # Created!</span>
<span class="sd">    &gt;&gt;&gt; # Here, instead, it will create a temporary file for the memory map</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist1d_numba_seq(x, bins=10**8, range=[0., 1.],</span>
<span class="sd">    ...                       use_memmap=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hist_arr</span> <span class="o">=</span> <span class="n">_allocate_array_or_memmap</span><span class="p">((</span><span class="n">bins</span><span class="p">,),</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_hist1d_numba_seq</span><span class="p">(</span><span class="n">hist_arr</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">range</span><span class="p">))</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_hist2d_numba_seq</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tracks</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">ranges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">bins</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">H</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">H</span>


<span class="k">def</span> <span class="nf">hist2d_numba_seq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-compiled 2-d histogram.</span>

<span class="sd">    From https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">        Input array, to be histogrammed</span>
<span class="sd">    y : array-like</span>
<span class="sd">        Input array (equal length to x), to be histogrammed</span>
<span class="sd">    shape : (int, int)</span>
<span class="sd">        shape of the final histogram</span>
<span class="sd">    range : [min, max]</span>
<span class="sd">        Minimum and maximum value of the histogram</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    use_memmap : bool</span>
<span class="sd">        If ``True`` and the number of bins is above 10 million,</span>
<span class="sd">        the histogram is created into a memory-mapped Numpy array</span>
<span class="sd">    tmp : str</span>
<span class="sd">        Temporary file name for the memory map (only relevant if</span>
<span class="sd">        ``use_memmap`` is ``True``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    histogram: array-like</span>
<span class="sd">        Output Histogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; y = np.random.uniform(2., 3., 100)</span>
<span class="sd">    &gt;&gt;&gt; H, xedges, yedges = np.histogram2d(x, y, bins=(5, 5),</span>
<span class="sd">    ...                                    range=[(0., 1.), (2., 3.)])</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist2d_numba_seq(x, y, bins=(5, 5),</span>
<span class="sd">    ...                       range=[[0., 1.], [2., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &gt;&gt;&gt; H, xedges, yedges = np.histogram2d(x, y, bins=(5000, 5000),</span>
<span class="sd">    ...                                    range=[(0., 1.), (2., 3.)])</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist2d_numba_seq(x, y, bins=(5000, 5000),</span>
<span class="sd">    ...                       range=[[0., 1.], [2., 3.]],</span>
<span class="sd">    ...                       use_memmap=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">_allocate_array_or_memmap</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_hist2d_numba_seq</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bins</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">range</span><span class="p">))</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_hist3d_numba_seq</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tracks</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">ranges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">bins</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">H</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">H</span>


<span class="k">def</span> <span class="nf">hist3d_numba_seq</span><span class="p">(</span><span class="n">tracks</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-compiled 3d histogram</span>

<span class="sd">    From https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tracks : (array-like, array-like, array-like)</span>
<span class="sd">        List of input arrays of identical length, to be histogrammed</span>
<span class="sd">    bins : (int, int, int)</span>
<span class="sd">        shape of the final histogram</span>
<span class="sd">    range : [min, max]</span>
<span class="sd">        Minimum and maximum value of the histogram</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    use_memmap : bool</span>
<span class="sd">        If ``True`` and the number of bins is above 10 million,</span>
<span class="sd">        the histogram is created into a memory-mapped Numpy array</span>
<span class="sd">    tmp : str</span>
<span class="sd">        Temporary file name for the memory map (only relevant if</span>
<span class="sd">        ``use_memmap`` is ``True``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    histogram: array-like</span>
<span class="sd">        Output Histogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; y = np.random.uniform(2., 3., 100)</span>
<span class="sd">    &gt;&gt;&gt; z = np.random.uniform(4., 5., 100)</span>
<span class="sd">    &gt;&gt;&gt; H, _ = np.histogramdd((x, y, z), bins=(5, 6, 7),</span>
<span class="sd">    ...                       range=[(0., 1.), (2., 3.), (4., 5)])</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist3d_numba_seq((x, y, z), bins=(5, 6, 7),</span>
<span class="sd">    ...                       range=[[0., 1.], [2., 3.], [4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &gt;&gt;&gt; H, _ = np.histogramdd((x, y, z), bins=(300, 300, 300),</span>
<span class="sd">    ...                       range=[(0., 1.), (2., 3.), (4., 5)])</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist3d_numba_seq((x, y, z), bins=(300, 300, 300),</span>
<span class="sd">    ...                       range=[[0., 1.], [2., 3.], [4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">_allocate_array_or_memmap</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_hist3d_numba_seq</span><span class="p">(</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">tracks</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bins</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span>
    <span class="p">)</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_hist1d_numba_seq_weight</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tracks</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">bins</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">:</span>
            <span class="n">H</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span>


<span class="k">def</span> <span class="nf">hist1d_numba_seq_weight</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-compiled 1-d histogram with weights.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like</span>
<span class="sd">        Input array, to be histogrammed</span>
<span class="sd">    weights : array-like</span>
<span class="sd">        Input weight of each of the input values ``a``</span>
<span class="sd">    bins : integer</span>
<span class="sd">        number of bins in the final histogram</span>
<span class="sd">    range : [min, max]</span>
<span class="sd">        Minimum and maximum value of the histogram</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    use_memmap : bool</span>
<span class="sd">        If ``True`` and the number of bins is above 10 million,</span>
<span class="sd">        the histogram is created into a memory-mapped Numpy array</span>
<span class="sd">    tmp : str</span>
<span class="sd">        Temporary file name for the memory map (only relevant if</span>
<span class="sd">        ``use_memmap`` is ``True``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    histogram: array-like</span>
<span class="sd">        Histogrammed values of a, in ``bins`` bins.</span>

<span class="sd">    Adapted from https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; if os.path.exists(&#39;out.npy&#39;): os.unlink(&#39;out.npy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; weights = np.random.uniform(0, 1, 100)</span>
<span class="sd">    &gt;&gt;&gt; H, xedges = np.histogram(x, bins=5, range=[0., 1.], weights=weights)</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist1d_numba_seq_weight(x, weights, bins=5, range=[0., 1.], tmp=&#39;out.npy&#39;,</span>
<span class="sd">    ...                              use_memmap=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &gt;&gt;&gt; # The number of bins is small, memory map was not used!</span>
<span class="sd">    &gt;&gt;&gt; assert not os.path.exists(&#39;out.npy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; H, xedges = np.histogram(x, bins=10**8, range=[0., 1.], weights=weights)</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist1d_numba_seq_weight(x, weights, bins=10**8, range=[0., 1.], tmp=&#39;out.npy&#39;,</span>
<span class="sd">    ...                              use_memmap=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &gt;&gt;&gt; assert os.path.exists(&#39;out.npy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # Now use memmap but do not specify a tmp file</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist1d_numba_seq_weight(x, weights, bins=10**8, range=[0., 1.],</span>
<span class="sd">    ...                              use_memmap=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">bins</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">**</span><span class="mi">7</span> <span class="ow">and</span> <span class="n">use_memmap</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tmp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="s2">&quot;w+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
        <span class="n">hist_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">open_memmap</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w+&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">bins</span><span class="p">,))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hist_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">bins</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_hist1d_numba_seq_weight</span><span class="p">(</span><span class="n">hist_arr</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">range</span><span class="p">))</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_hist2d_numba_seq_weight</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tracks</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">ranges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">bins</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">H</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span>


<span class="k">def</span> <span class="nf">hist2d_numba_seq_weight</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-compiled 2d histogram with weights</span>

<span class="sd">    From https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">        List of input values in the x-direction</span>
<span class="sd">    y : array-like</span>
<span class="sd">        List of input values in the y-direction, of the same length of ``x``</span>
<span class="sd">    weights : array-like</span>
<span class="sd">        Input weight of each of the input values.</span>
<span class="sd">    bins : (int, int, int)</span>
<span class="sd">        shape of the final histogram</span>
<span class="sd">    range : [min, max]</span>
<span class="sd">        Minimum and maximum value of the histogram</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    use_memmap : bool</span>
<span class="sd">        If ``True`` and the number of bins is above 10 million,</span>
<span class="sd">        the histogram is created into a memory-mapped Numpy array</span>
<span class="sd">    tmp : str</span>
<span class="sd">        Temporary file name for the memory map (only relevant if</span>
<span class="sd">        ``use_memmap`` is ``True``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    histogram: array-like</span>
<span class="sd">        Output Histogram</span>

<span class="sd">    From https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; y = np.random.uniform(2., 3., 100)</span>
<span class="sd">    &gt;&gt;&gt; weight = np.random.uniform(0, 1, 100)</span>
<span class="sd">    &gt;&gt;&gt; H, xedges, yedges = np.histogram2d(x, y, bins=(5, 5),</span>
<span class="sd">    ...                                    range=[(0., 1.), (2., 3.)],</span>
<span class="sd">    ...                                    weights=weight)</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist2d_numba_seq_weight(x, y, bins=(5, 5),</span>
<span class="sd">    ...                              range=[[0., 1.], [2., 3.]],</span>
<span class="sd">    ...                              weights=weight)</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">_allocate_array_or_memmap</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_hist2d_numba_seq_weight</span><span class="p">(</span>
        <span class="n">H</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]),</span>
        <span class="n">weights</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bins</span><span class="p">)),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">range</span><span class="p">),</span>
    <span class="p">)</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_hist3d_numba_seq_weight</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tracks</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">ranges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">bins</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">tracks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">H</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span>


<span class="k">def</span> <span class="nf">hist3d_numba_seq_weight</span><span class="p">(</span><span class="n">tracks</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-compiled weighted 3d histogram</span>

<span class="sd">    From https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tracks : (x, y, z)</span>
<span class="sd">        List of input arrays of identical length, to be histogrammed</span>
<span class="sd">    weights : array-like</span>
<span class="sd">        List of weights for each point of the input arrays</span>
<span class="sd">    bins : (int, int, int)</span>
<span class="sd">        shape of the final histogram</span>
<span class="sd">    range : [[xmin, xmax], [ymin, ymax], [zmin, zmax]]]</span>
<span class="sd">        Minimum and maximum value of the histogram, in each dimension</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    use_memmap : bool</span>
<span class="sd">        If ``True`` and the number of bins is above 10 million,</span>
<span class="sd">        the histogram is created into a memory-mapped Numpy array</span>
<span class="sd">    tmp : str</span>
<span class="sd">        Temporary file name for the memory map (only relevant if</span>
<span class="sd">        ``use_memmap`` is ``True``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    histogram: array-like</span>
<span class="sd">        Output Histogram</span>

<span class="sd">    From https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; y = np.random.uniform(2., 3., 100)</span>
<span class="sd">    &gt;&gt;&gt; z = np.random.uniform(4., 5., 100)</span>
<span class="sd">    &gt;&gt;&gt; weights = np.random.uniform(0, 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; H, _ = np.histogramdd((x, y, z), bins=(5, 6, 7),</span>
<span class="sd">    ...                       range=[(0., 1.), (2., 3.), (4., 5)],</span>
<span class="sd">    ...                       weights=weights)</span>
<span class="sd">    &gt;&gt;&gt; Hn = hist3d_numba_seq_weight(</span>
<span class="sd">    ...    (x, y, z), weights, bins=(5, 6, 7),</span>
<span class="sd">    ...    range=[[0., 1.], [2., 3.], [4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">_allocate_array_or_memmap</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_hist3d_numba_seq_weight</span><span class="p">(</span>
        <span class="n">H</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">tracks</span><span class="p">),</span>
        <span class="n">weights</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bins</span><span class="p">)),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">range</span><span class="p">),</span>
    <span class="p">)</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_index_arr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ix_arr</span><span class="p">):</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span><span class="o">.</span><span class="n">itemsize</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">ix_arr</span> <span class="o">*</span> <span class="n">strides</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">ix</span><span class="p">]</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_index_set_arr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ix_arr</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span><span class="o">.</span><span class="n">itemsize</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">ix_arr</span> <span class="o">*</span> <span class="n">strides</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_histnd_numba_seq</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tracks</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">slice_int</span><span class="p">):</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">ranges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">bins</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">slicearr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">tracks</span><span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tracks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="p">)</span>

        <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">slicearr</span> <span class="o">&lt;</span> <span class="n">bins</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">slicearr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">slice_int</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">slicearr</span>

        <span class="k">if</span> <span class="n">good</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">_index_arr</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">slice_int</span><span class="p">)</span>
            <span class="n">_index_set_arr</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">slice_int</span><span class="p">,</span> <span class="n">curr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">H</span>


<span class="k">def</span> <span class="nf">histnd_numba_seq</span><span class="p">(</span><span class="n">tracks</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-compiled n-d histogram</span>

<span class="sd">    From https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tracks : (array-like, array-like, array-like)</span>
<span class="sd">        List of input arrays, to be histogrammed</span>
<span class="sd">    bins : (int, int, ...)</span>
<span class="sd">        shape of the final histogram</span>
<span class="sd">    range : [[min, max], ...]</span>
<span class="sd">        Minimum and maximum value of the histogram, in each dimension</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    use_memmap : bool</span>
<span class="sd">        If ``True`` and the number of bins is above 10 million,</span>
<span class="sd">        the histogram is created into a memory-mapped Numpy array</span>
<span class="sd">    tmp : str</span>
<span class="sd">        Temporary file name for the memory map (only relevant if</span>
<span class="sd">        ``use_memmap`` is ``True``)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    histogram: array-like</span>
<span class="sd">        Output Histogram</span>

<span class="sd">    From https://iscinumpy.dev/post/histogram-speeds-in-python/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; y = np.random.uniform(2., 3., 100)</span>
<span class="sd">    &gt;&gt;&gt; z = np.random.uniform(4., 5., 100)</span>
<span class="sd">    &gt;&gt;&gt; # 2d example</span>
<span class="sd">    &gt;&gt;&gt; H, _, _ = np.histogram2d(x, y, bins=np.array((5, 5)),</span>
<span class="sd">    ...                          range=[(0., 1.), (2., 3.)])</span>
<span class="sd">    &gt;&gt;&gt; alldata = np.array([x, y])</span>
<span class="sd">    &gt;&gt;&gt; Hn = histnd_numba_seq(alldata, bins=np.array([5, 5]),</span>
<span class="sd">    ...                       range=np.array([[0., 1.], [2., 3.]]))</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &gt;&gt;&gt; # 3d example</span>
<span class="sd">    &gt;&gt;&gt; H, _ = np.histogramdd((x, y, z), bins=np.array((5, 6, 7)),</span>
<span class="sd">    ...                       range=[(0., 1.), (2., 3.), (4., 5)])</span>
<span class="sd">    &gt;&gt;&gt; alldata = np.array([x, y, z])</span>
<span class="sd">    &gt;&gt;&gt; Hn = histnd_numba_seq(alldata, bins=np.array((5, 6, 7)),</span>
<span class="sd">    ...                       range=np.array([[0., 1.], [2., 3.], [4., 5.]]))</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tracks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">tracks</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">_allocate_array_or_memmap</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
    <span class="n">slice_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_histnd_numba_seq</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">tracks</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">slice_int</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_wrap_histograms</span><span class="p">(</span><span class="n">numba_func</span><span class="p">,</span> <span class="n">weight_numba_func</span><span class="p">,</span> <span class="n">np_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Histogram wrapper.</span>

<span class="sd">    Make sure that the histogram fails safely if numba is not available or does not work.</span>

<span class="sd">    In particular, if weights are complex, it will split them in real and imaginary part.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">use_memmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_memmap&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tmp&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">_wrap_histograms</span><span class="p">(</span>
                <span class="n">numba_func</span><span class="p">,</span>
                <span class="n">weight_numba_func</span><span class="p">,</span>
                <span class="n">np_func</span><span class="p">,</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="o">.</span><span class="n">real</span><span class="p">,</span>
                <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span>
                <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="n">_wrap_histograms</span><span class="p">(</span>
                <span class="n">numba_func</span><span class="p">,</span>
                <span class="n">weight_numba_func</span><span class="p">,</span>
                <span class="n">np_func</span><span class="p">,</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span>
                <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span>
                <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">*</span> <span class="mf">1.0</span><span class="n">j</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_NUMBA</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numba_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weight_numba_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Weights not supported for this histogram&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weight_numba_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">use_memmap</span><span class="o">=</span><span class="n">use_memmap</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="n">tmp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">NumbaValueError</span><span class="p">,</span> <span class="n">NumbaNotImplementedError</span><span class="p">,</span> <span class="n">TypingError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Cannot calculate the histogram with the numba implementation. &quot;</span>
            <span class="s2">&quot;Trying standard numpy.&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">histogram3d</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Histogram implementation.</span>

<span class="sd">    Accepts the same arguments as `numpy.histogramdd`, but tries to use a Numba implementation</span>
<span class="sd">    of the histogram. Bonus: weights can be complex.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; y = np.random.uniform(2., 3., 100)</span>
<span class="sd">    &gt;&gt;&gt; z = np.random.uniform(4., 5., 100)</span>
<span class="sd">    &gt;&gt;&gt; # 3d example</span>
<span class="sd">    &gt;&gt;&gt; H, _ = np.histogramdd((x, y, z), bins=np.array((5, 6, 7)),</span>
<span class="sd">    ...                       range=[(0., 1.), (2., 3.), (4., 5)])</span>
<span class="sd">    &gt;&gt;&gt; Hn = histogram3d((x, y, z), bins=np.array((5, 6, 7)),</span>
<span class="sd">    ...                  range=[(0., 1.), (2., 3.), (4., 5)])</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_wrap_histograms</span><span class="p">(</span>
        <span class="n">hist3d_numba_seq</span><span class="p">,</span> <span class="n">hist3d_numba_seq_weight</span><span class="p">,</span> <span class="n">histogramdd_np</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">histogramnd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Histogram implementation.</span>

<span class="sd">    Accepts the same arguments as `numpy.histogramdd`, but tries to use a Numba implementation</span>
<span class="sd">    of the histogram. Bonus: weights can be complex.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; y = np.random.uniform(2., 3., 100)</span>
<span class="sd">    &gt;&gt;&gt; z = np.random.uniform(4., 5., 100)</span>
<span class="sd">    &gt;&gt;&gt; # 2d example</span>
<span class="sd">    &gt;&gt;&gt; H, _, _ = np.histogram2d(x, y, bins=np.array((5, 5)),</span>
<span class="sd">    ...                          range=[(0., 1.), (2., 3.)])</span>
<span class="sd">    &gt;&gt;&gt; Hn = histogramnd((x, y), bins=np.array([5, 5]),</span>
<span class="sd">    ...                  range=np.array([[0., 1.], [2., 3.]]))</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &gt;&gt;&gt; # 3d example</span>
<span class="sd">    &gt;&gt;&gt; H, _ = np.histogramdd((x, y, z), bins=np.array((5, 6, 7)),</span>
<span class="sd">    ...                       range=[(0., 1.), (2., 3.), (4., 5)])</span>
<span class="sd">    &gt;&gt;&gt; alldata = (x, y, z)</span>
<span class="sd">    &gt;&gt;&gt; Hn = histogramnd(alldata, bins=np.array((5, 6, 7)),</span>
<span class="sd">    ...                  range=np.array([[0., 1.], [2., 3.], [4., 5.]]))</span>
<span class="sd">    &gt;&gt;&gt; assert np.all(H == Hn)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_wrap_histograms</span><span class="p">(</span><span class="n">histnd_numba_seq</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">histogramdd_np</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">histogram2d</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Histogram implementation.</span>

<span class="sd">    Accepts the same arguments as `numpy.histogramdd`, but tries to use a Numba implementation</span>
<span class="sd">    of the histogram. Bonus: weights can be complex.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; y = np.random.uniform(2., 3., 100)</span>
<span class="sd">    &gt;&gt;&gt; weight = np.random.uniform(0, 1, 100)</span>
<span class="sd">    &gt;&gt;&gt; H, xedges, yedges = np.histogram2d(x, y, bins=(5, 5),</span>
<span class="sd">    ...                                    range=[(0., 1.), (2., 3.)],</span>
<span class="sd">    ...                                    weights=weight)</span>
<span class="sd">    &gt;&gt;&gt; Hn = histogram2d(x, y, bins=(5, 5),</span>
<span class="sd">    ...                  range=[[0., 1.], [2., 3.]],</span>
<span class="sd">    ...                  weights=weight)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(H, Hn)</span>
<span class="sd">    &gt;&gt;&gt; Hn1 = histogram2d(x, y, bins=(5, 5),</span>
<span class="sd">    ...                   range=[[0., 1.], [2., 3.]],</span>
<span class="sd">    ...                   weights=None)</span>
<span class="sd">    &gt;&gt;&gt; Hn2 = histogram2d(x, y, bins=(5, 5),</span>
<span class="sd">    ...                   range=[[0., 1.], [2., 3.]])</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(Hn1, Hn2)</span>
<span class="sd">    &gt;&gt;&gt; Hn = histogram2d(x, y, bins=(5, 5),</span>
<span class="sd">    ...                  range=[[0., 1.], [2., 3.]],</span>
<span class="sd">    ...                  weights=weight + 1.j * weight)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(Hn.real, Hn.imag)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(H, Hn.real)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrap_histograms</span><span class="p">(</span>
        <span class="n">hist2d_numba_seq</span><span class="p">,</span> <span class="n">hist2d_numba_seq_weight</span><span class="p">,</span> <span class="n">histogram2d_np</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Histogram implementation.</span>

<span class="sd">    Accepts the same arguments as `numpy.histogramdd`, but tries to use a Numba implementation</span>
<span class="sd">    of the histogram. Bonus: weights can be complex.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.uniform(0., 1., 100)</span>
<span class="sd">    &gt;&gt;&gt; weights = np.random.uniform(0, 1, 100)</span>
<span class="sd">    &gt;&gt;&gt; H, xedges = np.histogram(x, bins=5, range=[0., 1.], weights=weights)</span>
<span class="sd">    &gt;&gt;&gt; Hn = histogram(x, weights=weights, bins=5, range=[0., 1.], tmp=&#39;out.npy&#39;,</span>
<span class="sd">    ...                use_memmap=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(H, Hn)</span>
<span class="sd">    &gt;&gt;&gt; Hn1 = histogram(x, weights=None, bins=5, range=[0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; Hn2 = histogram(x, bins=5, range=[0., 1.])</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(Hn1, Hn2)</span>
<span class="sd">    &gt;&gt;&gt; Hn = histogram(x, weights=weights + weights * 2.j, bins=5, range=[0., 1.],</span>
<span class="sd">    ...                tmp=&#39;out.npy&#39;, use_memmap=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(Hn.real, Hn.imag / 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_wrap_histograms</span><span class="p">(</span>
        <span class="n">hist1d_numba_seq</span><span class="p">,</span> <span class="n">hist1d_numba_seq_weight</span><span class="p">,</span> <span class="n">histogram_np</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">equal_count_energy_ranges</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">n_ranges</span><span class="p">,</span> <span class="n">emin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">emax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find energy ranges containing an approximately equal number of events.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    energies : array-like</span>
<span class="sd">        List of event energies</span>
<span class="sd">    n_ranges : int</span>
<span class="sd">        Number of output ranges</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    emin : float, default None</span>
<span class="sd">        Minimum energy. Defaults to the minimum of ``energies``</span>
<span class="sd">    emax : float, default None</span>
<span class="sd">        Maximum energy. Defaults to the maximum of ``energies``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bin_edges : array-like</span>
<span class="sd">        Edges of the energy ranges, in a single array of length</span>
<span class="sd">        ``n_ranges+1``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; energies = np.random.uniform(0, 10, 1000000)</span>
<span class="sd">    &gt;&gt;&gt; edges = equal_count_energy_ranges(energies, 5, emin=0, emax=10)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(edges, [0, 2, 4, 6, 8, 10], atol=0.05)</span>
<span class="sd">    &gt;&gt;&gt; edges = equal_count_energy_ranges(energies, 5)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(edges, [0, 2, 4, 6, 8, 10], atol=0.05)</span>
<span class="sd">    &gt;&gt;&gt; edges = equal_count_energy_ranges(energies, 0)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(edges, [0, 10], atol=0.05)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">need_filtering</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">emin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">emax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">need_filtering</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">emin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">emin</span> <span class="o">=</span> <span class="n">energies</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">emax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">emax</span> <span class="o">=</span> <span class="n">energies</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">need_filtering</span><span class="p">:</span>
        <span class="n">good</span> <span class="o">=</span> <span class="p">(</span><span class="n">energies</span> <span class="o">&gt;=</span> <span class="n">emin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">energies</span> <span class="o">&lt;=</span> <span class="n">emax</span><span class="p">)</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="n">energies</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">n_ranges</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">n_ranges</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">emin</span><span class="p">],</span> <span class="n">percentiles</span><span class="p">,</span> <span class="p">[</span><span class="n">emax</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">percentiles</span>


<span class="k">def</span> <span class="nf">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;If A is None, define A as a copy of B. Otherwise, sum A + B.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : object</span>
<span class="sd">        The initial value</span>
<span class="sd">    B : object</span>
<span class="sd">        The value to be summed</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sum_if_not_none_or_initialize(None, 2)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; sum_if_not_none_or_initialize(1, 2)</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span>


<span class="k">def</span> <span class="nf">assign_if_not_finite</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if a value is finite. Otherwise, return the default.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : float, int or `np.array`</span>
<span class="sd">        The input value</span>
<span class="sd">    default : float</span>
<span class="sd">        The default value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : same as ``value``</span>
<span class="sd">        The result</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; assign_if_not_finite(1, 3.2)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; assign_if_not_finite(np.inf, 3.2)</span>
<span class="sd">    3.2</span>
<span class="sd">    &gt;&gt;&gt; input_arr = np.array([np.nan, 1, np.inf, 2])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(assign_if_not_finite(input_arr, 3.2), [3.2, 1, 3.2, 2])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">assign_if_not_finite</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">default</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">sqsum</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the square root of the sum of the squares of two arrays.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">array1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">array2</span><span class="p">)))</span>


<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_int_sum_non_zero</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sum all positive elements of an array of integers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : array-like</span>
<span class="sd">        Array of integers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, [{&#39;name&#39;: &#39;Stingray Developers&#39;, &#39;email&#39;: &#39;spectraltiming-stingray@googlegroups.com&#39;}].<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 8.0.2. &nbsp;
    Last built 09 Oct 2024. <br/>
  </p>
</footer>
  </body>
</html>