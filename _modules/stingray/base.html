<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>stingray.base &#8212; stingray v</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-astropy.css?v=9d21690f" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=2afd17ea" />
    
    <script src="../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <link rel="icon" href="../../_static/stingray_logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../index.html">stingray v</a>
	 &#187;
      </li>
      <li><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for stingray.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Base classes&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">Time</span><span class="p">,</span> <span class="n">TimeDelta</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Quantity</span>
<span class="kn">from</span> <span class="nn">stingray.loggingconfig</span> <span class="kn">import</span> <span class="n">setup_logger</span>

<span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">_can_save_longdouble</span><span class="p">,</span> <span class="n">_can_serialize_meta</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">sqsum</span><span class="p">,</span>
    <span class="n">assign_value_if_none</span><span class="p">,</span>
    <span class="n">make_nd_into_arrays</span><span class="p">,</span>
    <span class="n">make_1d_arrays_into_nd</span><span class="p">,</span>
    <span class="n">get_random_state</span><span class="p">,</span>
    <span class="n">find_nearest</span><span class="p">,</span>
    <span class="n">rebin_data</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.gti</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">create_gti_mask</span><span class="p">,</span>
    <span class="n">check_gtis</span><span class="p">,</span>
    <span class="n">cross_two_gtis</span><span class="p">,</span>
    <span class="n">join_gtis</span><span class="p">,</span>
    <span class="n">gti_border_bins</span><span class="p">,</span>
    <span class="n">get_btis</span><span class="p">,</span>
    <span class="n">merge_gtis</span><span class="p">,</span>
    <span class="n">get_total_gti_length</span><span class="p">,</span>
    <span class="n">bin_intervals_from_gtis</span><span class="p">,</span>
    <span class="n">time_intervals_from_gtis</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">xarray</span> <span class="kn">import</span> <span class="n">Dataset</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
    <span class="kn">from</span> <span class="nn">astropy.timeseries</span> <span class="kn">import</span> <span class="n">TimeSeries</span>
    <span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">TimeDelta</span>
    <span class="kn">import</span> <span class="nn">numpy.typing</span> <span class="k">as</span> <span class="nn">npt</span>

    <span class="n">TTime</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Time</span><span class="p">,</span> <span class="n">TimeDelta</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">]</span>
    <span class="n">Tso</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Tso&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;StingrayObject&quot;</span><span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;convert_table_attrs_to_lowercase&quot;</span><span class="p">,</span>
    <span class="s2">&quot;interpret_times&quot;</span><span class="p">,</span>
    <span class="s2">&quot;reduce_precision_if_extended&quot;</span><span class="p">,</span>
    <span class="s2">&quot;StingrayObject&quot;</span><span class="p">,</span>
    <span class="s2">&quot;StingrayTimeseries&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">convert_table_attrs_to_lowercase</span><span class="p">(</span><span class="n">table</span><span class="p">:</span> <span class="n">Table</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert the column names of an Astropy Table to lowercase.&quot;&quot;&quot;</span>
    <span class="n">new_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
        <span class="n">new_table</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">new_table</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">new_table</span>


<div class="viewcode-block" id="StingrayObject">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject">[docs]</a>
<span class="k">class</span> <span class="nc">StingrayObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This base class defines some general-purpose utilities.</span>

<span class="sd">    The main purpose is to have a consistent mechanism for:</span>

<span class="sd">    + round-tripping to and from Astropy Tables and other dataframes</span>

<span class="sd">    + round-tripping to files in different formats</span>

<span class="sd">    The idea is that any object inheriting :class:`StingrayObject` should,</span>
<span class="sd">    just by defining an attribute called ``main_array_attr``, be able to perform</span>
<span class="sd">    the operations above, with no additional effort.</span>

<span class="sd">    ``main_array_attr`` is, e.g. ``time`` for :class:`StingrayTimeseries` and</span>
<span class="sd">    :class:`Lightcurve`, ``freq`` for :class:`Crossspectrum`, ``energy`` for</span>
<span class="sd">    :class:`VarEnergySpectrum`, and so on. It is the array with which all other</span>
<span class="sd">    attributes are compared: if they are of the same shape, they get saved as</span>
<span class="sd">    columns of the table/dataframe, otherwise as metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">not_array_attr</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;main_array_attr&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;A StingrayObject needs to have the main_array_attr attribute specified&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">main_array_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="StingrayObject.data_attributes">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.data_attributes">[docs]</a>
    <span class="k">def</span> <span class="nf">data_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean up the list of attributes, only giving out those pointing to data.</span>

<span class="sd">        List all the attributes that point directly to valid data. This method goes through all the</span>
<span class="sd">        attributes of the class, eliminating methods, properties, and attributes that are complicated</span>
<span class="sd">        to serialize such as other ``StingrayObject``, or arrays of objects.</span>

<span class="sd">        This function does not make difference between array-like data and scalar data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_attributes : list of str</span>
<span class="sd">            List of attributes pointing to data that are not methods, properties,</span>
<span class="sd">            or other ``StingrayObject`` instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">attr</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;main_array_attr&quot;</span><span class="p">,</span> <span class="s2">&quot;not_array_attr&quot;</span><span class="p">]</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="nb">property</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">StingrayObject</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span>
            <span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="StingrayObject.array_attrs">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.array_attrs">[docs]</a>
    <span class="k">def</span> <span class="nf">array_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List the names of the array attributes of the Stingray Object.</span>

<span class="sd">        By array attributes, we mean the ones with the same size and shape as</span>
<span class="sd">        ``main_array_attr`` (e.g. ``time`` in ``EventList``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        attributes : list of str</span>
<span class="sd">            List of array attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">main_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;main_array_attr&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">main_attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">attr</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_attributes</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">attr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="n">Iterable</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_array_attr</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="nb">str</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">main_attr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="StingrayObject.internal_array_attrs">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.internal_array_attrs">[docs]</a>
    <span class="k">def</span> <span class="nf">internal_array_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List the names of the internal array attributes of the Stingray Object.</span>

<span class="sd">        These are array attributes that can be set by properties, and are generally indicated</span>
<span class="sd">        by an underscore followed by the name of the property that links to it (E.g.</span>
<span class="sd">        ``_counts`` in ``Lightcurve``).</span>
<span class="sd">        By array attributes, we mean the ones with the same size and shape as</span>
<span class="sd">        ``main_array_attr`` (e.g. ``time`` in ``EventList``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        attributes : list of str</span>
<span class="sd">            List of internal array attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">main_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;main_array_attr&quot;</span><span class="p">)</span>
        <span class="n">main_attr_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">main_attr_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">all_attrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_attributes</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span>  <span class="c1"># e.g. _time in lightcurve</span>
                <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_array_attr</span><span class="p">]</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">value</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">main_attr_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">all_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">all_attrs</span></div>


<div class="viewcode-block" id="StingrayObject.meta_attrs">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.meta_attrs">[docs]</a>
    <span class="k">def</span> <span class="nf">meta_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List the names of the meta attributes of the Stingray Object.</span>

<span class="sd">        By array attributes, we mean the ones with a different size and shape</span>
<span class="sd">        than ``main_array_attr`` (e.g. ``time`` in ``EventList``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        attributes : list of str</span>
<span class="sd">            List of meta attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">array_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span>

        <span class="n">all_meta_attrs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">attr</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_attributes</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">array_attrs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_array_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">not_array_attr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">all_meta_attrs</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_array_attr</span>
        <span class="k">return</span> <span class="n">all_meta_attrs</span></div>


<div class="viewcode-block" id="StingrayObject.dict">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.dict">[docs]</a>
    <span class="k">def</span> <span class="nf">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary representation of the object.&quot;&quot;&quot;</span>

        <span class="n">main_attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span>
        <span class="n">meta_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">()</span>
        <span class="n">array_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span>
        <span class="n">internal_array_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">results</span><span class="p">[</span><span class="n">main_attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_attr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">internal_array_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">),</span> <span class="kc">None</span><span class="p">),</span> <span class="nb">property</span><span class="p">):</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">meta_attrs</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="StingrayObject.pretty_print">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.pretty_print">[docs]</a>
    <span class="k">def</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_to_apply</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attrs_to_apply</span><span class="o">=</span><span class="p">[],</span> <span class="n">attrs_to_discard</span><span class="o">=</span><span class="p">[])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a pretty-printed string representation of the object.</span>

<span class="sd">        This is useful for debugging, and for interactive use.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        func_to_apply : function</span>
<span class="sd">            A function that modifies the attributes listed in ``attrs_to_apply``.</span>
<span class="sd">            It must return the modified attributes and a label to be printed.</span>
<span class="sd">            If ``None``, no function is applied.</span>
<span class="sd">        attrs_to_apply : list of str</span>
<span class="sd">            Attributes to be modified by ``func_to_apply``.</span>
<span class="sd">        attrs_to_discard : list of str</span>
<span class="sd">            Attributes to be discarded from the output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>
        <span class="n">results</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">edgeitems</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">items</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs_to_discard</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attr</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">items</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; (size </span><span class="si">{</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; (shape </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">)&quot;</span>

            <span class="k">if</span> <span class="n">func_to_apply</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs_to_apply</span><span class="p">:</span>
                <span class="n">new_value</span><span class="p">,</span> <span class="n">new_label</span> <span class="o">=</span> <span class="n">func_to_apply</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
                <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">attr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39; (&#39;</span><span class="w"> </span><span class="o">+</span><span class="n">new_label</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;)&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">new_value</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">results</span> <span class="o">+=</span> <span class="n">label</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">results</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare two :class:`StingrayObject` instances with ``==``.</span>

<span class="sd">        All attributes (internal, array, meta) are compared.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_ts</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> can only be compared with a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> Object&quot;</span><span class="p">)</span>

        <span class="n">self_arr_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span>
        <span class="n">other_arr_attrs</span> <span class="o">=</span> <span class="n">other_ts</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">self_arr_attrs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other_arr_attrs</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">self_meta_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">()</span>
        <span class="n">other_meta_attrs</span> <span class="o">=</span> <span class="n">other_ts</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">self_meta_attrs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other_meta_attrs</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">():</span>
            <span class="c1"># They are either both scalar or arrays</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">other_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_default_operated_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">operated_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;_err&quot;</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">operated_attrs</span>

    <span class="k">def</span> <span class="nf">_default_error_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;_err&quot;</span><span class="p">)]</span>

<div class="viewcode-block" id="StingrayObject.get_meta_dict">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.get_meta_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">get_meta_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Give a dictionary with all non-None meta attrs of the object.&quot;&quot;&quot;</span>
        <span class="n">meta_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">()</span>
        <span class="n">meta_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">meta_attrs</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">meta_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">meta_dict</span></div>


<div class="viewcode-block" id="StingrayObject.to_astropy_table">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.to_astropy_table">[docs]</a>
    <span class="k">def</span> <span class="nf">to_astropy_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_longdouble</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Table</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an Astropy Table from a ``StingrayObject``</span>

<span class="sd">        Array attributes (e.g. ``time``, ``pi``, ``energy``, etc. for</span>
<span class="sd">        ``EventList``) are converted into columns, while meta attributes</span>
<span class="sd">        (``mjdref``, ``gti``, etc.) are saved into the ``meta`` dictionary.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        no_longdouble : bool</span>
<span class="sd">            If True, reduce the precision of longdouble arrays to double precision.</span>
<span class="sd">            This needs to be done in some cases, e.g. when the table is to be saved</span>
<span class="sd">            in an architecture not supporting extended precision (e.g. ARM), but can</span>
<span class="sd">            also be useful when an extended precision is not needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">array_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">no_longdouble</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">reduce_precision_if_extended</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">meta_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta_dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">meta_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">no_longdouble</span><span class="p">:</span>
                <span class="n">meta_dict</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_precision_if_extended</span><span class="p">(</span><span class="n">meta_dict</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">meta_dict</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># Work around issue with Numpy 2.0 and Yaml serializer.</span>
            <span class="k">if</span> <span class="s2">&quot;np.float&quot;</span> <span class="ow">in</span> <span class="n">rep</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;np.int&quot;</span> <span class="ow">in</span> <span class="n">rep</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">meta_dict</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">meta_dict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ts</span></div>


<div class="viewcode-block" id="StingrayObject.from_astropy_table">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.from_astropy_table">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_astropy_table</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Tso</span><span class="p">],</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Table</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tso</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Stingray Object object from data in an Astropy Table.</span>

<span class="sd">        The table MUST contain at least a column named like the</span>
<span class="sd">        ``main_array_attr``.</span>
<span class="sd">        The rest of columns will form the array attributes of the</span>
<span class="sd">        new object, while the attributes in ds.attrs will</span>
<span class="sd">        form the new meta attributes of the object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># return an empty object</span>
            <span class="k">return</span> <span class="bp">cls</span>

        <span class="n">array_attrs</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">colnames</span>

        <span class="c1"># Set the main attribute first</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                <span class="n">mainarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">,</span> <span class="n">mainarray</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="k">break</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                <span class="k">continue</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">attr</span><span class="p">]))</span>

        <span class="n">attributes_left_unchanged</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="kc">None</span><span class="p">),</span> <span class="nb">property</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">fset</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">attributes_left_unchanged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes_left_unchanged</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Only warn once, if multiple properties are affected.</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attributes_left_unchanged</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The input table contains protected attribute(s) of StingrayTimeseries: </span><span class="si">{</span><span class="n">attrs</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;These values are set internally by the class, and cannot be overwritten. &quot;</span>
                <span class="s2">&quot;This issue is common when reading from FITS files using `fmt=&#39;fits&#39;`.&quot;</span>
                <span class="s2">&quot; If this is the case, please consider using `fmt=&#39;ogip&#39;` instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span></div>


<div class="viewcode-block" id="StingrayObject.to_xarray">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.to_xarray">[docs]</a>
    <span class="k">def</span> <span class="nf">to_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an ``xarray`` Dataset from a `StingrayObject`.</span>

<span class="sd">        Array attributes (e.g. ``time``, ``pi``, ``energy``, etc. for</span>
<span class="sd">        ``EventList``) are converted into columns, while meta attributes</span>
<span class="sd">        (``mjdref``, ``gti``, etc.) are saved into the ``ds.attrs`` dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">xarray</span> <span class="kn">import</span> <span class="n">Dataset</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">array_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">new_data</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="p">([</span><span class="n">attr</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_dim</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)],</span> <span class="n">new_data</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">ts</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_meta_dict</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">ts</span></div>


<div class="viewcode-block" id="StingrayObject.from_xarray">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.from_xarray">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_xarray</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Tso</span><span class="p">],</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tso</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a `StingrayObject` from data in an xarray Dataset.</span>

<span class="sd">        The dataset MUST contain at least a column named like the</span>
<span class="sd">        ``main_array_attr``.</span>
<span class="sd">        The rest of columns will form the array attributes of the</span>
<span class="sd">        new object, while the attributes in ds.attrs will</span>
<span class="sd">        form the new meta attributes of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># return an empty object</span>
            <span class="k">return</span> <span class="bp">cls</span>

        <span class="c1"># Set the main attribute first</span>
        <span class="n">mainarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">,</span> <span class="n">mainarray</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="n">all_array_attrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">array_attrs</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">data_vars</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
                <span class="n">all_array_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                    <span class="k">continue</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">attr</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_array_attrs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span></div>


<div class="viewcode-block" id="StingrayObject.to_pandas">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.to_pandas">[docs]</a>
    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a pandas ``DataFrame`` from a :class:`StingrayObject`.</span>

<span class="sd">        Array attributes (e.g. ``time``, ``pi``, ``energy``, etc. for</span>
<span class="sd">        ``EventList``) are converted into columns, while meta attributes</span>
<span class="sd">        (``mjdref``, ``gti``, etc.) are saved into the ``ds.attrs`` dictionary.</span>

<span class="sd">        Since pandas does not support n-D data, multi-dimensional arrays are</span>
<span class="sd">        converted into columns before the conversion, with names ``&lt;colname&gt;_dimN_M_K`` etc.</span>

<span class="sd">        See documentation of `make_nd_into_arrays` for details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">array_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">local_data</span> <span class="o">=</span> <span class="n">make_nd_into_arrays</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">local_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">attr</span><span class="p">:</span> <span class="n">values</span><span class="p">}</span>
            <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">local_data</span><span class="p">)</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">ts</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_meta_dict</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">ts</span></div>


<div class="viewcode-block" id="StingrayObject.from_pandas">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.from_pandas">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pandas</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Tso</span><span class="p">],</span> <span class="n">ts</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tso</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an `StingrayObject` object from data in a pandas DataFrame.</span>

<span class="sd">        The dataframe MUST contain at least a column named like the</span>
<span class="sd">        ``main_array_attr``.</span>
<span class="sd">        The rest of columns will form the array attributes of the</span>
<span class="sd">        new object, while the attributes in ds.attrs will</span>
<span class="sd">        form the new meta attributes of the object.</span>

<span class="sd">        Since pandas does not support n-D data, multi-dimensional arrays can be</span>
<span class="sd">        specified as ``&lt;colname&gt;_dimN_M_K`` etc.</span>

<span class="sd">        See documentation of `make_1d_arrays_into_nd` for details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># return an empty object</span>
            <span class="k">return</span> <span class="bp">cls</span>

        <span class="n">array_attrs</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">columns</span>

        <span class="c1"># Set the main attribute first</span>
        <span class="n">mainarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">,</span> <span class="n">mainarray</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="n">nd_attrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="s2">&quot;_dim&quot;</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                <span class="n">nd_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;_dim[0-9].*&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">attr</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nd_attrs</span><span class="p">)):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">make_1d_arrays_into_nd</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span></div>


<div class="viewcode-block" id="StingrayObject.read">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.read">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Tso</span><span class="p">],</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tso</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generic reader for :class`StingrayObject`</span>

<span class="sd">        Currently supported formats are</span>

<span class="sd">        * pickle (not recommended for long-term storage)</span>
<span class="sd">        * any other formats compatible with the writers in</span>
<span class="sd">          :class:`astropy.table.Table` (ascii.ecsv, hdf5, etc.)</span>

<span class="sd">        Files that need the :class:`astropy.table.Table` interface MUST contain</span>
<span class="sd">        at least a column named like the ``main_array_attr``.</span>
<span class="sd">        The default ascii format is enhanced CSV (ECSV). Data formats</span>
<span class="sd">        supporting the serialization of metadata (such as ECSV and HDF5) can</span>
<span class="sd">        contain all attributes such as ``mission``, ``gti``, etc with</span>
<span class="sd">        no significant loss of information. Other file formats might lose part</span>
<span class="sd">        of the metadata, so must be used with care.</span>

<span class="sd">        ..note::</span>

<span class="sd">            Complex values can be dealt with out-of-the-box in some formats</span>
<span class="sd">            like HDF5 or FITS, not in others (e.g. all ASCII formats).</span>
<span class="sd">            With these formats, and in any case when fmt is ``None``, complex</span>
<span class="sd">            values should be stored as two columns of real numbers, whose names</span>
<span class="sd">            are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename: str</span>
<span class="sd">            Path and file name for the file to be read.</span>

<span class="sd">        fmt: str</span>
<span class="sd">            Available options are &#39;pickle&#39;, &#39;hea&#39;, and any `Table`-supported</span>
<span class="sd">            format such as &#39;hdf5&#39;, &#39;ascii.ecsv&#39;, etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj: :class:`StingrayObject` object</span>
<span class="sd">            The object reconstructed from file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;pickle&quot;</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fobj</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fobj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;ascii&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;ascii.ecsv&quot;</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">convert_table_attrs_to_lowercase</span><span class="p">(</span><span class="n">Table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">fmt</span><span class="p">))</span>

        <span class="c1"># For specific formats, and in any case when the format is not</span>
        <span class="c1"># specified, make sure that complex values are treated correctly.</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="s2">&quot;ascii&quot;</span> <span class="ow">in</span> <span class="n">fmt</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">is_real</span> <span class="o">:=</span> <span class="n">col</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.real&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_imag</span> <span class="o">:=</span> <span class="n">col</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.imag&quot;</span><span class="p">))):</span>
                    <span class="k">continue</span>

                <span class="n">new_value</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">is_imag</span><span class="p">:</span>
                    <span class="n">new_value</span> <span class="o">=</span> <span class="n">new_value</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>

                <span class="c1"># Make sure it&#39;s complex, even if we find the real part first</span>
                <span class="n">new_value</span> <span class="o">=</span> <span class="n">new_value</span> <span class="o">+</span> <span class="mf">0.0</span><span class="n">j</span>

                <span class="n">col_strip</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.real&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.imag&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">col_strip</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                    <span class="c1"># If the column without &quot;.real&quot; or &quot;.imag&quot; doesn&#39;t exist,</span>
                    <span class="c1"># define it, and make sure it&#39;s complex-valued</span>
                    <span class="n">ts</span><span class="p">[</span><span class="n">col_strip</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If it does exist, sum the new value to it.</span>
                    <span class="n">ts</span><span class="p">[</span><span class="n">col_strip</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_value</span>

                <span class="n">ts</span><span class="o">.</span><span class="n">remove_column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_astropy_table</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span></div>


<div class="viewcode-block" id="StingrayObject.write">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.write">[docs]</a>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic writer for :class`StingrayObject`</span>

<span class="sd">        Currently supported formats are</span>

<span class="sd">        * pickle (not recommended for long-term storage)</span>
<span class="sd">        * any other formats compatible with the writers in</span>
<span class="sd">          :class:`astropy.table.Table` (ascii.ecsv, hdf5, etc.)</span>

<span class="sd">        ..note::</span>

<span class="sd">            Complex values can be dealt with out-of-the-box in some formats</span>
<span class="sd">            like HDF5 or FITS, not in others (e.g. all ASCII formats).</span>
<span class="sd">            With these formats, and in any case when fmt is ``None``, complex</span>
<span class="sd">            values will be stored as two columns of real numbers, whose names</span>
<span class="sd">            are of the format &lt;variablename&gt;.real and &lt;variablename&gt;.imag</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename: str</span>
<span class="sd">            Name and path of the file to save the object list to.</span>

<span class="sd">        fmt: str</span>
<span class="sd">            The file format to store the data in.</span>
<span class="sd">            Available options are ``pickle``, ``hdf5``, ``ascii``, ``fits``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;pickle&quot;</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fobj</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fobj</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;ascii&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;ascii.ecsv&quot;</span>

        <span class="n">probe_file</span> <span class="o">=</span> <span class="s2">&quot;probe.bu.bu.&quot;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">:]</span>

        <span class="n">CAN_SAVE_LONGD</span> <span class="o">=</span> <span class="n">_can_save_longdouble</span><span class="p">(</span><span class="n">probe_file</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>
        <span class="n">CAN_SERIALIZE_META</span> <span class="o">=</span> <span class="n">_can_serialize_meta</span><span class="p">(</span><span class="n">probe_file</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>

        <span class="n">to_be_saved</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">to_be_saved</span><span class="o">.</span><span class="n">to_astropy_table</span><span class="p">(</span><span class="n">no_longdouble</span><span class="o">=</span><span class="ow">not</span> <span class="n">CAN_SAVE_LONGD</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="s2">&quot;ascii&quot;</span> <span class="ow">in</span> <span class="n">fmt</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">.real&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
                    <span class="n">ts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">.imag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span>
                    <span class="n">ts</span><span class="o">.</span><span class="n">remove_column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">CAN_SERIALIZE_META</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">serialize_meta</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="StingrayObject.apply_mask">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.apply_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">filtered_attrs</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a mask to all array attributes of the object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : array of ``bool``</span>
<span class="sd">            The mask. Has to be of the same length as ``self.time``</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current object. Otherwise, return a new one.</span>
<span class="sd">        filtered_attrs : list of str or None</span>
<span class="sd">            Array attributes to be filtered. Defaults to all array attributes if ``None``.</span>
<span class="sd">            The other array attributes will be set to ``None``. The main array attr is always</span>
<span class="sd">            included.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts_new : StingrayObject object</span>
<span class="sd">            The new object with the mask applied if ``inplace`` is ``False``, otherwise the</span>
<span class="sd">            same object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">filtered_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filtered_attrs</span> <span class="o">=</span> <span class="n">all_attrs</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">new_ts</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_ts</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)))</span>

        <span class="c1"># If the main array attr is managed through an internal attr</span>
        <span class="c1"># (e.g. lightcurve), set the internal attr instead.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span>
                <span class="n">new_ts</span><span class="p">,</span>
                <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">))[</span><span class="n">mask</span><span class="p">]),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span>
                <span class="n">new_ts</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">))[</span><span class="n">mask</span><span class="p">]),</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">all_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filtered_attrs</span><span class="p">:</span>
                <span class="c1"># Eliminate all unfiltered attributes</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))[</span><span class="n">mask</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">new_ts</span></div>


    <span class="k">def</span> <span class="nf">_operation_with_other_obj</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">operation</span><span class="p">,</span>
        <span class="n">operated_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">error_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">error_operation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to codify an operation of one time series with another (e.g. add, subtract).</span>
<span class="sd">        Takes into account the GTIs, and returns a new :class:`StingrayTimeseries` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`StingrayTimeseries` object</span>
<span class="sd">            A second time series object</span>

<span class="sd">        operation : function</span>
<span class="sd">            An operation between the :class:`StingrayTimeseries` object calling this method, and</span>
<span class="sd">            ``other``, operating on all the specified array attributes.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        operated_attrs : list of str or None</span>
<span class="sd">            Array attributes to be operated on. Defaults to all array attributes not ending in</span>
<span class="sd">            ``_err``.</span>
<span class="sd">            The other array attributes will be discarded from the time series to avoid</span>
<span class="sd">            inconsistencies.</span>

<span class="sd">        error_attrs : list of str or None</span>
<span class="sd">            Array attributes to be operated on with ``error_operation``. Defaults to all array</span>
<span class="sd">            attributes ending with ``_err``.</span>

<span class="sd">        error_operation : function</span>
<span class="sd">            The function used for error propagation. Defaults to the sum of squares.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts_new : StingrayTimeseries object</span>
<span class="sd">            The new time series calculated in ``operation``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">operated_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">operated_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_operated_attrs</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">error_attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">error_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_error_attrs</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects can only be operated with other </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects.&quot;</span>
            <span class="p">)</span>

        <span class="n">this_time</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">)</span>
        <span class="c1"># ValueError is raised by Numpy while asserting np.equal over arrays</span>
        <span class="c1"># with different dimensions.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">this_time</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The values of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="si">}</span><span class="s2"> are different in the two </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;objects.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">ts_new</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ts_new</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">ts_new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">,</span> <span class="n">this_time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ts_new</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">operated_attrs</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span>
                <span class="n">ts_new</span><span class="p">,</span>
                <span class="n">attr</span><span class="p">,</span>
                <span class="n">operation</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">)),</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">error_attrs</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span>
                <span class="n">ts_new</span><span class="p">,</span>
                <span class="n">attr</span><span class="p">,</span>
                <span class="n">error_operation</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">)),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ts_new</span>

<div class="viewcode-block" id="StingrayObject.add">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.add">[docs]</a>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">operated_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_operation</span><span class="o">=</span><span class="n">sqsum</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add two :class:`StingrayObject` instances.</span>

<span class="sd">        Add the array values of two :class:`StingrayObject` instances element by element, assuming</span>
<span class="sd">        the main array attributes of the instances match exactly.</span>

<span class="sd">        All array attrs ending with ``_err`` are treated as error bars and propagated with the</span>
<span class="sd">        sum of squares.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`StingrayTimeseries` object</span>
<span class="sd">            A second time series object</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        operated_attrs : list of str or None</span>
<span class="sd">            Array attributes to be operated on. Defaults to all array attributes not ending in</span>
<span class="sd">            ``_err``.</span>
<span class="sd">            The other array attributes will be discarded from the time series to avoid</span>
<span class="sd">            inconsistencies.</span>
<span class="sd">        error_attrs : list of str or None</span>
<span class="sd">            Array attributes to be operated on with ``error_operation``. Defaults to all array</span>
<span class="sd">            attributes ending with ``_err``.</span>
<span class="sd">        error_operation : function</span>
<span class="sd">            Function to be called to propagate the errors</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current time series. Otherwise, return a new one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
            <span class="n">operated_attrs</span><span class="o">=</span><span class="n">operated_attrs</span><span class="p">,</span>
            <span class="n">error_attrs</span><span class="o">=</span><span class="n">error_attrs</span><span class="p">,</span>
            <span class="n">error_operation</span><span class="o">=</span><span class="n">error_operation</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Operation that gets called with the ``+`` operator.</span>

<span class="sd">        Add the array values of two :class:`StingrayObject` instances element by element, assuming</span>
<span class="sd">        the main array attributes of the instances match exactly.</span>

<span class="sd">        All array attrs ending with ``_err`` are treated as error bars and propagated with the</span>
<span class="sd">        sum of squares.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
            <span class="n">error_operation</span><span class="o">=</span><span class="n">sqsum</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Operation that gets called with the ``+=`` operator.</span>

<span class="sd">        Add the array values of two :class:`StingrayObject` instances element by element, assuming</span>
<span class="sd">        the main array attributes of the instances match exactly.</span>

<span class="sd">        All array attrs ending with ``_err`` are treated as error bars and propagated with the</span>
<span class="sd">        sum of squares.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
            <span class="n">error_operation</span><span class="o">=</span><span class="n">sqsum</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="StingrayObject.sub">
<a class="viewcode-back" href="../../api.html#stingray.StingrayObject.sub">[docs]</a>
    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">operated_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_operation</span><span class="o">=</span><span class="n">sqsum</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract *all the array attrs* of two :class:`StingrayObject` instances element by element, assuming the main array attributes of the instances match exactly.</span>

<span class="sd">        All array attrs ending with ``_err`` are treated as error bars and propagated with the</span>
<span class="sd">        sum of squares.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`StingrayTimeseries` object</span>
<span class="sd">            A second time series object</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        operated_attrs : list of str or None</span>
<span class="sd">            Array attributes to be operated on. Defaults to all array attributes not ending in</span>
<span class="sd">            ``_err``.</span>
<span class="sd">            The other array attributes will be discarded from the time series to avoid</span>
<span class="sd">            inconsistencies.</span>
<span class="sd">        error_attrs : list of str or None</span>
<span class="sd">            Array attributes to be operated on with ``error_operation``. Defaults to all array</span>
<span class="sd">            attributes ending with ``_err``.</span>
<span class="sd">        error_operation : function</span>
<span class="sd">            Function to be called to propagate the errors</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current time series. Otherwise, return a new one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">,</span>
            <span class="n">operated_attrs</span><span class="o">=</span><span class="n">operated_attrs</span><span class="p">,</span>
            <span class="n">error_attrs</span><span class="o">=</span><span class="n">error_attrs</span><span class="p">,</span>
            <span class="n">error_operation</span><span class="o">=</span><span class="n">error_operation</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Operation that gets called with the ``-`` operator.</span>

<span class="sd">        Subtract *all the array attrs* of two :class:`StingrayObject` instances element by element, assuming the main array attributes of the instances match exactly.</span>

<span class="sd">        All array attrs ending with ``_err`` are treated as error bars and propagated with the</span>
<span class="sd">        sum of squares.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">,</span>
            <span class="n">error_operation</span><span class="o">=</span><span class="n">sqsum</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Operation that gets called with the ``-=`` operator.</span>

<span class="sd">        Subtract *all the array attrs* of two :class:`StingrayObject` instances element by element, assuming the main array attributes of the instances match exactly.</span>

<span class="sd">        All array attrs ending with ``_err`` are treated as error bars and propagated with the</span>
<span class="sd">        sum of squares.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">,</span>
            <span class="n">error_operation</span><span class="o">=</span><span class="n">sqsum</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement the behavior of negation of the array attributes of a :class:`StingrayObject`</span>
<span class="sd">        Error attrs are left alone.</span>

<span class="sd">        The negation operator ``-`` is supposed to invert the sign of all array attributes of a</span>
<span class="sd">        time series object, leaving out the ones ending with ``_err``.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ts_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_operated_attrs</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ts_new</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">ts_new</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of bins of a the main array attributes</span>

<span class="sd">        This method overrides the ``len`` function for a :class:`StingrayObject`</span>
<span class="sd">        object and returns the length of the array attributes (using the main array attribute</span>
<span class="sd">        as probe).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an element or a slice of the :class:`StingrayObject`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or slice instance</span>
<span class="sd">            Index value of the time array or a slice object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts_new : :class:`StingrayObject` object</span>
<span class="sd">            The new :class:`StingrayObject` object with the set of selected data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">index</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The index must be either an integer or a slice &quot;</span> <span class="s2">&quot;object !&quot;</span><span class="p">)</span>

        <span class="n">new_ts</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">main_array_attr</span><span class="p">]:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">new_ts</span></div>



<span class="k">def</span> <span class="nf">_ts_sum</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sum the number of values of a time series object.</span>

<span class="sd">    If it has a ``counts`` attribute, sum the counts. Otherwise, count the number</span>
<span class="sd">    of time samples. Masked values are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="s2">&quot;counts&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">mask</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>


<div class="viewcode-block" id="StingrayTimeseries">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries">[docs]</a>
<span class="k">class</span> <span class="nc">StingrayTimeseries</span><span class="p">(</span><span class="n">StingrayObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Basic class for time series data.</span>

<span class="sd">    This can be events, binned light curves, unevenly sampled light curves, etc. The only</span>
<span class="sd">    requirement is that the data (which can be any quantity, related or not to an electromagnetic</span>
<span class="sd">    measurement) are associated with a time measurement.</span>
<span class="sd">    We make a distinction between the *array* attributes, which have the same length of the</span>
<span class="sd">    ``time`` array, and the *meta* attributes, which can be scalars or arrays of different</span>
<span class="sd">    size. The array attributes can be multidimensional (e.g. a spectrum for each time bin),</span>
<span class="sd">    but their first dimension (``array.shape[0]``) must have same length of the ``time`` array.</span>

<span class="sd">    Array attributes are singled out automatically depending on their shape. All filtering</span>
<span class="sd">    operations (e.g. ``apply_gtis``, ``rebin``, etc.) are applied to array attributes only.</span>
<span class="sd">    For this reason, it is advisable to specify whether a given attribute should *not* be</span>
<span class="sd">    considered as an array attribute by adding it to the ``not_array_attr`` list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time: iterable</span>
<span class="sd">        A list or array of time stamps</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    array_attrs : dict</span>
<span class="sd">        Array attributes to be set (e.g. ``{&quot;flux&quot;: flux_array, &quot;flux_err&quot;: flux_err_array}``).</span>
<span class="sd">        In principle, they could be specified as simple keyword arguments. But this way, we</span>
<span class="sd">        will run a check on the length of the arrays, and raise an error if they are not of a</span>
<span class="sd">        shape compatible with the ``time`` array.</span>

<span class="sd">    dt: float</span>
<span class="sd">        The time resolution of the time series. Can be a scalar or an array attribute (useful</span>
<span class="sd">        for non-evenly sampled data or events from different instruments)</span>

<span class="sd">    mjdref : float</span>
<span class="sd">        The MJD used as a reference for the time array.</span>

<span class="sd">    gtis: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">        Good Time Intervals</span>

<span class="sd">    high_precision : bool</span>
<span class="sd">        Change the precision of self.time to float128. Useful while dealing with fast pulsars.</span>

<span class="sd">    timeref : str</span>
<span class="sd">        The time reference, as recorded in the FITS file (e.g. SOLARSYSTEM)</span>

<span class="sd">    timesys : str</span>
<span class="sd">        The time system, as recorded in the FITS file (e.g. TDB)</span>

<span class="sd">    ephem : str</span>
<span class="sd">        The JPL ephemeris used to barycenter the data, if any (e.g. DE430)</span>

<span class="sd">    skip_checks : bool</span>
<span class="sd">        Skip checks on the time array. Useful when the user is reasonably sure that the</span>
<span class="sd">        input data are valid.</span>

<span class="sd">    **other_kw :</span>
<span class="sd">        Used internally. Any other keyword arguments will be set as attributes of the object.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    time: numpy.ndarray</span>
<span class="sd">        The array of time stamps, in seconds from the reference</span>
<span class="sd">        MJD defined in ``mjdref``</span>

<span class="sd">    not_array_attr: list</span>
<span class="sd">        List of attributes that are never to be considered as array attributes. For example, GTIs</span>
<span class="sd">        are not array attributes.</span>

<span class="sd">    dt: float</span>
<span class="sd">        The time resolution of the measurements. Can be a scalar or an array attribute (useful</span>
<span class="sd">        for non-evenly sampled data or events from different instruments). It can also be 0, which</span>
<span class="sd">        means that the time series is not evenly sampled and the effects of the time resolution are</span>
<span class="sd">        considered negligible for the analysis. This is sometimes the case for events from</span>
<span class="sd">        high-energy telescopes.</span>

<span class="sd">    mjdref : float</span>
<span class="sd">        The MJD used as a reference for the time array.</span>

<span class="sd">    gtis: ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">        Good Time Intervals</span>

<span class="sd">    high_precision : bool</span>
<span class="sd">        Change the precision of self.time to float128. Useful while dealing with fast pulsars.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">main_array_attr</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span>
    <span class="n">not_array_attr</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gti&quot;</span><span class="p">]</span>
    <span class="n">_time</span><span class="p">:</span> <span class="n">TTime</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">high_precision</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">mjdref</span><span class="p">:</span> <span class="n">TTime</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">TTime</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">array_attrs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">mjdref</span><span class="p">:</span> <span class="n">TTime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">notes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">gti</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">high_precision</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ephem</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">timeref</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">timesys</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skip_checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">other_kw</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">StingrayObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="n">notes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">=</span> <span class="n">mjdref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gti</span> <span class="o">=</span> <span class="n">gti</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ephem</span> <span class="o">=</span> <span class="n">ephem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeref</span> <span class="o">=</span> <span class="n">timeref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesys</span> <span class="o">=</span> <span class="n">timesys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high_precision</span> <span class="o">=</span> <span class="n">high_precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">other_kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;dt&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_times</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">high_precision</span><span class="o">=</span><span class="n">high_precision</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">other_kw</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">,</span> <span class="n">other_kw</span><span class="p">[</span><span class="n">kw</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="n">new_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">array_attrs</span><span class="p">[</span><span class="n">kw</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lengths of time and </span><span class="si">{</span><span class="n">kw</span><span class="si">}</span><span class="s2"> must be equal.&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">,</span> <span class="n">new_arr</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">is_sorted</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_checks</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The time array is not sorted. Sorting it now.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

    <span class="nd">@time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_and_format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_times</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">high_precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">high_precision</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gti</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">dt0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dt1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt0</span> <span class="o">=</span> <span class="n">dt1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span>

    <span class="nd">@gti</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gti</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">create_gti_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_array_length</span>

    <span class="k">def</span> <span class="nf">_set_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">high_precision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>
        <span class="n">time</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">interpret_times</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">high_precision</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">(</span>
            <span class="n">attrs_to_apply</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gti&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;tstart&quot;</span><span class="p">,</span> <span class="s2">&quot;tseg&quot;</span><span class="p">,</span> <span class="s2">&quot;tstop&quot;</span><span class="p">],</span>
            <span class="n">func_to_apply</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">86400</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span> <span class="s2">&quot;MJD&quot;</span><span class="p">),</span>
            <span class="n">attrs_to_discard</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;header&quot;</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_and_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">compare_to_attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the size of a value is compatible with the size of another attribute.</span>

<span class="sd">        Different cases are possible:</span>

<span class="sd">        - If the value is None, we return None</span>
<span class="sd">        - If the value is a scalar, we fail</span>
<span class="sd">        - If the value is an array, we check if it has the correct shape by comparing it with</span>
<span class="sd">          another attribute. In the special case where the attribute is the same, if it is None</span>
<span class="sd">          we assign the new value. Otherwise, the first dimension of the value and the current</span>
<span class="sd">          value of the attribute being compared with has to be the same.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : array-like or None</span>
<span class="sd">            The value to check.</span>
<span class="sd">        attr_name : str</span>
<span class="sd">            The name of the attribute being checked.</span>
<span class="sd">        compare_to_attr : str</span>
<span class="sd">            The name of the attribute to compare with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : array-like or None</span>
<span class="sd">            The value to check wrapped in a class:`np.array`, if it is not None. Otherwise None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attr_name</span><span class="si">}</span><span class="s2"> array must be at least 1D&quot;</span><span class="p">)</span>
        <span class="c1"># If the attribute we compare it with is the same and it is currently None, we assign it</span>
        <span class="c1"># This can happen, e.g. with the time array.</span>
        <span class="n">compare_with</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compare_to_attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr_name</span> <span class="o">==</span> <span class="n">compare_to_attr</span> <span class="ow">and</span> <span class="n">compare_with</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c1"># In the special case where the current value of the attribute being compared</span>
        <span class="c1"># is None, this also has to fail.</span>
        <span class="k">if</span> <span class="n">compare_with</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Can only assign new </span><span class="si">{</span><span class="n">attr_name</span><span class="si">}</span><span class="s2"> if the </span><span class="si">{</span><span class="n">compare_to_attr</span><span class="si">}</span><span class="s2"> array is not None&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">compare_with</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Can only assign new </span><span class="si">{</span><span class="n">attr_name</span><span class="si">}</span><span class="s2"> of the same shape as the </span><span class="si">{</span><span class="n">compare_to_attr</span><span class="si">}</span><span class="s2"> array&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exposure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total exposure of the time series, i.e. the sum of the GTIs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_exposure : float</span>
<span class="sd">            The total exposure of the time series, in seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">get_total_gti_length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_ts</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other_ts</span><span class="p">)</span>

<div class="viewcode-block" id="StingrayTimeseries.apply_gtis">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.apply_gtis">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_gtis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_gti</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply Good Time Intervals (GTIs) to a time series. Filters all the array attributes, only</span>
<span class="sd">        keeping the bins that fall into GTIs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current time series. Otherwise, return a new one.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># I import here to avoid the risk of circular imports</span>

        <span class="k">if</span> <span class="n">new_gti</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_gti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span>

        <span class="n">check_gtis</span><span class="p">(</span><span class="n">new_gti</span><span class="p">)</span>

        <span class="c1"># This will automatically be recreated from GTIs once I set it to None</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">create_gti_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">new_gti</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">newts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">good</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="c1"># Important, otherwise addition/subtraction ops will go into an infinite loop</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">newts</span><span class="o">.</span><span class="n">gti</span> <span class="o">=</span> <span class="n">new_gti</span>
        <span class="k">return</span> <span class="n">newts</span></div>


<div class="viewcode-block" id="StingrayTimeseries.split_by_gti">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.split_by_gti">[docs]</a>
    <span class="k">def</span> <span class="nf">split_by_gti</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gti</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_points</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split the current :class:`StingrayTimeseries` object into a list of</span>
<span class="sd">        :class:`StingrayTimeseries` objects, one for each continuous GTI segment</span>
<span class="sd">        as defined in the ``gti`` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_points : int, default 1</span>
<span class="sd">            The minimum number of data points in each time series. Light</span>
<span class="sd">            curves with fewer data points will be ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list_of_tss : list</span>
<span class="sd">            A list of :class:`StingrayTimeseries` objects, one for each GTI segment</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">gti</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span>

        <span class="n">list_of_tss</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">start_bins</span><span class="p">,</span> <span class="n">stop_bins</span> <span class="o">=</span> <span class="n">gti_border_bins</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_bins</span><span class="p">)):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">stop_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_points</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">new_gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">gti</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">create_gti_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">new_gti</span><span class="p">)</span>

            <span class="c1"># Note: GTIs are consistent with default in this case!</span>
            <span class="n">new_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">new_ts</span><span class="o">.</span><span class="n">gti</span> <span class="o">=</span> <span class="n">new_gti</span>

            <span class="n">list_of_tss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">list_of_tss</span></div>


<div class="viewcode-block" id="StingrayTimeseries.to_astropy_timeseries">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.to_astropy_timeseries">[docs]</a>
    <span class="k">def</span> <span class="nf">to_astropy_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the ``StingrayTimeseries`` to an ``Astropy`` timeseries.</span>

<span class="sd">        Array attributes (time, pi, energy, etc.) are converted</span>
<span class="sd">        into columns, while meta attributes (mjdref, gti, etc.)</span>
<span class="sd">        are saved into the ``meta`` dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : `astropy.timeseries.TimeSeries`</span>
<span class="sd">            A ``TimeSeries`` object with the array attributes as columns,</span>
<span class="sd">            and the meta attributes in the `meta` dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">astropy.timeseries</span> <span class="kn">import</span> <span class="n">TimeSeries</span>
        <span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">TimeDelta</span>
        <span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">array_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">data</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="p">{}:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">TimeDelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">()</span>

        <span class="n">ts</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_meta_dict</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">ts</span></div>


<div class="viewcode-block" id="StingrayTimeseries.from_astropy_timeseries">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.from_astropy_timeseries">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_astropy_timeseries</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StingrayTimeseries</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a `StingrayTimeseries` from data in an Astropy TimeSeries</span>

<span class="sd">        The timeseries has to define at least a column called time,</span>
<span class="sd">        the rest of columns will form the array attributes of the</span>
<span class="sd">        new time series, while the attributes in table.meta will</span>
<span class="sd">        form the new meta attributes of the time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts : `astropy.timeseries.TimeSeries`</span>
<span class="sd">            A ``TimeSeries`` object with the array attributes as columns,</span>
<span class="sd">            and the meta attributes in the `meta` dictionary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : `StingrayTimeseries`</span>
<span class="sd">            Timeseries object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
        <span class="n">mjdref</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;mjdref&quot;</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
            <span class="n">mjdref</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;mjdref&quot;</span><span class="p">]</span>

        <span class="n">new_cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">time</span><span class="p">,</span> <span class="n">mjdref</span> <span class="o">=</span> <span class="n">interpret_times</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">mjdref</span><span class="p">)</span>
        <span class="n">new_cls</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="n">array_attrs</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">colnames</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">array_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">attr</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">new_cls</span></div>


<div class="viewcode-block" id="StingrayTimeseries.change_mjdref">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.change_mjdref">[docs]</a>
    <span class="k">def</span> <span class="nf">change_mjdref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_mjdref</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StingrayTimeseries</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the MJD reference time (MJDREF) of the time series</span>

<span class="sd">        The times of the time series will be shifted in order to be referred to</span>
<span class="sd">        this new MJDREF</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_mjdref : float</span>
<span class="sd">            New MJDREF</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current time series. Otherwise, return a new one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_ts : :class:`StingrayTimeseries` object</span>
<span class="sd">            The new time series, shifted by MJDREF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_shift</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">-</span> <span class="n">new_mjdref</span><span class="p">)</span> <span class="o">*</span> <span class="mi">86400</span>  <span class="c1"># type: ignore</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">time_shift</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">=</span> <span class="n">new_mjdref</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">ts</span></div>


<div class="viewcode-block" id="StingrayTimeseries.shift">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.shift">[docs]</a>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_shift</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StingrayTimeseries</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shift the time and the GTIs by the same amount</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_shift: float</span>
<span class="sd">            The time interval by which the time series will be shifted (in</span>
<span class="sd">            the same units as the time array in :class:`StingrayTimeseries`</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current time series. Otherwise, return a new one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : ``StingrayTimeseries`` object</span>
<span class="sd">            The new time series shifted by ``time_shift``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="n">time_shift</span>  <span class="c1"># type: ignore</span>
        <span class="c1"># Pay attention here: if the GTIs are created dynamically while we</span>
        <span class="c1"># access the property,</span>
        <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">_gti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">_gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_gti</span><span class="p">)</span> <span class="o">+</span> <span class="n">time_shift</span>  <span class="c1"># type: ignore</span>

        <span class="k">return</span> <span class="n">ts</span></div>


    <span class="k">def</span> <span class="nf">_operation_with_other_obj</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">operated_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_operation</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to codify an operation of one time series with another (e.g. add, subtract).</span>
<span class="sd">        Takes into account the GTIs correctly, and returns a new :class:`StingrayTimeseries` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`StingrayTimeseries` object</span>
<span class="sd">            A second time series object</span>

<span class="sd">        operation : function</span>
<span class="sd">            An operation between the :class:`StingrayTimeseries` object calling this method, and</span>
<span class="sd">            ``other``, operating on all the specified array attributes.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        operated_attrs : list of str or None</span>
<span class="sd">            Array attributes to be operated on. Defaults to all array attributes not ending in</span>
<span class="sd">            ``_err``.</span>
<span class="sd">            The other array attributes will be discarded from the time series to avoid</span>
<span class="sd">            inconsistencies.</span>

<span class="sd">        error_attrs : list of str or None</span>
<span class="sd">            Array attributes to be operated on with ``error_operation``. Defaults to all array</span>
<span class="sd">            attributes ending with ``_err``.</span>

<span class="sd">        error_operation : function</span>
<span class="sd">            The function used for error propagation. Defaults to the sum of squares.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts_new : StingrayTimeseries object</span>
<span class="sd">            The new time series calculated in ``operation``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">mjdref</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;MJDref is different in the two time series&quot;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">change_mjdref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">gti</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The good time intervals in the two time series are different. Data outside the &quot;</span>
                <span class="s2">&quot;common GTIs will be discarded.&quot;</span>
            <span class="p">)</span>
            <span class="n">common_gti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span>
            <span class="n">masked_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_gtis</span><span class="p">(</span><span class="n">common_gti</span><span class="p">)</span>
            <span class="n">masked_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">apply_gtis</span><span class="p">(</span><span class="n">common_gti</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">masked_self</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span>
                <span class="n">masked_other</span><span class="p">,</span>
                <span class="n">operation</span><span class="p">,</span>
                <span class="n">operated_attrs</span><span class="o">=</span><span class="n">operated_attrs</span><span class="p">,</span>
                <span class="n">error_attrs</span><span class="o">=</span><span class="n">error_attrs</span><span class="p">,</span>
                <span class="n">error_operation</span><span class="o">=</span><span class="n">error_operation</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">operation</span><span class="p">,</span>
            <span class="n">operated_attrs</span><span class="o">=</span><span class="n">operated_attrs</span><span class="p">,</span>
            <span class="n">error_attrs</span><span class="o">=</span><span class="n">error_attrs</span><span class="p">,</span>
            <span class="n">error_operation</span><span class="o">=</span><span class="n">error_operation</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the array values of two time series element by element, assuming they</span>
<span class="sd">        have the same time array.</span>

<span class="sd">        This magic method adds two :class:`TimeSeries` objects having the same time</span>
<span class="sd">        array such that the corresponding array arrays get summed up.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [5, 10, 15]</span>
<span class="sd">        &gt;&gt;&gt; count1 = [300, 100, 400]</span>
<span class="sd">        &gt;&gt;&gt; count2 = [600, 1200, 800]</span>
<span class="sd">        &gt;&gt;&gt; gti1 = [[0, 25]]</span>
<span class="sd">        &gt;&gt;&gt; gti2 = [[0, 25]]</span>
<span class="sd">        &gt;&gt;&gt; ts1 = StingrayTimeseries(time, array_attrs=dict(counts=count1), gti=gti1, dt=5)</span>
<span class="sd">        &gt;&gt;&gt; ts2 = StingrayTimeseries(time, array_attrs=dict(counts=count2), gti=gti2, dt=5)</span>
<span class="sd">        &gt;&gt;&gt; ts = ts1 + ts2</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(ts.counts, [ 900, 1300, 1200])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract the counts/flux of one time series from the counts/flux of another</span>
<span class="sd">        time series element by element, assuming the ``time`` arrays of the time series</span>
<span class="sd">        match exactly.</span>

<span class="sd">        This magic method adds two :class:`StingrayTimeSeries` objects having the same</span>
<span class="sd">        ``time`` array and subtracts the ``counts`` of one :class:`StingrayTimeseries` with</span>
<span class="sd">        that of another, while also updating ``countrate``, ``counts_err`` and ``countrate_err``</span>
<span class="sd">        correctly.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [10, 20, 30]</span>
<span class="sd">        &gt;&gt;&gt; count1 = [600, 1200, 800]</span>
<span class="sd">        &gt;&gt;&gt; count2 = [300, 100, 400]</span>
<span class="sd">        &gt;&gt;&gt; gti1 = [[0, 35]]</span>
<span class="sd">        &gt;&gt;&gt; gti2 = [[0, 35]]</span>
<span class="sd">        &gt;&gt;&gt; ts1 = StingrayTimeseries(time, array_attrs=dict(counts=count1), gti=gti1, dt=10)</span>
<span class="sd">        &gt;&gt;&gt; ts2 = StingrayTimeseries(time, array_attrs=dict(counts=count2), gti=gti2, dt=10)</span>
<span class="sd">        &gt;&gt;&gt; ts = ts1 - ts2</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(ts.counts, [ 300, 1100,  400])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__sub__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the corresponding count value at the index or a new :class:`StingrayTimeseries`</span>
<span class="sd">        object upon slicing.</span>

<span class="sd">        This method adds functionality to retrieve the count value at</span>
<span class="sd">        a particular index. This also can be used for slicing and generating</span>
<span class="sd">        a new :class:`StingrayTimeseries` object. GTIs are recalculated based on the new light</span>
<span class="sd">        curve segment</span>

<span class="sd">        If the slice object is of kind ``start:stop:step`` and ``dt`` is not 0, GTIs are also</span>
<span class="sd">        sliced, by crossing with ``zip(time - self.dt /2, time + self.dt / 2)``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or slice instance</span>
<span class="sd">            Index value of the time array or a slice object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; count = [11, 22, 33, 44, 55, 66, 77, 88, 99]</span>
<span class="sd">        &gt;&gt;&gt; ts = StingrayTimeseries(time, array_attrs=dict(counts=count), dt=1)</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(ts[2].counts, [33])</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(ts[:2].counts, [11, 22])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_ts</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
            <span class="n">delta_gti_start</span> <span class="o">=</span> <span class="n">delta_gti_stop</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta_gti_start</span> <span class="o">=</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">delta_gti_stop</span> <span class="o">=</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span>

        <span class="n">new_gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">new_ts</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta_gti_start</span><span class="p">,</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta_gti_stop</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">delta_gti_start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_gt1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">new_ts</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="n">new_gti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="n">new_gti</span><span class="p">,</span> <span class="n">new_gt1</span><span class="p">)</span>
        <span class="n">new_gti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">new_gti</span><span class="p">)</span>

        <span class="n">new_ts</span><span class="o">.</span><span class="n">gti</span> <span class="o">=</span> <span class="n">new_gti</span>
        <span class="k">return</span> <span class="n">new_ts</span>

<div class="viewcode-block" id="StingrayTimeseries.truncate">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.truncate">[docs]</a>
    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncate a :class:`StingrayTimeseries` object.</span>

<span class="sd">        This method takes a ``start`` and a ``stop`` point (either as indices,</span>
<span class="sd">        or as times in the same unit as those in the ``time`` attribute, and truncates</span>
<span class="sd">        all bins before ``start`` and after ``stop``, then returns a new</span>
<span class="sd">        :class:`StingrayTimeseries` object with the truncated time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, default 0</span>
<span class="sd">            Index (or time stamp) of the starting point of the truncation. If no value is set</span>
<span class="sd">            for the start point, then all points from the first element in the ``time`` array</span>
<span class="sd">            are taken into account.</span>

<span class="sd">        stop : int, default ``None``</span>
<span class="sd">            Index (or time stamp) of the ending point (exclusive) of the truncation. If no</span>
<span class="sd">            value of stop is set, then points including the last point in</span>
<span class="sd">            the counts array are taken in count.</span>

<span class="sd">        method : {``index`` | ``time``}, optional, default ``index``</span>
<span class="sd">            Type of the start and stop values. If set to ``index`` then</span>
<span class="sd">            the values are treated as indices of the counts array, or</span>
<span class="sd">            if set to ``time``, the values are treated as actual time values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts_new: :class:`StingrayTimeseries` object</span>
<span class="sd">            The :class:`StingrayTimeseries` object with truncated time and arrays.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; count = [10, 20, 30, 40, 50, 60, 70, 80, 90]</span>
<span class="sd">        &gt;&gt;&gt; ts = StingrayTimeseries(time, array_attrs={&quot;counts&quot;: count}, dt=1)</span>
<span class="sd">        &gt;&gt;&gt; ts_new = ts.truncate(start=2, stop=8)</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(ts_new.counts, [30, 40, 50, 60, 70, 80])</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(ts_new.time, [3, 4, 5, 6, 7, 8])</span>
<span class="sd">        &gt;&gt;&gt; # Truncation can also be done by time values</span>
<span class="sd">        &gt;&gt;&gt; ts_new = ts.truncate(start=6, method=&#39;time&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(ts_new.time, [6, 7, 8, 9])</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(ts_new.counts, [60, 70, 80, 90])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The method keyword argument is not a string !&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown method type &quot;</span> <span class="o">+</span> <span class="n">method</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span>
            <span class="n">new_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncate_by_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncate_by_time</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="n">new_ts</span><span class="o">.</span><span class="n">tstart</span> <span class="o">=</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">gti</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">new_ts</span><span class="o">.</span><span class="n">tseg</span> <span class="o">=</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">gti</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">gti</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_ts</span></div>


    <span class="k">def</span> <span class="nf">_truncate_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private method for truncation using index values.&quot;&quot;&quot;</span>

        <span class="n">new_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>

        <span class="n">dtstart</span> <span class="o">=</span> <span class="n">dtstop</span> <span class="o">=</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">dtstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dtstop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">gti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">([[</span><span class="n">new_ts</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dtstart</span><span class="p">,</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dtstop</span><span class="p">]]),</span>
        <span class="p">)</span>

        <span class="n">new_ts</span><span class="o">.</span><span class="n">gti</span> <span class="o">=</span> <span class="n">gti</span>

        <span class="k">return</span> <span class="n">new_ts</span>

    <span class="k">def</span> <span class="nf">_truncate_by_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper method for truncation using time values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : float</span>
<span class="sd">            start time for new time series; all time bins before this time will be discarded</span>

<span class="sd">        stop : float</span>
<span class="sd">            stop time for new time series; all time bins after this point will be discarded</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            new_ts : StingrayTimeseries</span>
<span class="sd">                A new :class:`StingrayTimeseries` object with the truncated time bins</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start time must be less than stop time!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncate_by_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

<div class="viewcode-block" id="StingrayTimeseries.concatenate">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.concatenate">[docs]</a>
    <span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">check_gti</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate two :class:`StingrayTimeseries` objects.</span>

<span class="sd">        This method concatenates two or more :class:`StingrayTimeseries` objects along the time</span>
<span class="sd">        axis. GTIs are recalculated by merging all the GTIs together. GTIs should not overlap at</span>
<span class="sd">        any point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`StingrayTimeseries` object or list of :class:`StingrayTimeseries` objects</span>
<span class="sd">            A second time series object, or a list of objects to be concatenated</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        check_gti : bool</span>
<span class="sd">            Check if the GTIs are overlapping or not. Default: True</span>
<span class="sd">            If this is True and GTIs overlap, an error is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">check_gti</span><span class="p">:</span>
            <span class="n">treatment</span> <span class="o">=</span> <span class="s2">&quot;append&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">treatment</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
        <span class="n">new_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_timeseries</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">treatment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_ts</span></div>


    <span class="k">def</span> <span class="nf">_join_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">others</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">,</span> <span class="n">ignore_meta</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper method to join two or more :class:`StingrayTimeseries` objects.</span>

<span class="sd">        This is a helper method that can be called by other user-facing methods, such as</span>
<span class="sd">        :class:`StingrayTimeseries().join()`.</span>

<span class="sd">        Standard attributes such as ``pi`` and ``energy`` remain ``None`` if they are ``None``</span>
<span class="sd">        in both. Otherwise, ``np.nan`` is used as a default value for the missing values.</span>
<span class="sd">        Arbitrary array attributes are created and joined using the same convention.</span>

<span class="sd">        Multiple checks are done on the joined time series. If the time array of the series</span>
<span class="sd">        being joined is empty, it is ignored (and a copy of the original time series is returned</span>
<span class="sd">        instead). If the time resolution is different, the final time series will associate</span>
<span class="sd">        different time resolutions to different time bins.</span>
<span class="sd">        If the MJDREF is different (including being 0), the time reference will be changed to</span>
<span class="sd">        the one of the first time series. An empty time series will be ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`StingrayTimeseries` or class:`list` of :class:`StingrayTimeseries`</span>
<span class="sd">            The other :class:`StingrayTimeseries` object which is supposed to be joined with.</span>
<span class="sd">            If ``other`` is a list, it is assumed to be a list of :class:`StingrayTimeseries`</span>
<span class="sd">            and they are all joined, one by one.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        strategy : {&quot;intersection&quot;, &quot;union&quot;, &quot;append&quot;, &quot;infer&quot;, &quot;none&quot;}</span>
<span class="sd">            Method to use to merge the GTIs. If &quot;intersection&quot;, the GTIs are merged</span>
<span class="sd">            using the intersection of the GTIs. If &quot;union&quot;, the GTIs are merged</span>
<span class="sd">            using the union of the GTIs. If &quot;none&quot;, a single GTI with the minimum and</span>
<span class="sd">            the maximum time stamps of all GTIs is returned. If &quot;infer&quot;, the strategy</span>
<span class="sd">            is decided based on the GTIs. If there are no overlaps, &quot;union&quot; is used,</span>
<span class="sd">            otherwise &quot;intersection&quot; is used. If &quot;append&quot;, the GTIs are simply appended</span>
<span class="sd">            but they must be mutually exclusive.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `ts_new` : :class:`StingrayTimeseries` object</span>
<span class="sd">            The resulting :class:`StingrayTimeseries` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_ts</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">StingrayObject</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">others</span> <span class="o">=</span> <span class="p">[</span><span class="n">others</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">others</span> <span class="o">=</span> <span class="n">others</span>

        <span class="c1"># First of all, check if there are empty objects</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects can only be merged with other </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;One of the time series you are joining is empty.&quot;</span><span class="p">)</span>
                <span class="n">others</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">other</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">others</span><span class="p">):</span>
            <span class="c1"># Tolerance for MJDREF:1 microsecond</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span> <span class="o">/</span> <span class="mi">86400</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Attribute mjdref is different in the time series being merged.&quot;</span><span class="p">)</span>
                <span class="n">others</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">change_mjdref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">)</span>

        <span class="n">all_objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">others</span>

        <span class="c1"># Check if none of the GTIs was already initialized.</span>
        <span class="n">all_gti</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">_gti</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">all_objs</span> <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">_gti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_gti</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">new_gti</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For this, initialize the GTIs</span>
            <span class="n">new_gti</span> <span class="o">=</span> <span class="n">merge_gtis</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">gti</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">all_objs</span><span class="p">],</span> <span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">)</span>

        <span class="n">all_time_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">all_objs</span> <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">new_ts</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">all_time_arrays</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">new_ts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="n">new_ts</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

        <span class="n">new_ts</span><span class="o">.</span><span class="n">gti</span> <span class="o">=</span> <span class="n">new_gti</span>

        <span class="n">dts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;dt&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">all_objs</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The time resolution is different. Transforming in array&quot;</span><span class="p">)</span>

            <span class="n">new_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">dt</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">all_objs</span><span class="p">])</span>
            <span class="n">new_ts</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">new_dt</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_ts</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">_get_set_from_many_lists</span><span class="p">(</span><span class="n">lists</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Make a single set out of many lists.&quot;&quot;&quot;</span>
            <span class="n">all_vals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
                <span class="n">all_vals</span> <span class="o">+=</span> <span class="n">ls</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_vals</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_all_array_attrs</span><span class="p">(</span><span class="n">objs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Get all array attributes from the time series being merged. Do not include time.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">_get_set_from_many_lists</span><span class="p">(</span>
                <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_get_all_array_attrs</span><span class="p">(</span><span class="n">all_objs</span><span class="p">):</span>
            <span class="c1"># if it&#39;s here, it means that it&#39;s an array attr in at least one object.</span>
            <span class="c1"># So, everywhere it&#39;s None, it needs to be set to 0s of the same length as time</span>
            <span class="n">new_attr_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">all_objs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> array is empty in one of the time series being merged. &quot;</span>
                        <span class="s2">&quot;Setting it to NaN for the affected events&quot;</span>
                    <span class="p">)</span>
                    <span class="n">new_attr_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_attr_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

            <span class="n">new_attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_attr_values</span><span class="p">)[</span><span class="n">order</span><span class="p">]</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">new_attr</span><span class="p">)</span>

        <span class="n">all_meta_attrs</span> <span class="o">=</span> <span class="n">_get_set_from_many_lists</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">all_objs</span><span class="p">])</span>
        <span class="c1"># The attributes being treated separately are removed from the standard treatment</span>
        <span class="c1"># When energy, pi etc. are None, they might appear in the meta_attrs, so we</span>
        <span class="c1"># also add them to the list of attributes to be removed if present.</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gti&quot;</span><span class="p">,</span> <span class="s2">&quot;dt&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">all_meta_attrs</span><span class="p">:</span>
                <span class="n">all_meta_attrs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">ignore_meta</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> attribute will be removed from the output &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">all_meta_attrs</span><span class="p">:</span>
                <span class="n">all_meta_attrs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_safe_concatenate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="n">b</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">all_meta_attrs</span><span class="p">:</span>
            <span class="n">self_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">new_val</span> <span class="o">=</span> <span class="n">self_attr</span>
            <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
                <span class="n">other_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">self_attr</span> <span class="o">!=</span> <span class="n">other_attr</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Attribute &quot;</span> <span class="o">+</span> <span class="n">attr</span> <span class="o">+</span> <span class="s2">&quot; is different in the time series being merged.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">new_val</span> <span class="o">=</span> <span class="n">_safe_concatenate</span><span class="p">(</span><span class="n">new_val</span><span class="p">,</span> <span class="n">other_attr</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">new_val</span><span class="p">)</span>

        <span class="n">new_ts</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span>

        <span class="k">return</span> <span class="n">new_ts</span>

<div class="viewcode-block" id="StingrayTimeseries.join">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.join">[docs]</a>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join other :class:`StingrayTimeseries` objects with the current one.</span>

<span class="sd">        If both are empty, an empty :class:`StingrayTimeseries` is returned.</span>

<span class="sd">        Standard attributes such as ``pi`` and ``energy`` remain ``None`` if they are ``None``</span>
<span class="sd">        in both. Otherwise, ``np.nan`` is used as a default value for the missing values.</span>
<span class="sd">        Arbitrary array attributes are created and joined using the same convention.</span>

<span class="sd">        Multiple checks are done on the joined time series. If the time array of the series</span>
<span class="sd">        being joined is empty, it is ignored. If the time resolution is different, the final</span>
<span class="sd">        time series will have the rougher time resolution. If the MJDREF is different, the time</span>
<span class="sd">        reference will be changed to the one of the first time series. An empty time series will</span>
<span class="sd">        be ignored.</span>

<span class="sd">        Note: ``join`` is not equivalent to ``concatenate``. ``concatenate`` is used to join</span>
<span class="sd">        multiple **non-overlapping** time series along the time axis, while ``join`` is more</span>
<span class="sd">        general, and can be used to join multiple time series with different strategies (see</span>
<span class="sd">        parameter ``strategy`` below).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`StingrayTimeseries` or class:`list` of :class:`StingrayTimeseries`</span>
<span class="sd">            The other :class:`StingrayTimeseries` object which is supposed to be joined with.</span>
<span class="sd">            If ``other`` is a list, it is assumed to be a list of :class:`StingrayTimeseries`</span>
<span class="sd">            and they are all joined, one by one.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        strategy : {&quot;intersection&quot;, &quot;union&quot;, &quot;append&quot;, &quot;infer&quot;, &quot;none&quot;}</span>
<span class="sd">            Method to use to merge the GTIs. If &quot;intersection&quot;, the GTIs are merged</span>
<span class="sd">            using the intersection of the GTIs. If &quot;union&quot;, the GTIs are merged</span>
<span class="sd">            using the union of the GTIs. If &quot;none&quot;, a single GTI with the minimum and</span>
<span class="sd">            the maximum time stamps of all GTIs is returned. If &quot;infer&quot;, the strategy</span>
<span class="sd">            is decided based on the GTIs. If there are no overlaps, &quot;union&quot; is used,</span>
<span class="sd">            otherwise &quot;intersection&quot; is used. If &quot;append&quot;, the GTIs are simply appended</span>
<span class="sd">            but they must be mutually exclusive.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `ts_new` : :class:`StingrayTimeseries` object</span>
<span class="sd">            The resulting :class:`StingrayTimeseries` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_timeseries</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="StingrayTimeseries.rebin">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.rebin">[docs]</a>
    <span class="k">def</span> <span class="nf">rebin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt_new</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rebin the time series to a new time resolution. While the new</span>
<span class="sd">        resolution need not be an integer multiple of the previous time</span>
<span class="sd">        resolution, be aware that if it is not, the last bin will be cut</span>
<span class="sd">        off by the fraction left over by the integer division.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt_new: float</span>
<span class="sd">            The new time resolution of the time series. Must be larger than</span>
<span class="sd">            the time resolution of the old time series!</span>

<span class="sd">        method: {``sum`` | ``mean`` | ``average``}, optional, default ``sum``</span>
<span class="sd">            This keyword argument sets whether the counts in the new bins</span>
<span class="sd">            should be summed or averaged.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        f: float</span>
<span class="sd">            the rebin factor. If specified, it substitutes ``dt_new`` with</span>
<span class="sd">            ``f*self.dt``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts_new: :class:`StingrayTimeseries` object</span>
<span class="sd">            The :class:`StingrayTimeseries` object with the new, binned time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt_new</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to specify at least one between f and &quot;</span> <span class="s2">&quot;dt_new&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt_new</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dt_new</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The new time resolution must be larger than the old one!&quot;</span><span class="p">)</span>

        <span class="n">gti_new</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">new_ts</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">():</span>
            <span class="n">bin_time</span><span class="p">,</span> <span class="n">bin_counts</span><span class="p">,</span> <span class="n">bin_err</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;_err&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">e_temp</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dt_new</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># find start and end of GTI segment in data</span>
                    <span class="n">start_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">end_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                    <span class="n">t_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">end_ind</span><span class="p">]</span>
                    <span class="n">c_temp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">end_ind</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span> <span class="o">+</span> <span class="s2">&quot;_err&quot;</span><span class="p">):</span>
                        <span class="n">e_temp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span> <span class="o">+</span> <span class="s2">&quot;_err&quot;</span><span class="p">)[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">end_ind</span><span class="p">]</span>

                    <span class="n">bin_t</span><span class="p">,</span> <span class="n">bin_c</span><span class="p">,</span> <span class="n">bin_e</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rebin_data</span><span class="p">(</span>
                        <span class="n">t_temp</span><span class="p">,</span> <span class="n">c_temp</span><span class="p">,</span> <span class="n">dt_new</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">e_temp</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
                    <span class="p">)</span>

                    <span class="n">bin_time</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bin_t</span><span class="p">)</span>
                    <span class="n">bin_counts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bin_c</span><span class="p">)</span>
                    <span class="n">bin_err</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bin_e</span><span class="p">)</span>
                    <span class="n">gti_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_ts</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_time</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">bin_counts</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">e_temp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span> <span class="o">+</span> <span class="s2">&quot;_err&quot;</span><span class="p">,</span> <span class="n">bin_err</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gti_new</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid GTIs after rebin.&quot;</span><span class="p">)</span>
        <span class="n">new_ts</span><span class="o">.</span><span class="n">gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti_new</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;dt&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_ts</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)))</span>
        <span class="n">new_ts</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt_new</span>
        <span class="k">return</span> <span class="n">new_ts</span></div>


<div class="viewcode-block" id="StingrayTimeseries.sort">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.sort">[docs]</a>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort a ``StingrayTimeseries`` object by time.</span>

<span class="sd">        A ``StingrayTimeseries`` can be sorted in either increasing or decreasing order</span>
<span class="sd">        using this method. The time array gets sorted and the counts array is</span>
<span class="sd">        changed accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reverse : boolean, default False</span>
<span class="sd">            If True then the object is sorted in reverse order.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current time series. Otherwise, return a new one.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [2, 1, 3]</span>
<span class="sd">        &gt;&gt;&gt; count = [200, 100, 300]</span>
<span class="sd">        &gt;&gt;&gt; ts = StingrayTimeseries(time, array_attrs={&quot;counts&quot;: count}, dt=1, skip_checks=True)</span>
<span class="sd">        &gt;&gt;&gt; ts_new = ts.sort()</span>
<span class="sd">        &gt;&gt;&gt; ts_new.time</span>
<span class="sd">        array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(ts_new.counts, [100, 200, 300])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts_new: :class:`StingrayTimeseries` object</span>
<span class="sd">            The :class:`StingrayTimeseries` object with sorted time and counts</span>
<span class="sd">            arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span></div>


<div class="viewcode-block" id="StingrayTimeseries.fill_bad_time_intervals">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.fill_bad_time_intervals">[docs]</a>
    <span class="k">def</span> <span class="nf">fill_bad_time_intervals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attrs_to_randomize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">even_sampling</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill short bad time intervals with random data.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method is only appropriate for *very short* bad time intervals. The simulated data</span>
<span class="sd">            are basically white noise, so they are able to alter the statistical properties of</span>
<span class="sd">            variable data. For very short gaps in the data, the effect of these small</span>
<span class="sd">            injections of white noise should be negligible. How short depends on the single case,</span>
<span class="sd">            the user is urged not to use the method as a black box and make simulations to measure</span>
<span class="sd">            its effect. If you have long bad time intervals, you should use more advanced</span>
<span class="sd">            techniques, not currently available in Stingray for this use case, such as Gaussian</span>
<span class="sd">            Processes. In particular, please verify that the values of ``max_length`` and</span>
<span class="sd">            ``buffer_size`` are adequate to your case.</span>

<span class="sd">        To fill the gaps in all but the time points (i.e., flux measures, energies), we take the</span>
<span class="sd">        ``buffer_size`` (by default, the largest value between 100 and the estimated samples in</span>
<span class="sd">        a ``max_length``-long gap) valid data points closest to the gap and repeat them randomly</span>
<span class="sd">        with the same empirical statistical distribution. So, if the `my_fancy_attr` attribute, in</span>
<span class="sd">        the 100 points of the buffer, has 30 times 10, 10 times 9, and 60 times 11, there will be</span>
<span class="sd">        *on average* 30% of 10, 60% of 11, and 10% of 9 in the simulated data.</span>

<span class="sd">        Times are treated differently depending on the fact that the time series is evenly</span>
<span class="sd">        sampled or not. If it is not, the times are simulated from a uniform distribution with the</span>
<span class="sd">        same count rate found in the buffer. Otherwise, times just follow the same grid used</span>
<span class="sd">        inside GTIs. Using the evenly sampled or not is decided based on the ``even_sampling``</span>
<span class="sd">        parameter. If left to ``None``, the time series is considered evenly sampled if</span>
<span class="sd">        ``self.dt`` is greater than zero and the median separation between subsequent times is</span>
<span class="sd">        within 1% of the time resolution.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        max_length : float</span>
<span class="sd">            Maximum length of a bad time interval to be filled. If None, the criterion is bad</span>
<span class="sd">            time intervals shorter than 1/100th of the longest good time interval.</span>
<span class="sd">        attrs_to_randomize : list of str, default None</span>
<span class="sd">            List of array_attrs to randomize. ``If None``, all array_attrs are randomized.</span>
<span class="sd">            It should not include ``time`` and ``_mask``, which are treated separately.</span>
<span class="sd">        buffer_size : int, default 100</span>
<span class="sd">            Number of good data points to use to calculate the means and variance the random data</span>
<span class="sd">            on each side of the bad time interval</span>
<span class="sd">        even_sampling : bool, default None</span>
<span class="sd">            Force the treatment of the data as evenly sampled or not. If None, the data are</span>
<span class="sd">            considered evenly sampled if ``self.dt`` is larger than zero and the median</span>
<span class="sd">            separation between subsequent times is within 1% of ``self.dt``.</span>
<span class="sd">        seed : int, default None</span>
<span class="sd">            Random seed to use for the simulation. If None, a random seed is generated.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rs</span> <span class="o">=</span> <span class="n">get_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attrs_to_randomize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attrs_to_randomize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;_mask&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs_to_randomize</span><span class="p">:</span>
                    <span class="n">attrs_to_randomize</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="n">attrs_to_leave_alone</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">attrs_to_randomize</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">max_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">100</span>

        <span class="n">btis</span> <span class="o">=</span> <span class="n">get_btis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">btis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No bad time intervals to fill&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">filtered_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>

        <span class="n">new_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">filtered_times</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>
        <span class="n">new_attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">mean_data_separation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">filtered_times</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">even_sampling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The time series is considered evenly sampled if the median separation between</span>
            <span class="c1"># subsequent times is within 1% of the time resolution</span>
            <span class="n">even_sampling</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">mean_data_separation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
                <span class="n">even_sampling</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data are </span><span class="si">{</span><span class="s1">&#39;not&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">even_sampling</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2"> evenly sampled&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">even_sampling</span><span class="p">:</span>
            <span class="n">est_samples_in_gap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_length</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">est_samples_in_gap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_length</span> <span class="o">/</span> <span class="n">mean_data_separation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">buffer_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">buffer_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">est_samples_in_gap</span><span class="p">)</span>

        <span class="n">added_gtis</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">total_filled_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bti</span> <span class="ow">in</span> <span class="n">btis</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">bti</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bti</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filling bad time interval </span><span class="si">{</span><span class="n">bti</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">length</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> s)&quot;</span><span class="p">)</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-5</span> <span class="o">*</span> <span class="n">length</span>
            <span class="n">added_gtis</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bti</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">bti</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">])</span>
            <span class="n">filt_low_t</span><span class="p">,</span> <span class="n">filt_low_idx</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">filtered_times</span><span class="p">,</span> <span class="n">bti</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">filt_hig_t</span><span class="p">,</span> <span class="n">filt_hig_idx</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">filtered_times</span><span class="p">,</span> <span class="n">bti</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">even_sampling</span><span class="p">:</span>
                <span class="n">local_new_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bti</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">bti</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
                <span class="n">nevents</span> <span class="o">=</span> <span class="n">local_new_times</span><span class="o">.</span><span class="n">size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">low_time_arr</span> <span class="o">=</span> <span class="n">filtered_times</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">filt_low_idx</span> <span class="o">-</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="n">filt_low_idx</span><span class="p">]</span>
                <span class="n">low_time_arr</span> <span class="o">=</span> <span class="n">low_time_arr</span><span class="p">[</span><span class="n">low_time_arr</span> <span class="o">&gt;</span> <span class="n">bti</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">buffer_size</span><span class="p">]</span>
                <span class="n">high_time_arr</span> <span class="o">=</span> <span class="n">filtered_times</span><span class="p">[</span><span class="n">filt_hig_idx</span> <span class="p">:</span> <span class="n">buffer_size</span> <span class="o">+</span> <span class="n">filt_hig_idx</span><span class="p">]</span>
                <span class="n">high_time_arr</span> <span class="o">=</span> <span class="n">high_time_arr</span><span class="p">[</span><span class="n">high_time_arr</span> <span class="o">&lt;</span> <span class="n">bti</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">buffer_size</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">low_time_arr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">filt_low_t</span> <span class="o">-</span> <span class="n">low_time_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ctrate_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">low_time_arr</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">filt_low_t</span> <span class="o">-</span> <span class="n">low_time_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ctrate_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">high_time_arr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">high_time_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">filt_hig_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ctrate_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">high_time_arr</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">high_time_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">filt_hig_t</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ctrate_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ctrate_low</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ctrate_high</span><span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No valid data around to simulate the time series in interval &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bti</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">bti</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">. Skipping. Please check that the buffer size is &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;adequate.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">ctrate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">([</span><span class="n">ctrate_low</span><span class="p">,</span> <span class="n">ctrate_high</span><span class="p">])</span>
                <span class="n">nevents</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">ctrate</span> <span class="o">*</span> <span class="p">(</span><span class="n">bti</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bti</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">local_new_times</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">bti</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bti</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nevents</span><span class="p">)</span>
            <span class="n">new_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_new_times</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs_to_randomize</span><span class="p">:</span>
                <span class="n">low_arr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)[</span><span class="nb">max</span><span class="p">(</span><span class="n">buffer_size</span> <span class="o">-</span> <span class="n">filt_low_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="n">filt_low_idx</span><span class="p">]</span>
                <span class="n">high_arr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)[</span><span class="n">filt_hig_idx</span> <span class="p">:</span> <span class="n">buffer_size</span> <span class="o">+</span> <span class="n">filt_hig_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_attrs</span><span class="p">:</span>
                    <span class="n">new_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]]</span>
                <span class="n">new_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">low_arr</span><span class="p">,</span> <span class="n">high_arr</span><span class="p">]),</span> <span class="n">nevents</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs_to_leave_alone</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_attrs</span><span class="p">:</span>
                    <span class="n">new_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_mask&quot;</span><span class="p">:</span>
                    <span class="n">new_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nevents</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nevents</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">total_filled_time</span> <span class="o">+=</span> <span class="n">length</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A total of </span><span class="si">{</span><span class="n">total_filled_time</span><span class="si">}</span><span class="s2"> s of data were simulated&quot;</span><span class="p">)</span>

        <span class="n">new_gtis</span> <span class="o">=</span> <span class="n">join_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">added_gtis</span><span class="p">)</span>
        <span class="n">new_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">new_times</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_attrs</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">new_attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">)[</span><span class="n">order</span><span class="p">])</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">gti</span> <span class="o">=</span> <span class="n">new_gtis</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>


<div class="viewcode-block" id="StingrayTimeseries.plot">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attr</span><span class="p">,</span>
        <span class="n">witherrors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_btis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">axis_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the time series using ``matplotlib``.</span>

<span class="sd">        Plot the time series object on a graph ``self.time`` on x-axis and</span>
<span class="sd">        ``self.counts`` on y-axis with ``self.counts_err`` optionally</span>
<span class="sd">        as error bars.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attr: str</span>
<span class="sd">            Attribute to plot.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        witherrors: boolean, default False</span>
<span class="sd">            Whether to plot the StingrayTimeseries with errorbars or not</span>
<span class="sd">        labels : iterable, default ``None``</span>
<span class="sd">            A list or tuple with ``xlabel`` and ``ylabel`` as strings. E.g.</span>
<span class="sd">            if the attribute is ``&#39;counts&#39;``, the list of labels</span>
<span class="sd">            could be ``[&#39;Time (s)&#39;, &#39;Counts (s^-1)&#39;]``</span>
<span class="sd">        ax : ``matplotlib.pyplot.axis`` object</span>
<span class="sd">            Axis to be used for plotting. Defaults to creating a new one.</span>
<span class="sd">        axis_limits : list, tuple, string, default ``None``</span>
<span class="sd">            Parameter to set axis properties of the ``matplotlib`` figure. For example</span>
<span class="sd">            it can be a list like ``[xmin, xmax, ymin, ymax]`` or any other</span>
<span class="sd">            acceptable argument for the``matplotlib.pyplot.axis()`` method.</span>
<span class="sd">        title : str, default ``None``</span>
<span class="sd">            The title of the plot.</span>
<span class="sd">        marker : str, default &#39;-&#39;</span>
<span class="sd">            Line style and color of the plot. Line styles and colors are</span>
<span class="sd">            combined in a single format string, as in ``&#39;bo&#39;`` for blue</span>
<span class="sd">            circles. See ``matplotlib.pyplot.plot`` for more options.</span>
<span class="sd">        save : boolean, optional, default ``False``</span>
<span class="sd">            If ``True``, save the figure with specified filename.</span>
<span class="sd">        filename : str</span>
<span class="sd">            File name of the image to save. Depends on the boolean ``save``.</span>
<span class="sd">        plot_btis : bool</span>
<span class="sd">            Plot the bad time intervals as red areas on the plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="n">valid_labels</span> <span class="o">=</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">labels</span>
        <span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">valid_labels</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;``labels`` must be an iterable with two labels for x and y axes.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">valid_labels</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">attr</span><span class="p">]</span>

        <span class="n">xlabel</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ylabel</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Default values for labels</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="n">marker</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="s2">&quot;steps-mid&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">witherrors</span> <span class="ow">and</span> <span class="n">attr</span> <span class="o">+</span> <span class="s2">&quot;_err&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">():</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span>
                <span class="n">yerr</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span> <span class="o">+</span> <span class="s2">&quot;_err&quot;</span><span class="p">),</span>
                <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
                <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis_limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">axis_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">axis_limits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis_limits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;out.png&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_btis</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">tend</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">btis</span> <span class="o">=</span> <span class="n">get_btis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bti</span> <span class="ow">in</span> <span class="n">btis</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span>
                    <span class="n">bti</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">bti</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                    <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
                    <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="StingrayTimeseries.estimate_segment_size">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.estimate_segment_size">[docs]</a>
    <span class="k">def</span> <span class="nf">estimate_segment_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">even_sampling</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate a reasonable segment length for segment-by-segment analysis.</span>

<span class="sd">        The user has to specify a criterion based on a minimum number of counts (if</span>
<span class="sd">        the time series has a ``counts`` attribute) or a minimum number of time samples.</span>
<span class="sd">        At least one between ``min_counts`` and ``min_samples`` must be specified.</span>
<span class="sd">        In the special case of a time series with ``dt=0`` (event list-like, where each time</span>
<span class="sd">        stamp correspond to a single count), the two definitions are equivalent.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        min_counts : int</span>
<span class="sd">            Minimum number of counts for each chunk. Optional (but needs ``min_samples``</span>
<span class="sd">            if left unspecified). Only makes sense if the series has a ``counts`` attribute and</span>
<span class="sd">            it is evenly sampled.</span>
<span class="sd">        min_samples : int</span>
<span class="sd">            Minimum number of time bins. Optional (but needs ``min_counts`` if left unspecified).</span>
<span class="sd">        even_sampling : bool</span>
<span class="sd">            Force the treatment of the data as evenly sampled or not. If None, the data are</span>
<span class="sd">            considered evenly sampled if ``self.dt`` is larger than zero and the median</span>
<span class="sd">            separation between subsequent times is within 1% of ``self.dt``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        segment_size : float</span>
<span class="sd">            The length of the light curve chunks that satisfies the conditions</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; time = np.arange(150)</span>
<span class="sd">        &gt;&gt;&gt; counts = np.zeros_like(time) + 3</span>
<span class="sd">        &gt;&gt;&gt; ts = StingrayTimeseries(time, counts=counts, dt=1)</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(ts.estimate_segment_size(min_counts=10, min_samples=3), 4.0)</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(ts.estimate_segment_size(min_counts=10, min_samples=5), 5.0)</span>
<span class="sd">        &gt;&gt;&gt; counts[2:4] = 1</span>
<span class="sd">        &gt;&gt;&gt; ts = StingrayTimeseries(time, counts=counts, dt=1)</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(ts.estimate_segment_size(min_counts=3, min_samples=1), 3.0)</span>
<span class="sd">        &gt;&gt;&gt; # A slightly more complex example</span>
<span class="sd">        &gt;&gt;&gt; dt=0.2</span>
<span class="sd">        &gt;&gt;&gt; time = np.arange(0, 1000, dt)</span>
<span class="sd">        &gt;&gt;&gt; counts = np.random.poisson(100, size=len(time))</span>
<span class="sd">        &gt;&gt;&gt; ts = StingrayTimeseries(time, counts=counts, dt=dt)</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(ts.estimate_segment_size(100, 2), 0.4)</span>
<span class="sd">        &gt;&gt;&gt; min_total_bins = 40</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(ts.estimate_segment_size(100, 40), 8.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">min_counts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify at least one of min_counts or min_samples&quot;</span><span class="p">)</span>

        <span class="n">mean_data_separation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">even_sampling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The time series is considered evenly sampled if the median separation between</span>
            <span class="c1"># subsequent times is within 1% of the time resolution</span>
            <span class="n">even_sampling</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">mean_data_separation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">even_sampling</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data are </span><span class="si">{</span><span class="s1">&#39;not&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">even_sampling</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2"> evenly sampled&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_counts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">even_sampling</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;counts&quot;</span><span class="p">):</span>
                <span class="n">min_counts</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_counts</span> <span class="o">=</span> <span class="n">min_samples</span>

        <span class="n">mean_ctrate</span> <span class="o">=</span> <span class="n">_ts_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span>

        <span class="n">rough_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_counts</span> <span class="o">/</span> <span class="n">mean_ctrate</span><span class="p">)</span>

        <span class="c1"># If data are evenly sampled, even sampling make the segment an integer multiple of dt.</span>
        <span class="c1"># Otherwise, just use steps of 1 second.</span>
        <span class="k">if</span> <span class="n">even_sampling</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">rough_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_counts</span> <span class="o">/</span> <span class="n">mean_ctrate</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>

        <span class="n">segment_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">rough_estimate</span><span class="p">,</span> <span class="n">min_samples</span> <span class="o">*</span> <span class="n">step</span><span class="p">])</span>

        <span class="n">keep_searching</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">while</span> <span class="n">keep_searching</span><span class="p">:</span>
            <span class="n">start_times</span><span class="p">,</span> <span class="n">stop_times</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyze_segments</span><span class="p">(</span><span class="n">_ts_sum</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">)</span>
            <span class="n">mincounts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mincounts</span> <span class="o">&gt;=</span> <span class="n">min_counts</span><span class="p">:</span>
                <span class="n">keep_searching</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">segment_size</span> <span class="o">+=</span> <span class="n">step</span>

        <span class="k">return</span> <span class="n">segment_size</span></div>


<div class="viewcode-block" id="StingrayTimeseries.analyze_segments">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.analyze_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">analyze_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Analyze segments of the light curve with any function.</span>

<span class="sd">        Intervals with less than one data point are skipped.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function accepting a :class:`StingrayTimeseries` object as single argument, plus</span>
<span class="sd">            possible additional keyword arguments, and returning a number or a</span>
<span class="sd">            tuple - e.g., ``(result, error)`` where both ``result`` and ``error`` are</span>
<span class="sd">            numbers.</span>
<span class="sd">        segment_size : float</span>
<span class="sd">            Length in seconds of the light curve segments. If None, the full GTIs are considered</span>
<span class="sd">            instead as segments.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        fraction_step : float</span>
<span class="sd">            If the step is not a full ``segment_size`` but less (e.g. a moving window),</span>
<span class="sd">            this indicates the ratio between step step and ``segment_size`` (e.g.</span>
<span class="sd">            0.5 means that the window shifts of half ``segment_size``)</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            These additional keyword arguments, if present, they will be passed</span>
<span class="sd">            to ``func``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        start_times : array</span>
<span class="sd">            Lower time boundaries of all time segments.</span>
<span class="sd">        stop_times : array</span>
<span class="sd">            upper time boundaries of all segments.</span>
<span class="sd">        result : list of N elements</span>
<span class="sd">            The result of ``func`` for each segment of the light curve. If the function</span>
<span class="sd">            returns multiple outputs, they are returned as a list of arrays.</span>
<span class="sd">            If a given interval has not enough data for a calculation, ``None`` is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; time = np.arange(0, 10, 0.1)</span>
<span class="sd">        &gt;&gt;&gt; counts = np.zeros_like(time) + 10</span>
<span class="sd">        &gt;&gt;&gt; ts = StingrayTimeseries(time, counts=counts, dt=0.1)</span>
<span class="sd">        &gt;&gt;&gt; # Define a function that calculates the mean</span>
<span class="sd">        &gt;&gt;&gt; mean_func = lambda ts: np.mean(ts.counts)</span>
<span class="sd">        &gt;&gt;&gt; # Calculate the mean in segments of 5 seconds</span>
<span class="sd">        &gt;&gt;&gt; start, stop, res = ts.analyze_segments(mean_func, 5)</span>
<span class="sd">        &gt;&gt;&gt; len(res) == 2</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(res, 10)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">segment_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">stop_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">start_times</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">stop_times</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">bin_intervals_from_gtis</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="n">fraction_step</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
            <span class="p">)</span>
            <span class="n">start_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
            <span class="c1"># Remember that stop is one element above the last element, because</span>
            <span class="c1"># it&#39;s defined to be used in intervals start:stop</span>
            <span class="n">stop_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">*</span> <span class="mf">1.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_times</span><span class="p">,</span> <span class="n">stop_times</span> <span class="o">=</span> <span class="n">time_intervals_from_gtis</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="n">fraction_step</span>
            <span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">start_times</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">stop_times</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">n_outs</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">tst</span><span class="p">,</span> <span class="n">tsp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">start_times</span><span class="p">,</span> <span class="n">stop_times</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">sp</span> <span class="o">-</span> <span class="n">st</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Segment </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">tst</span><span class="si">}</span><span class="s2">--</span><span class="si">{</span><span class="n">tsp</span><span class="si">}</span><span class="s2">) has one data point or less. Skipping it &quot;</span>
                <span class="p">)</span>

                <span class="k">continue</span>
            <span class="n">lc_filt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">st</span><span class="p">:</span><span class="n">sp</span><span class="p">]</span>
            <span class="n">lc_filt</span><span class="o">.</span><span class="n">gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">([[</span><span class="n">tst</span><span class="p">,</span> <span class="n">tsp</span><span class="p">]])</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">lc_filt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">n_outs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="c1"># If the function returns multiple outputs, we need to separate them</span>

        <span class="k">if</span> <span class="n">n_outs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_outs</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_outs</span><span class="p">):</span>
                    <span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">outs</span>

        <span class="c1"># Try to transform into a (possibly multi-dimensional) numpy array</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">start_times</span><span class="p">,</span> <span class="n">stop_times</span><span class="p">,</span> <span class="n">results</span></div>


<div class="viewcode-block" id="StingrayTimeseries.analyze_by_gti">
<a class="viewcode-back" href="../../api.html#stingray.StingrayTimeseries.analyze_by_gti">[docs]</a>
    <span class="k">def</span> <span class="nf">analyze_by_gti</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Analyze the light curve with any function, on a GTI-by-GTI base.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function accepting a :class:`StingrayTimeseries` object as single argument, plus</span>
<span class="sd">            possible additional keyword arguments, and returning a number or a</span>
<span class="sd">            tuple - e.g., ``(result, error)`` where both ``result`` and ``error`` are</span>
<span class="sd">            numbers.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        fraction_step : float</span>
<span class="sd">            By default, segments do not overlap (``fraction_step`` = 1). If ``fraction_step`` &lt; 1,</span>
<span class="sd">            then the start points of consecutive segments are ``fraction_step * segment_size``</span>
<span class="sd">            apart, and consecutive segments overlap. For example, for ``fraction_step`` = 0.5,</span>
<span class="sd">            the window shifts one half of ``segment_size``)</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            These additional keyword arguments, if present, they will be passed</span>
<span class="sd">            to ``func``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        start_times : array</span>
<span class="sd">            Lower time boundaries of all time segments.</span>
<span class="sd">        stop_times : array</span>
<span class="sd">            upper time boundaries of all segments.</span>
<span class="sd">        result : array of N elements</span>
<span class="sd">            The result of ``func`` for each segment of the light curve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyze_segments</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">segment_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="n">fraction_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<span class="k">def</span> <span class="nf">interpret_times</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="n">TTime</span><span class="p">,</span> <span class="n">mjdref</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Understand the format of input times, and return seconds from MJDREF</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : class:`astropy.Time`, class:`time.Time`, class:`astropy.TimeDelta`, class:`astropy.Quantity`, class:`np.array`</span>
<span class="sd">        Input times.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    mjdref : float</span>
<span class="sd">        Input MJD reference of the times. Optional.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    time_s : class:`np.array`</span>
<span class="sd">        Times, in seconds from MJDREF</span>
<span class="sd">    mjdref : float</span>
<span class="sd">        MJDREF. If the input time is a `time.Time` object and the input mjdref</span>
<span class="sd">        is 0, it will be defined as the MJD of the input time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">    &gt;&gt;&gt; newt, mjdref = interpret_times(None)</span>
<span class="sd">    &gt;&gt;&gt; assert newt is None</span>
<span class="sd">    &gt;&gt;&gt; time = Time(57483, format=&#39;mjd&#39;)</span>
<span class="sd">    &gt;&gt;&gt; newt, mjdref = interpret_times(time)</span>
<span class="sd">    &gt;&gt;&gt; assert newt == 0</span>
<span class="sd">    &gt;&gt;&gt; assert mjdref == 57483</span>
<span class="sd">    &gt;&gt;&gt; time = Time([57483], format=&#39;mjd&#39;)</span>
<span class="sd">    &gt;&gt;&gt; newt, mjdref = interpret_times(time)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(newt, 0)</span>
<span class="sd">    &gt;&gt;&gt; assert mjdref == 57483</span>
<span class="sd">    &gt;&gt;&gt; time = TimeDelta([3, 4, 5] * u.s)</span>
<span class="sd">    &gt;&gt;&gt; newt, mjdref = interpret_times(time)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(newt, [3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; time = np.array([3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; newt, mjdref = interpret_times(time, mjdref=45000)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(newt, [3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; assert mjdref == 45000</span>
<span class="sd">    &gt;&gt;&gt; time = np.array([3, 4, 5] * u.s)</span>
<span class="sd">    &gt;&gt;&gt; newt, mjdref = interpret_times(time, mjdref=45000)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(newt, [3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; assert mjdref == 45000</span>
<span class="sd">    &gt;&gt;&gt; newt, mjdref = interpret_times(1, mjdref=45000)</span>
<span class="sd">    &gt;&gt;&gt; assert newt == 1</span>
<span class="sd">    &gt;&gt;&gt; newt, mjdref = interpret_times(list, mjdref=45000)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Unknown time format: ...</span>
<span class="sd">    &gt;&gt;&gt; newt, mjdref = interpret_times(&quot;guadfkljfd&quot;, mjdref=45000)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Unknown time format: ...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mjdref</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">TimeDelta</span><span class="p">):</span>
        <span class="n">out_times</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">out_times</span><span class="p">,</span> <span class="n">mjdref</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">mjds</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">mjd</span>
        <span class="k">if</span> <span class="n">mjdref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mjds</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mjds</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                    <span class="n">mjdref</span> <span class="o">=</span> <span class="n">mjds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mjdref</span> <span class="o">=</span> <span class="n">mjds</span>

        <span class="n">out_times</span> <span class="o">=</span> <span class="p">(</span><span class="n">mjds</span> <span class="o">-</span> <span class="n">mjdref</span><span class="p">)</span> <span class="o">*</span> <span class="mi">86400</span>
        <span class="k">return</span> <span class="n">out_times</span><span class="p">,</span> <span class="n">mjdref</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
        <span class="n">out_times</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">out_times</span><span class="p">,</span> <span class="n">mjdref</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">mjdref</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">mjdref</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">pass</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown time format: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">reduce_precision_if_extended</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">probe_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;float128&quot;</span><span class="p">,</span> <span class="s2">&quot;float96&quot;</span><span class="p">,</span> <span class="s2">&quot;float80&quot;</span><span class="p">,</span> <span class="s2">&quot;longdouble&quot;</span><span class="p">],</span> <span class="n">destination</span><span class="o">=</span><span class="nb">float</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reduce a number to a standard float if extended precision.</span>

<span class="sd">    Ignore all non-float types.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        The number to be reduced</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_red : same type of input</span>
<span class="sd">        The input, only reduce to ``float`` precision if ``np.float128``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = 1.0</span>
<span class="sd">    &gt;&gt;&gt; val = reduce_precision_if_extended(x, probe_types=[&quot;float64&quot;])</span>
<span class="sd">    &gt;&gt;&gt; assert val is x</span>
<span class="sd">    &gt;&gt;&gt; x = &quot;1wrt&quot;</span>
<span class="sd">    &gt;&gt;&gt; assert reduce_precision_if_extended(x, probe_types=[&quot;float64&quot;]) is x</span>
<span class="sd">    &gt;&gt;&gt; x = np.asanyarray(1.0).astype(int)</span>
<span class="sd">    &gt;&gt;&gt; val = reduce_precision_if_extended(x, probe_types=[&quot;float64&quot;])</span>
<span class="sd">    &gt;&gt;&gt; assert val is x</span>
<span class="sd">    &gt;&gt;&gt; x = np.asanyarray([1.0, 2]).astype(int)</span>
<span class="sd">    &gt;&gt;&gt; val = reduce_precision_if_extended(x, probe_types=[&quot;float64&quot;])</span>
<span class="sd">    &gt;&gt;&gt; assert val is x</span>
<span class="sd">    &gt;&gt;&gt; x = np.asanyarray([1.0]).astype(int)</span>
<span class="sd">    &gt;&gt;&gt; val = reduce_precision_if_extended(x, probe_types=[&quot;float64&quot;])</span>
<span class="sd">    &gt;&gt;&gt; assert val is x</span>
<span class="sd">    &gt;&gt;&gt; x = np.asanyarray(1.0).astype(np.float64)</span>
<span class="sd">    &gt;&gt;&gt; reduce_precision_if_extended(x, probe_types=[&quot;float64&quot;], destination=np.float32) is x</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; x = np.asanyarray([1.0]).astype(np.float64)</span>
<span class="sd">    &gt;&gt;&gt; reduce_precision_if_extended(x, probe_types=[&quot;float64&quot;], destination=np.float32) is x</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">obj2sctype</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert an object to a numpy scalar type.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;obj2sctype&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;str&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj2sctype</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="s2">&quot;numpy&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">return</span> <span class="s2">&quot;None&quot;</span>

        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
        <span class="c1"># return np.dtype(x).type</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj2sctype</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">probe_types</span><span class="p">]):</span>
        <span class="n">x_ret</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_ret</span>
    <span class="k">return</span> <span class="n">x</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, [{&#39;name&#39;: &#39;Stingray Developers&#39;, &#39;email&#39;: &#39;spectraltiming-stingray@googlegroups.com&#39;}].<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 8.0.2. &nbsp;
    Last built 09 Oct 2024. <br/>
  </p>
</footer>
  </body>
</html>