<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>stingray.modeling.parameterestimation &#8212; stingray v</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bootstrap-astropy.css?v=9d21690f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=2afd17ea" />
    
    <script src="../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../_static/stingray_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">stingray v</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for stingray.modeling.parameterestimation</h1><div class="highlight"><pre>
<span></span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;OptimizationResults&quot;</span><span class="p">,</span> <span class="s2">&quot;ParameterEstimation&quot;</span><span class="p">,</span> <span class="s2">&quot;PSDParEst&quot;</span><span class="p">,</span> <span class="s2">&quot;SamplingResults&quot;</span><span class="p">]</span>


<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">MaxNLocator</span>


<span class="c1"># check whether emcee is installed for sampling</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">emcee</span>

    <span class="n">can_sample</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">can_sample</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">corner</span>

    <span class="n">use_corner</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">use_corner</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="kn">import</span> <span class="n">approx_hess</span>

    <span class="n">comp_hessian</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">comp_hessian</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">from</span> <span class="nn">stingray.modeling.posterior</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Posterior</span><span class="p">,</span>
    <span class="n">PSDPosterior</span><span class="p">,</span>
    <span class="n">LogLikelihood</span><span class="p">,</span>
    <span class="n">PSDLogLikelihood</span><span class="p">,</span>
    <span class="n">logmin</span><span class="p">,</span>
    <span class="n">fitter_to_model_params</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">stingray.loggingconfig</span> <span class="kn">import</span> <span class="n">CustomFormatter</span><span class="p">,</span> <span class="n">setup_logger</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">()</span>


<div class="viewcode-block" id="OptimizationResults">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.OptimizationResults">[docs]</a>
<span class="k">class</span> <span class="nc">OptimizationResults</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper class that will contain the results of the regression.</span>
<span class="sd">    Less fiddly than a dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lpost: instance of :class:`Posterior` or one of its subclasses</span>
<span class="sd">        The object containing the function that is being optimized</span>
<span class="sd">        in the regression</span>

<span class="sd">    res: instance of ``scipy.OptimizeResult``</span>
<span class="sd">        The object containing the results from a optimization run</span>

<span class="sd">    neg : bool, optional, default ``True``</span>
<span class="sd">        A flag that sets whether the log-likelihood or negative log-likelihood</span>
<span class="sd">        is being used</span>

<span class="sd">    log : a logging.getLogger() object, default None</span>
<span class="sd">        You can pass a pre-defined object for logging, else a new</span>
<span class="sd">        logger will be instantiated</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    result : float</span>
<span class="sd">        The result of the optimization, i.e. the function value at the</span>
<span class="sd">        minimum that the optimizer found</span>

<span class="sd">    p_opt : iterable</span>
<span class="sd">        The list of parameters at the minimum found by the optimizer</span>

<span class="sd">    model : ``astropy.models.Model`` instance</span>
<span class="sd">        The parametric model fit to the data</span>

<span class="sd">    cov : numpy.ndarray</span>
<span class="sd">        The covariance matrix for the parameters, has shape ``(len(p_opt), len(p_opt))``</span>

<span class="sd">    err : numpy.ndarray</span>
<span class="sd">        The standard deviation of the parameters, derived from the diagonal of ``cov``.</span>
<span class="sd">        Has the same shape as ``p_opt``</span>

<span class="sd">    mfit : numpy.ndarray</span>
<span class="sd">        The values of the model for all ``x``</span>

<span class="sd">    deviance : float</span>
<span class="sd">        The deviance, calculated as ``-2*log(likelihood)``</span>

<span class="sd">    aic : float</span>
<span class="sd">        The Akaike Information Criterion, derived from the log(likelihood) and often used</span>
<span class="sd">        in model comparison between non-nested models;</span>
<span class="sd">        For more details, see [#]_</span>

<span class="sd">    bic : float</span>
<span class="sd">        The Bayesian Information Criterion, derived from the log(likelihood) and often used</span>
<span class="sd">        in model comparison between non-nested models;</span>
<span class="sd">        For more details, see [#]_</span>

<span class="sd">    merit : float</span>
<span class="sd">        sum of squared differences between data and model, normalized by the</span>
<span class="sd">        model values</span>

<span class="sd">    dof : int</span>
<span class="sd">        The number of degrees of freedom in the problem, defined as the number of</span>
<span class="sd">        data points - the number of parameters</span>

<span class="sd">    sexp : int</span>
<span class="sd">        ``2*(number of parameters)*(number of data points)``</span>

<span class="sd">    ssd : float</span>
<span class="sd">        ``sqrt(2*(sexp))``, expected sum of data-model residuals</span>

<span class="sd">    sobs : float</span>
<span class="sd">        sum of data-model residuals</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [#] https://doi.org/10.1109/TAC.1974.1100705</span>
<span class="sd">    .. [#] https://projecteuclid.org/euclid.aos/1176344136</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neg</span> <span class="o">=</span> <span class="n">neg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">fun</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span>

        <span class="k">if</span> <span class="n">log</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;Fitting summary&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
                <span class="n">formatter</span> <span class="o">=</span> <span class="n">CustomFormatter</span><span class="p">()</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_covariance</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_model</span><span class="p">(</span><span class="n">lpost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_criteria</span><span class="p">(</span><span class="n">lpost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_statistics</span><span class="p">(</span><span class="n">lpost</span><span class="p">)</span>

<div class="viewcode-block" id="OptimizationResults._compute_covariance">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.OptimizationResults._compute_covariance">[docs]</a>
    <span class="k">def</span> <span class="nf">_compute_covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the covariance of the parameters using inverse of the Hessian, i.e.</span>
<span class="sd">        the second-order derivative of the log-likelihood. Also calculates an estimate</span>
<span class="sd">        of the standard deviation in the parameters, using the square root of the diagonal</span>
<span class="sd">        of the covariance matrix.</span>

<span class="sd">        The Hessian is either estimated directly by the chosen method of fitting, or</span>
<span class="sd">        approximated using the ``statsmodel`` ``approx_hess`` function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost: instance of :class:`Posterior` or one of its subclasses</span>
<span class="sd">            The object containing the function that is being optimized</span>
<span class="sd">            in the regression</span>

<span class="sd">        res: instance of ``scipy``&#39;s ``OptimizeResult`` class</span>
<span class="sd">            The object containing the results from a optimization run</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s2">&quot;hess_inv&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">hess_inv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">hess_inv</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">hess_inv</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">comp_hessian</span><span class="p">:</span>
                <span class="c1"># calculate Hessian approximating with finite differences</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Approximating Hessian with finite differences ...&quot;</span><span class="p">)</span>

                <span class="n">phess</span> <span class="o">=</span> <span class="n">approx_hess</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_opt</span><span class="p">),</span> <span class="n">lpost</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">phess</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">)))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="OptimizationResults._compute_model">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.OptimizationResults._compute_model">[docs]</a>
    <span class="k">def</span> <span class="nf">_compute_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the values of the best-fit model for all ``x``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost: instance of :class:`Posterior` or one of its subclasses</span>
<span class="sd">            The object containing the function that is being optimized</span>
<span class="sd">            in the regression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_opt</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mfit</span> <span class="o">=</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="OptimizationResults._compute_criteria">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.OptimizationResults._compute_criteria">[docs]</a>
    <span class="k">def</span> <span class="nf">_compute_criteria</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute various information criteria useful for model comparison in</span>
<span class="sd">        non-nested models.</span>

<span class="sd">        Currently implemented are the Akaike Information Criterion [#]_ and the</span>
<span class="sd">        Bayesian Information Criterion [#]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost: instance of :class:`Posterior` or one of its subclasses</span>
<span class="sd">            The object containing the function that is being optimized</span>
<span class="sd">            in the regression</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [#] https://doi.org/10.1109/TAC.1974.1100705</span>
<span class="sd">        .. [#] https://projecteuclid.org/euclid.aos/1176344136</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">Posterior</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deviance</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">lpost</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_opt</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">LogLikelihood</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deviance</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span>

        <span class="c1"># Akaike Information Criterion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_opt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Bayesian Information Criterion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_opt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


        <span class="c1"># Deviance Information Criterion</span>
        <span class="c1"># TODO: Add Deviance Information Criterion</span>

<div class="viewcode-block" id="OptimizationResults._compute_statistics">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.OptimizationResults._compute_statistics">[docs]</a>
    <span class="k">def</span> <span class="nf">_compute_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute some useful fit statistics, like the degrees of freedom and the</span>
<span class="sd">        figure of merit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost: instance of :class:`Posterior` or one of its subclasses</span>
<span class="sd">            The object containing the function that is being optimized</span>
<span class="sd">            in the regression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mfit</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_model</span><span class="p">(</span><span class="n">lpost</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">merit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">lpost</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mfit</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mfit</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="n">lpost</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_opt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sexp</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_opt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sexp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sobs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mfit</span><span class="p">)</span></div>


<div class="viewcode-block" id="OptimizationResults.print_summary">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.OptimizationResults.print_summary">[docs]</a>
    <span class="k">def</span> <span class="nf">print_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a useful summary of the fitting procedure to screen or</span>
<span class="sd">        a log file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost : instance of :class:`Posterior` or one of its subclasses</span>
<span class="sd">            The object containing the function that is being optimized</span>
<span class="sd">            in the regression</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The best-fit model parameters plus errors are:&quot;</span><span class="p">)</span>

        <span class="n">fixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fixed</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="n">tied</span> <span class="o">=</span> <span class="p">[</span><span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>

        <span class="n">parnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">tied</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="p">]</span>

        <span class="n">all_parnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_parnames</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:3}</span><span class="s2">) Parameter </span><span class="si">{:&lt;20}</span><span class="s2">: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">par</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">parnames</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">parnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>

                <span class="n">err_info</span> <span class="o">=</span> <span class="s2">&quot; (no error estimate)&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">err_info</span> <span class="o">=</span> <span class="s2">&quot; +/- </span><span class="si">{:&lt;20.5f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:&lt;20.5f}{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_opt</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">err_info</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">{:&gt;10}</span><span class="s2"> </span><span class="si">{:&gt;10}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">elif</span> <span class="n">fixed</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:&lt;20.5f}</span><span class="s2"> (Fixed) &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">tied</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:&lt;20.5f}</span><span class="s2"> (Tied) &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fitting statistics: &quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot; -- number of data points: </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deviance</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_criteria</span><span class="p">(</span><span class="n">lpost</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot; -- Deviance [-2 log L] D = </span><span class="si">%f</span><span class="s2">.3&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">deviance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot; -- The Akaike Information Criterion of the model is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aic</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot; -- The Bayesian Information Criterion of the model is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bic</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">merit</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_statistics</span><span class="p">(</span><span class="n">lpost</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot; -- The figure-of-merit function for this model &quot;</span>
            <span class="o">+</span> <span class="s2">&quot; is: </span><span class="si">%f</span><span class="s2">.5f&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">merit</span>
            <span class="o">+</span> <span class="s2">&quot; and the fit for </span><span class="si">%i</span><span class="s2"> dof is </span><span class="si">%f</span><span class="s2">.3f&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">merit</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot; -- Summed Residuals S = </span><span class="si">%f</span><span class="s2">.5f&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sobs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot; -- Expected S ~ </span><span class="si">%f</span><span class="s2">.5 +/- </span><span class="si">%f</span><span class="s2">.5&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sexp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssd</span><span class="p">))</span>

        <span class="k">return</span></div>
</div>



<div class="viewcode-block" id="ParameterEstimation">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.ParameterEstimation">[docs]</a>
<span class="k">class</span> <span class="nc">ParameterEstimation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameter estimation of two-dimensional data, either via</span>
<span class="sd">    optimization or MCMC.</span>
<span class="sd">    Note: optimization with bounds is not supported. If something like</span>
<span class="sd">    this is required, define (uniform) priors in the ParametricModel</span>
<span class="sd">    instances to be used below.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fitmethod : string, optional, default ``L-BFGS-B``</span>
<span class="sd">        Any of the strings allowed in ``scipy.optimize.minimize`` in</span>
<span class="sd">        the method keyword. Sets the fit method to be used.</span>

<span class="sd">    max_post : bool, optional, default ``True``</span>
<span class="sd">        If ``True``, then compute the Maximum-A-Posteriori estimate. If ``False``,</span>
<span class="sd">        compute a Maximum Likelihood estimate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="s2">&quot;BFGS&quot;</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span> <span class="o">=</span> <span class="n">fitmethod</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_post</span> <span class="o">=</span> <span class="n">max_post</span>

<div class="viewcode-block" id="ParameterEstimation.fit">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.ParameterEstimation.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scipy_optimize_options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do either a Maximum-A-Posteriori (MAP) or Maximum Likelihood (ML)</span>
<span class="sd">        fit to the data.</span>

<span class="sd">        MAP fits include priors, ML fits do not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost : :class:`Posterior` (or subclass) instance</span>
<span class="sd">            and instance of class :class:`Posterior` or one of its subclasses</span>
<span class="sd">            that defines the function to be minimized (either in ``loglikelihood``</span>
<span class="sd">            or ``logposterior``)</span>

<span class="sd">        t0 : {``list`` | ``numpy.ndarray``}</span>
<span class="sd">            List/array with set of initial parameters</span>

<span class="sd">        neg : bool, optional, default ``True``</span>
<span class="sd">            Boolean to be passed to ``lpost``, setting whether to use the</span>
<span class="sd">            *negative* posterior or the *negative* log-likelihood. Useful for</span>
<span class="sd">            optimization routines, which are generally defined as *minimization* routines.</span>

<span class="sd">        scipy_optimize_options : dict, optional, default ``None``</span>
<span class="sd">            A dictionary with options for ``scipy.optimize.minimize``,</span>
<span class="sd">            directly passed on as keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res : :class:`OptimizationResults` object</span>
<span class="sd">            An object containing useful summaries of the fitting procedure.</span>
<span class="sd">            For details, see documentation of class:`OptimizationResults`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">Posterior</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">LogLikelihood</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;lpost must be a subclass of &quot;</span> <span class="s2">&quot;Posterior or LogLikelihoood.&quot;</span><span class="p">)</span>

        <span class="n">newmod</span> <span class="o">=</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">p0</span> <span class="o">=</span> <span class="n">t0</span>

        <span class="c1"># p0 will be shorter than t0, if there are any frozen/tied parameters</span>
        <span class="c1"># this has to match with the npar attribute.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">==</span> <span class="n">lpost</span><span class="o">.</span><span class="n">npar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter set t0 must be of right &quot;</span> <span class="s2">&quot;length for model in lpost.&quot;</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">neg</span><span class="p">,)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">scipy_optimize_options</span><span class="p">:</span>
            <span class="n">scipy_optimize_options</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># different commands for different fitting methods,</span>
        <span class="c1"># at least until scipy 0.11 is out</span>
        <span class="n">funcval</span> <span class="o">=</span> <span class="mf">100.0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">funcval</span> <span class="o">==</span> <span class="mi">100</span> <span class="ow">or</span> <span class="n">funcval</span> <span class="o">==</span> <span class="mi">200</span> <span class="ow">or</span> <span class="n">funcval</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">funcval</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Fitting unsuccessful!&quot;</span><span class="p">)</span>
            <span class="c1"># perturb parameters slightly</span>
            <span class="n">t0_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">))</span>

            <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">newmod</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">newmod</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">bounds</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">tied</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">fixed</span><span class="p">])])</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">elem</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">bounds</span><span class="p">))</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span>
                <span class="s2">&quot;TNC&quot;</span><span class="p">,</span>
                <span class="s2">&quot;SLSQP&quot;</span><span class="p">,</span>
            <span class="p">]:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Fitting method </span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span> <span class="o">+</span> <span class="s2">&quot;cannot incorporate the bounds you set!&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">elem</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">bounds</span><span class="p">))</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span>
                <span class="s2">&quot;TNC&quot;</span><span class="p">,</span>
                <span class="s2">&quot;SLSQP&quot;</span><span class="p">,</span>
            <span class="p">]:</span>
                <span class="n">use_bounds</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">use_bounds</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># if max_post is True, do the Maximum-A-Posteriori Fit</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_post</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">use_bounds</span><span class="p">:</span>
                    <span class="n">opt</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                        <span class="n">lpost</span><span class="p">,</span>
                        <span class="n">t0_p</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span><span class="p">,</span>
                        <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                        <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-10</span><span class="p">,</span>
                        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">scipy_optimize_options</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">opt</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                        <span class="n">lpost</span><span class="p">,</span>
                        <span class="n">t0_p</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span><span class="p">,</span>
                        <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                        <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-10</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">scipy_optimize_options</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># if max_post is False, then do a Maximum Likelihood Fit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">Posterior</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">use_bounds</span><span class="p">:</span>
                        <span class="c1"># This could be a `Posterior` object</span>
                        <span class="n">opt</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                            <span class="n">lpost</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span>
                            <span class="n">t0_p</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span><span class="p">,</span>
                            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                            <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-10</span><span class="p">,</span>
                            <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">scipy_optimize_options</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">opt</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                            <span class="n">lpost</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span>
                            <span class="n">t0_p</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span><span class="p">,</span>
                            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                            <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-10</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">scipy_optimize_options</span><span class="p">,</span>
                        <span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">LogLikelihood</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">use_bounds</span><span class="p">:</span>
                        <span class="c1"># Except this could be a `LogLikelihood object</span>
                        <span class="c1"># In which case, use the evaluate function</span>
                        <span class="c1"># if it&#39;s not either, give up and break!</span>
                        <span class="n">opt</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                            <span class="n">lpost</span><span class="o">.</span><span class="n">evaluate</span><span class="p">,</span>
                            <span class="n">t0_p</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span><span class="p">,</span>
                            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                            <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-10</span><span class="p">,</span>
                            <span class="c1"># bounds=bounds,</span>
                            <span class="o">**</span><span class="n">scipy_optimize_options</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">opt</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                            <span class="n">lpost</span><span class="o">.</span><span class="n">evaluate</span><span class="p">,</span>
                            <span class="n">t0_p</span><span class="p">,</span>
                            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span><span class="p">,</span>
                            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                            <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-10</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">scipy_optimize_options</span><span class="p">,</span>
                        <span class="p">)</span>

            <span class="n">funcval</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">fun</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">fun</span><span class="p">,</span> <span class="n">logmin</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">fun</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">logmin</span><span class="p">):</span>
                <span class="n">funcval</span> <span class="o">=</span> <span class="mi">100</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">OptimizationResults</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="n">neg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="ParameterEstimation.compute_lrt">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.ParameterEstimation.compute_lrt">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_lrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">lpost2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the Likelihood Ratio Test between two</span>
<span class="sd">        nested models.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost1 : object of a subclass of :class:`Posterior`</span>
<span class="sd">            The :class:`Posterior` object for model 1</span>

<span class="sd">        t1 : iterable</span>
<span class="sd">            The starting parameters for model 1</span>

<span class="sd">        lpost2 : object of a subclass of :class:`Posterior`</span>
<span class="sd">            The :class:`Posterior` object for model 2</span>

<span class="sd">        t2 : iterable</span>
<span class="sd">            The starting parameters for model 2</span>

<span class="sd">        neg : bool, optional, default ``True``</span>
<span class="sd">            Boolean flag to decide whether to use the negative log-likelihood</span>
<span class="sd">            or log-posterior</span>

<span class="sd">        max_post: bool, optional, default ``False``</span>
<span class="sd">            If ``True``, set the internal state to do the optimization with the</span>
<span class="sd">            log-likelihood rather than the log-posterior.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lrt : float</span>
<span class="sd">            The likelihood ratio for model 2 and model 1</span>

<span class="sd">        res1 : OptimizationResults object</span>
<span class="sd">            Contains the result of fitting ``lpost1``</span>

<span class="sd">        res2 : OptimizationResults object</span>
<span class="sd">            Contains the results of fitting ``lpost2``</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_post</span> <span class="o">=</span> <span class="n">max_post</span>

        <span class="c1"># fit data with both models</span>
        <span class="n">res1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">lpost1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="n">neg</span><span class="p">)</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">lpost2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="n">neg</span><span class="p">)</span>

        <span class="c1"># compute log likelihood ratio as difference between the deviances</span>
        <span class="n">lrt</span> <span class="o">=</span> <span class="n">res1</span><span class="o">.</span><span class="n">deviance</span> <span class="o">-</span> <span class="n">res2</span><span class="o">.</span><span class="n">deviance</span>

        <span class="k">return</span> <span class="n">lrt</span><span class="p">,</span> <span class="n">res1</span><span class="p">,</span> <span class="n">res2</span></div>


<div class="viewcode-block" id="ParameterEstimation.sample">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.ParameterEstimation.sample">[docs]</a>
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lpost</span><span class="p">,</span>
        <span class="n">t0</span><span class="p">,</span>
        <span class="n">cov</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nwalkers</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">burnin</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">print_results</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">namestr</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span>
        <span class="n">pool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample the :class:`Posterior` distribution defined in ``lpost`` using MCMC.</span>
<span class="sd">        Here we use the ``emcee`` package, but other implementations could</span>
<span class="sd">        in principle be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost : instance of a :class:`Posterior` subclass</span>
<span class="sd">            and instance of class :class:`Posterior` or one of its subclasses</span>
<span class="sd">            that defines the function to be minimized (either in ``loglikelihood``</span>
<span class="sd">            or ``logposterior``)</span>

<span class="sd">        t0 : iterable</span>
<span class="sd">            list or array containing the starting parameters. Its length</span>
<span class="sd">            must match ``lpost.model.npar``.</span>

<span class="sd">        nwalkers : int, optional, default 500</span>
<span class="sd">            The number of walkers (chains) to use during the MCMC procedure.</span>
<span class="sd">            The more walkers are used, the slower the estimation will be, but</span>
<span class="sd">            the better the final distribution is likely to be.</span>

<span class="sd">        niter : int, optional, default 100</span>
<span class="sd">            The number of iterations to run the MCMC chains for. The larger this</span>
<span class="sd">            number, the longer the estimation will take, but the higher the</span>
<span class="sd">            chance that the walkers have actually converged on the true</span>
<span class="sd">            posterior distribution.</span>

<span class="sd">        burnin : int, optional, default 100</span>
<span class="sd">            The number of iterations to run the walkers before convergence is</span>
<span class="sd">            assumed to have occurred. This part of the chain will be discarded</span>
<span class="sd">            before sampling from what is then assumed to be the posterior</span>
<span class="sd">            distribution desired.</span>

<span class="sd">        threads : **DEPRECATED** int, optional, default 1</span>
<span class="sd">            The number of threads for parallelization.</span>
<span class="sd">            Default is ``1``, i.e. no parallelization</span>
<span class="sd">            With the change to the new emcee version 3, threads is</span>
<span class="sd">            deprecated. Use the `pool` keyword argument instead.</span>
<span class="sd">            This will no longer have any effect.</span>

<span class="sd">        print_results : bool, optional, default ``True``</span>
<span class="sd">            Boolean flag setting whether the results of the MCMC run should</span>
<span class="sd">            be printed to standard output. Default: True</span>

<span class="sd">        plot : bool, optional, default ``False``</span>
<span class="sd">            Boolean flag setting whether summary plots of the MCMC chains</span>
<span class="sd">            should be produced. Default: False</span>

<span class="sd">        namestr : str, optional, default ``test``</span>
<span class="sd">            Optional string for output file names for the plotting.</span>

<span class="sd">        pool : bool, default False</span>
<span class="sd">            If True, use pooling to parallelize the operation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        res : class:`SamplingResults` object</span>
<span class="sd">            An object of class :class:`SamplingResults` summarizing the</span>
<span class="sd">            results of the MCMC run.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s2">&quot;Keyword &#39;threads&#39; is deprecated. Please use &#39;pool&#39; instead.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">can_sample</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;emcee not installed! Can&#39;t sample!&quot;</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># do a MAP fitting step to find good starting positions for</span>
            <span class="c1"># the sampler</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov</span>
        <span class="c1"># sample random starting positions for each walker from</span>
        <span class="c1"># a multivariate Gaussian</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nwalkers</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">()</span> <span class="k">as</span> <span class="n">pooling</span><span class="p">:</span>
                <span class="c1"># initialize the sampler</span>
                <span class="n">sampler</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">EnsembleSampler</span><span class="p">(</span><span class="n">nwalkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span> <span class="n">pool</span><span class="o">=</span><span class="n">pooling</span><span class="p">)</span>

                <span class="c1"># run the burn-in</span>
                <span class="n">pos</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">burnin</span><span class="p">)</span>

                <span class="n">sampler</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

                <span class="n">state</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">State</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">state</span><span class="p">)</span>
                <span class="c1"># do the actual MCMC run</span>

                <span class="n">_</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">(</span><span class="n">initial_state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="n">niter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># initialize the sampler</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">EnsembleSampler</span><span class="p">(</span><span class="n">nwalkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">])</span>

            <span class="c1"># run the burn-in</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">burnin</span><span class="p">)</span>

            <span class="n">sampler</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">State</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">state</span><span class="p">)</span>

            <span class="c1"># do the actual MCMC run</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">(</span><span class="n">initial_state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="n">niter</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">SamplingResults</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">print_results</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">print_results</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">plot_results</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">namestr</span> <span class="o">+</span> <span class="s2">&quot;_corner.pdf&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


    <span class="k">def</span> <span class="nf">_generate_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">pars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that generates a fake PSD similar to the</span>
<span class="sd">        one in the data, but with different parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost : instance of a :class:`Posterior` or :class:`LogLikelihood` subclass</span>
<span class="sd">            The object containing the relevant information about the</span>
<span class="sd">            data and the model</span>

<span class="sd">        pars : iterable</span>
<span class="sd">            A list of parameters to be passed to ``lpost.model`` in order</span>
<span class="sd">            to generate a model data set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model_data : numpy.ndarray</span>
<span class="sd">            An array of model values for each bin in ``lpost.x``</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">LogLikelihood</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">Posterior</span><span class="p">),</span> <span class="p">(</span>
            <span class="s2">&quot;lpost must be of type LogLikelihood or Posterior or one of its &quot;</span> <span class="s2">&quot;subclasses!&quot;</span>
        <span class="p">)</span>

        <span class="c1"># assert pars is of correct length</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pars</span><span class="p">)</span> <span class="o">==</span> <span class="n">lpost</span><span class="o">.</span><span class="n">npar</span><span class="p">,</span> <span class="s2">&quot;pars must be a list &quot;</span> <span class="s2">&quot;of </span><span class="si">%i</span><span class="s2"> parameters&quot;</span> <span class="o">%</span> <span class="n">lpost</span><span class="o">.</span><span class="n">npar</span>
        <span class="c1"># get the model</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span>

        <span class="c1"># reset the parameters</span>
        <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>

        <span class="c1"># make a model spectrum</span>
        <span class="n">model_data</span> <span class="o">=</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model_data</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_compute_pvalue</span><span class="p">(</span><span class="n">obs_val</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the p-value given an observed value of a test statistic</span>
<span class="sd">        and some simulations of that same test statistic.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obs_value : float</span>
<span class="sd">            The observed value of the test statistic in question</span>

<span class="sd">        sim: iterable</span>
<span class="sd">            A list or array of simulated values for the test statistic</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pval : float in range [0, 1]</span>
<span class="sd">            The p-value for the test statistic given the simulations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># cast the simulations as a numpy array</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>

        <span class="c1"># find all simulations that are larger than</span>
        <span class="c1"># the observed value</span>
        <span class="n">ntail</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="n">sim</span> <span class="o">&gt;</span> <span class="n">obs_val</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># divide by the total number of simulations</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ntail</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">pval</span>

<div class="viewcode-block" id="ParameterEstimation.simulate_lrts">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.ParameterEstimation.simulate_lrts">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_lrts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_all</span><span class="p">,</span> <span class="n">lpost1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">lpost2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate likelihood ratios.</span>
<span class="sd">        For details, see definitions in the subclasses that implement this</span>
<span class="sd">        task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;The behaviour of `simulate_lrts` should be defined &quot;</span>
            <span class="s2">&quot;in the subclass appropriate for your problem, not in &quot;</span>
            <span class="s2">&quot;this super class!&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ParameterEstimation.calibrate_lrt">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.ParameterEstimation.calibrate_lrt">[docs]</a>
    <span class="k">def</span> <span class="nf">calibrate_lrt</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lpost1</span><span class="p">,</span>
        <span class="n">t1</span><span class="p">,</span>
        <span class="n">lpost2</span><span class="p">,</span>
        <span class="n">t2</span><span class="p">,</span>
        <span class="n">sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">neg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">max_post</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nsim</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">niter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">nwalkers</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">burnin</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">namestr</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calibrate the outcome of a Likelihood Ratio Test via MCMC.</span>

<span class="sd">        In order to compare models via likelihood ratio test, one generally</span>
<span class="sd">        aims to compute a p-value for the null hypothesis (generally the</span>
<span class="sd">        simpler model). There are two special cases where the theoretical</span>
<span class="sd">        distribution used to compute that p-value analytically given the</span>
<span class="sd">        observed likelihood ratio (a chi-square distribution) is not</span>
<span class="sd">        applicable:</span>

<span class="sd">        * the models are not nested (i.e. Model 1 is not a special, simpler</span>
<span class="sd">          case of Model 2),</span>
<span class="sd">        * the parameter values fixed in Model 2 to retrieve Model 1 are at the</span>
<span class="sd">          edges of parameter space (e.g. if one must set, say, an amplitude to</span>
<span class="sd">          zero in order to remove a component in the more complex model, and</span>
<span class="sd">          negative amplitudes are excluded a priori)</span>

<span class="sd">        In these cases, the observed likelihood ratio must be calibrated via</span>
<span class="sd">        simulations of the simpler model (Model 1), using MCMC to take into</span>
<span class="sd">        account the uncertainty in the parameters. This function does</span>
<span class="sd">        exactly that: it computes the likelihood ratio for the observed data,</span>
<span class="sd">        and produces simulations to calibrate the likelihood ratio and</span>
<span class="sd">        compute a p-value for observing the data under the assumption that</span>
<span class="sd">        Model 1 istrue.</span>

<span class="sd">        If ``max_post=True``, the code will use MCMC to sample the posterior</span>
<span class="sd">        of the parameters and simulate fake data from there.</span>

<span class="sd">        If ``max_post=False``, the code will use the covariance matrix derived</span>
<span class="sd">        from the fit to simulate data sets for comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost1 : object of a subclass of :class:`Posterior`</span>
<span class="sd">            The :class:`Posterior` object for model 1</span>

<span class="sd">        t1 : iterable</span>
<span class="sd">            The starting parameters for model 1</span>

<span class="sd">        lpost2 : object of a subclass of :class:`Posterior`</span>
<span class="sd">            The :class:`Posterior` object for model 2</span>

<span class="sd">        t2 : iterable</span>
<span class="sd">            The starting parameters for model 2</span>

<span class="sd">        neg : bool, optional, default ``True``</span>
<span class="sd">            Boolean flag to decide whether to use the negative</span>
<span class="sd">            log-likelihood or log-posterior</span>

<span class="sd">        max_post: bool, optional, default ``False``</span>
<span class="sd">            If ``True``, set the internal state to do the optimization with the</span>
<span class="sd">            log-likelihood rather than the log-posterior.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pvalue : float [0,1]</span>
<span class="sd">            p-value &#39;n stuff</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute the observed likelihood ratio</span>
        <span class="n">lrt_obs</span><span class="p">,</span> <span class="n">res1</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_lrt</span><span class="p">(</span><span class="n">lpost1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">lpost2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="n">neg</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="n">max_post</span><span class="p">)</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># simulate parameter sets from the simpler model</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">max_post</span><span class="p">:</span>
                <span class="c1"># using Maximum Likelihood, so I&#39;m going to simulate parameters</span>
                <span class="c1"># from a multivariate Gaussian</span>

                <span class="c1"># set up the distribution</span>
                <span class="n">mvn</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">res1</span><span class="o">.</span><span class="n">p_opt</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">res1</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

                <span class="c1"># sample parameters</span>
                <span class="n">s_all</span> <span class="o">=</span> <span class="n">mvn</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">nsim</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lpost1</span><span class="o">.</span><span class="n">npar</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">s_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">s_all</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># sample the :class:`Posterior` using MCMC</span>
                <span class="n">s_mcmc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                    <span class="n">lpost1</span><span class="p">,</span>
                    <span class="n">res1</span><span class="o">.</span><span class="n">p_opt</span><span class="p">,</span>
                    <span class="n">cov</span><span class="o">=</span><span class="n">res1</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span>
                    <span class="n">nwalkers</span><span class="o">=</span><span class="n">nwalkers</span><span class="p">,</span>
                    <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span>
                    <span class="n">burnin</span><span class="o">=</span><span class="n">burnin</span><span class="p">,</span>
                    <span class="n">namestr</span><span class="o">=</span><span class="n">namestr</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># pick nsim samples out of the :class:`Posterior` sample</span>
                <span class="n">s_all</span> <span class="o">=</span> <span class="n">s_mcmc</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">s_mcmc</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsim</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>

                <span class="c1"># if lpost1.npar == 1:</span>
                <span class="c1">#    s_all = np.atleast_2d(s_all).T</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">s_all</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsim</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>

        <span class="c1"># simulate LRTs</span>
        <span class="c1"># this method is defined in the subclasses!</span>
        <span class="n">lrt_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_lrts</span><span class="p">(</span><span class="n">s_all</span><span class="p">,</span> <span class="n">lpost1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">lpost2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="c1"># now I can compute the p-value:</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="n">ParameterEstimation</span><span class="o">.</span><span class="n">_compute_pvalue</span><span class="p">(</span><span class="n">lrt_obs</span><span class="p">,</span> <span class="n">lrt_sim</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pval</span></div>
</div>



<div class="viewcode-block" id="SamplingResults">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.SamplingResults">[docs]</a>
<span class="k">class</span> <span class="nc">SamplingResults</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper class that will contain the results of the sampling</span>
<span class="sd">    in a handy format.</span>

<span class="sd">    Less fiddly than a dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sampler: ``emcee.EnsembleSampler`` object</span>
<span class="sd">        The object containing the sampler that&#39;s done all the work.</span>

<span class="sd">    ci_min: float out of [0,100]</span>
<span class="sd">        The lower bound percentile for printing credible intervals</span>
<span class="sd">        on the parameters</span>

<span class="sd">    ci_max: float out of [0,100]</span>
<span class="sd">        The upper bound percentile for printing credible intervals</span>
<span class="sd">        on the parameters</span>
<span class="sd">    log : a logging.getLogger() object, default None</span>
<span class="sd">        You can pass a pre-defined object for logging, else a new</span>
<span class="sd">        logger will be instantiated</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : numpy.ndarray</span>
<span class="sd">        An array of samples from the MCMC run, including all chains</span>
<span class="sd">        flattened into one long (``nwalkers*niter``, ``ndim``) array</span>

<span class="sd">    nwalkers : int</span>
<span class="sd">        The number of chains used in the MCMC procedure</span>

<span class="sd">    niter : int</span>
<span class="sd">        The number of MCMC iterations in each chain</span>

<span class="sd">    ndim : int</span>
<span class="sd">        The dimensionality of the problem, i.e. the number of</span>
<span class="sd">        parameters in the model</span>

<span class="sd">    acceptance : float</span>
<span class="sd">        The mean acceptance ratio, calculated over all chains</span>

<span class="sd">    L : float</span>
<span class="sd">        The product of acceptance ratio and number of samples</span>

<span class="sd">    acor : float</span>
<span class="sd">        The autocorrelation length for the chains; should be shorter</span>
<span class="sd">        than the chains themselves for independent sampling</span>

<span class="sd">    rhat : float</span>
<span class="sd">        weighted average of between-sequence variance and within-sequence</span>
<span class="sd">        variance; Gelman-Rubin convergence statistic [#]_</span>

<span class="sd">    mean : numpy.ndarray</span>
<span class="sd">        An array of size ``ndim``, with the posterior means of the parameters</span>
<span class="sd">        derived from the MCMC chains</span>

<span class="sd">    std : numpy.ndarray</span>
<span class="sd">        An array of size ``ndim`` with the posterior standard deviations of</span>
<span class="sd">        the parameters derived from the MCMC chains</span>

<span class="sd">    ci : numpy.ndarray</span>
<span class="sd">        An array of shape ``(ndim, 2)`` containing the lower and upper bounds</span>
<span class="sd">        of the credible interval (the Bayesian equivalent of the confidence</span>
<span class="sd">        interval) for each parameter using the bounds set by ``ci_min`` and ``ci_max``</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [#] https://projecteuclid.org/euclid.ss/1177011136</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">ci_min</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ci_max</span><span class="o">=</span><span class="mi">95</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">log</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;MCMC summary&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

        <span class="c1"># store all the samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_chain</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">chain_dims</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_chain</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nwalkers</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">chain_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">chain_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># store number of dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="n">chain_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># compute and store acceptance fraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">acceptance_fraction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_convergence</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_infer</span><span class="p">(</span><span class="n">ci_min</span><span class="p">,</span> <span class="n">ci_max</span><span class="p">)</span>

<div class="viewcode-block" id="SamplingResults._check_convergence">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.SamplingResults._check_convergence">[docs]</a>
    <span class="k">def</span> <span class="nf">_check_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampler</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute common statistics for convergence of the MCMC</span>
<span class="sd">        chains. While you can never be completely sure that your chains</span>
<span class="sd">        converged, these present reasonable heuristics to give an</span>
<span class="sd">        indication whether convergence is very far off or reasonably close.</span>

<span class="sd">        Currently implemented are the autocorrelation time [#]_ and the</span>
<span class="sd">        Gelman-Rubin convergence criterion [#]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sampler : an ``emcee.EnsembleSampler`` object</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [#] https://arxiv.org/abs/1202.3665</span>
<span class="sd">        .. [#] https://projecteuclid.org/euclid.ss/1177011136</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute and store autocorrelation time</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acor</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_autocorr_time</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">emcee</span><span class="o">.</span><span class="n">autocorr</span><span class="o">.</span><span class="n">AutocorrError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Chains too short to compute autocorrelation lengths.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rhat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rhat</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span></div>


<div class="viewcode-block" id="SamplingResults._compute_rhat">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.SamplingResults._compute_rhat">[docs]</a>
    <span class="k">def</span> <span class="nf">_compute_rhat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampler</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Gelman-Rubin convergence criterion [#]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sampler : an `emcee.EnsembleSampler` object</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [#] https://projecteuclid.org/euclid.ss/1177011136</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_chain</span><span class="p">()</span>
        <span class="c1"># between-sequence variance</span>
        <span class="n">mean_samples_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># mean over the means over iterations: (self.ndim)</span>
        <span class="n">mean_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># now compute between-sequence variance</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwalkers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="p">(</span><span class="n">mean_samples_iter</span> <span class="o">-</span> <span class="n">mean_samples</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="c1"># compute variance of each chain</span>
        <span class="n">var_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># compute mean of variance</span>
        <span class="n">ww</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">var_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># compute weighted average of ww and bb:</span>
        <span class="n">rhat</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">)</span> <span class="o">*</span> <span class="n">ww</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">)</span> <span class="o">*</span> <span class="n">bb</span>

        <span class="k">return</span> <span class="n">rhat</span></div>


<div class="viewcode-block" id="SamplingResults._infer">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.SamplingResults._infer">[docs]</a>
    <span class="k">def</span> <span class="nf">_infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ci_min</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ci_max</span><span class="o">=</span><span class="mi">95</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer the :class:`Posterior` means, standard deviations and credible intervals</span>
<span class="sd">        (i.e. the Bayesian equivalent to confidence intervals) from the :class:`Posterior` samples</span>
<span class="sd">        for each parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ci_min : float</span>
<span class="sd">            Lower bound to the credible interval, given as percentage between</span>
<span class="sd">            0 and 100</span>

<span class="sd">        ci_max : float</span>
<span class="sd">            Upper bound to the credible interval, given as percentage between</span>
<span class="sd">            0 and 100</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="p">[</span><span class="n">ci_min</span><span class="p">,</span> <span class="n">ci_max</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="SamplingResults.print_results">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.SamplingResults.print_results">[docs]</a>
    <span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print results of the MCMC run on screen or to a log-file.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;-- The acceptance fraction is: </span><span class="si">%f</span><span class="s2">.5&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;-- The autocorrelation time is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acor</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;R_hat for the parameters is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhat</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;-- Posterior Summary of Parameters: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;parameter </span><span class="se">\t</span><span class="s2"> mean </span><span class="se">\t\t</span><span class="s2"> sd </span><span class="se">\t\t</span><span class="s2"> 5% </span><span class="se">\t\t</span><span class="s2"> 95% </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;---------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;theta[&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;] </span><span class="se">\t</span><span class="s2"> &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ci</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span></div>


<div class="viewcode-block" id="SamplingResults.plot_results">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.SamplingResults.plot_results">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;test.pdf&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot some results in a triangle plot.</span>
<span class="sd">        If installed, will use [corner]_</span>
<span class="sd">        for the plotting, if not,</span>
<span class="sd">        uses its own code to make a triangle plot.</span>

<span class="sd">        By default, this method returns a ``matplotlib.Figure`` object, but</span>
<span class="sd">        if ``save_plot=True`` the plot can be saved to file automatically,</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        nsamples : int, default 1000</span>
<span class="sd">            The maximum number of samples used for plotting.</span>

<span class="sd">        fig : matplotlib.Figure instance, default None</span>
<span class="sd">            If created externally, you can pass a Figure instance to this method.</span>
<span class="sd">            If none is passed, the method will create one internally.</span>

<span class="sd">        save_plot : bool, default ``False``</span>
<span class="sd">            If ``True`` save the plot to file with a file name specified by the</span>
<span class="sd">            keyword ``filename``. If ``False`` just return the ``Figure`` object</span>

<span class="sd">        filename : str</span>
<span class="sd">            Name of the output file with the figure</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [corner] https://github.com/dfm/corner.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_corner</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">corner</span><span class="o">.</span><span class="n">corner</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                <span class="n">bins</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
                <span class="n">quantiles</span><span class="o">=</span><span class="p">[</span><span class="mf">0.16</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.84</span><span class="p">],</span>
                <span class="n">show_titles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">title_args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fontsize&quot;</span><span class="p">:</span> <span class="mi">12</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span>
                <span class="n">top</span><span class="o">=</span><span class="mf">0.925</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">0.975</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.2</span>
            <span class="p">)</span>

            <span class="n">ind_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">ind_all</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">ticklabel_format</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">&quot;sci&quot;</span><span class="p">,</span> <span class="n">scilimits</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">ntemp</span><span class="p">,</span> <span class="n">binstemp</span><span class="p">,</span> <span class="n">patchestemp</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
                            <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="mi">30</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s2">&quot;stepfilled&quot;</span>
                        <span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ntemp</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.2</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

                        <span class="c1"># make a scatter plot first</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
                        <span class="c1"># then add contours</span>
                        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

                        <span class="c1"># Perform Kernel density estimate on data</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">,</span> <span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xx</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>
                            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]])</span>
                            <span class="n">kernel</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">gaussian_kde</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                            <span class="n">zz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kernel</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                            <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Not making contours.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>
</div>



<div class="viewcode-block" id="PSDParEst">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.PSDParEst">[docs]</a>
<span class="k">class</span> <span class="nc">PSDParEst</span><span class="p">(</span><span class="n">ParameterEstimation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameter estimation for parametric modelling of power spectra.</span>

<span class="sd">    This class contains functionality that allows parameter estimation</span>
<span class="sd">    and related tasks that involve fitting a parametric model to an</span>
<span class="sd">    (averaged) power spectrum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ps : class:`stingray.Powerspectrum` or class:`stingray.AveragedPowerspectrum` object</span>
<span class="sd">        The power spectrum to be modelled</span>

<span class="sd">    fitmethod : str, optional, default ``BFGS``</span>
<span class="sd">        A string allowed by ``scipy.optimize.minimize`` as a valid</span>
<span class="sd">        fitting method</span>

<span class="sd">    max_post : bool, optional, default ``True``</span>
<span class="sd">        If ``True``, do a Maximum-A-Posteriori (MAP) fit, i.e. fit with</span>
<span class="sd">        priors, otherwise do a Maximum Likelihood fit instead</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="s2">&quot;BFGS&quot;</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ps</span> <span class="o">=</span> <span class="n">ps</span>
        <span class="n">ParameterEstimation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="n">fitmethod</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="n">max_post</span><span class="p">)</span>

<div class="viewcode-block" id="PSDParEst.fit">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.PSDParEst.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scipy_optimize_options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do either a Maximum-A-Posteriori (MAP) or Maximum Likelihood (ML)</span>
<span class="sd">        fit to the power spectrum.</span>

<span class="sd">        MAP fits include priors, ML fits do not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost : :class:`stingray.modeling.PSDPosterior` object</span>
<span class="sd">            An instance of class :class:`stingray.modeling.PSDPosterior` that defines the</span>
<span class="sd">            function to be minimized (either in ``loglikelihood`` or ``logposterior``)</span>

<span class="sd">        t0 : {list | numpy.ndarray}</span>
<span class="sd">            List/array with set of initial parameters</span>

<span class="sd">        neg : bool, optional, default ``True``</span>
<span class="sd">            Boolean to be passed to ``lpost``, setting whether to use the</span>
<span class="sd">            *negative* posterior or the *negative* log-likelihood.</span>

<span class="sd">        scipy_optimize_options : dict, optional, default None</span>
<span class="sd">            A dictionary with options for ``scipy.optimize.minimize``,</span>
<span class="sd">            directly passed on as keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res : :class:`OptimizationResults` object</span>
<span class="sd">            An object containing useful summaries of the fitting procedure.</span>
<span class="sd">            For details, see documentation of :class:`OptimizationResults`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lpost</span> <span class="o">=</span> <span class="n">lpost</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">ParameterEstimation</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpost</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="n">neg</span><span class="p">,</span> <span class="n">scipy_optimize_options</span><span class="o">=</span><span class="n">scipy_optimize_options</span>
        <span class="p">)</span>

        <span class="n">res</span><span class="o">.</span><span class="n">maxpow</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">maxfreq</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">maxind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_highest_outlier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lpost</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="PSDParEst.sample">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.PSDParEst.sample">[docs]</a>
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lpost</span><span class="p">,</span>
        <span class="n">t0</span><span class="p">,</span>
        <span class="n">cov</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nwalkers</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">burnin</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">print_results</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">namestr</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample the posterior distribution defined in ``lpost`` using MCMC.</span>
<span class="sd">        Here we use the ``emcee`` package, but other implementations could</span>
<span class="sd">        in principle be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost : instance of a :class:`Posterior` subclass</span>
<span class="sd">            and instance of class :class:`Posterior` or one of its subclasses</span>
<span class="sd">            that defines the function to be minimized (either in ``loglikelihood``</span>
<span class="sd">            or ``logposterior``)</span>

<span class="sd">        t0 : iterable</span>
<span class="sd">            list or array containing the starting parameters. Its length</span>
<span class="sd">            must match ``lpost.model.npar``.</span>

<span class="sd">        nwalkers : int, optional, default 500</span>
<span class="sd">            The number of walkers (chains) to use during the MCMC procedure.</span>
<span class="sd">            The more walkers are used, the slower the estimation will be, but</span>
<span class="sd">            the better the final distribution is likely to be.</span>

<span class="sd">        niter : int, optional, default 100</span>
<span class="sd">            The number of iterations to run the MCMC chains for. The larger this</span>
<span class="sd">            number, the longer the estimation will take, but the higher the</span>
<span class="sd">            chance that the walkers have actually converged on the true</span>
<span class="sd">            posterior distribution.</span>

<span class="sd">        burnin : int, optional, default 100</span>
<span class="sd">            The number of iterations to run the walkers before convergence is</span>
<span class="sd">            assumed to have occurred. This part of the chain will be discarded</span>
<span class="sd">            before sampling from what is then assumed to be the posterior</span>
<span class="sd">            distribution desired.</span>

<span class="sd">        threads : int, optional, default 1</span>
<span class="sd">            The number of threads for parallelization.</span>
<span class="sd">            Default is ``1``, i.e. no parallelization</span>

<span class="sd">        print_results : bool, optional, default True</span>
<span class="sd">            Boolean flag setting whether the results of the MCMC run should</span>
<span class="sd">            be printed to standard output</span>

<span class="sd">        plot : bool, optional, default False</span>
<span class="sd">            Boolean flag setting whether summary plots of the MCMC chains</span>
<span class="sd">            should be produced</span>

<span class="sd">        namestr : str, optional, default ``test``</span>
<span class="sd">            Optional string for output file names for the plotting.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        res : :class:`SamplingResults` object</span>
<span class="sd">            An object containing useful summaries of the</span>
<span class="sd">            sampling procedure. For details see documentation of :class:`SamplingResults`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lpost</span> <span class="o">=</span> <span class="n">lpost</span>

        <span class="k">if</span> <span class="n">cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fit_res</span> <span class="o">=</span> <span class="n">ParameterEstimation</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpost</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">fit_res</span><span class="o">.</span><span class="n">cov</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">fit_res</span><span class="o">.</span><span class="n">p_opt</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">ParameterEstimation</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lpost</span><span class="p">,</span>
            <span class="n">t0</span><span class="p">,</span>
            <span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">,</span>
            <span class="n">nwalkers</span><span class="o">=</span><span class="n">nwalkers</span><span class="p">,</span>
            <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span>
            <span class="n">burnin</span><span class="o">=</span><span class="n">burnin</span><span class="p">,</span>
            <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span>
            <span class="n">print_results</span><span class="o">=</span><span class="n">print_results</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
            <span class="n">namestr</span><span class="o">=</span><span class="n">namestr</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


    <span class="k">def</span> <span class="nf">_generate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a fake power spectrum from a model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost : instance of a :class:`Posterior` or :class:`LogLikelihood` subclass</span>
<span class="sd">            The object containing the relevant information about the</span>
<span class="sd">            data and the model</span>

<span class="sd">        pars : iterable</span>
<span class="sd">            A list of parameters to be passed to ``lpost.model`` in order</span>
<span class="sd">            to generate a model data set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sim_ps : :class:`stingray.Powerspectrum` object</span>
<span class="sd">            The simulated :class:`Powerspectrum` object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create own random state object</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">model_spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_model</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>

        <span class="c1"># use chi-square distribution to get fake data</span>
        <span class="n">model_powers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">model_spectrum</span>
            <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">chisquare</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">model_spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">sim_ps</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">)</span>

        <span class="n">sim_ps</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">model_powers</span>

        <span class="k">return</span> <span class="n">sim_ps</span>

<div class="viewcode-block" id="PSDParEst.simulate_lrts">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.PSDParEst.simulate_lrts">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_lrts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_all</span><span class="p">,</span> <span class="n">lpost1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">lpost2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate likelihood ratios for two given models based on MCMC samples</span>
<span class="sd">        for the simpler model (i.e. the null hypothesis).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s_all : numpy.ndarray of shape ``(nsamples, lpost1.npar)``</span>
<span class="sd">            An array with MCMC samples derived from the null hypothesis model in</span>
<span class="sd">            ``lpost1``. Its second dimension must match the number of free</span>
<span class="sd">            parameters in ``lpost1.model``.</span>

<span class="sd">        lpost1 : :class:`LogLikelihood` or :class:`Posterior` subclass object</span>
<span class="sd">            Object containing the null hypothesis model</span>

<span class="sd">        t1 : iterable of length ``lpost1.npar``</span>
<span class="sd">            A starting guess for fitting the model in ``lpost1``</span>

<span class="sd">        lpost2 : :class:`LogLikelihood` or :class:`Posterior` subclass object</span>
<span class="sd">            Object containing the alternative hypothesis model</span>

<span class="sd">        t2 : iterable of length ``lpost2.npar``</span>
<span class="sd">            A starting guess for fitting the model in ``lpost2``</span>

<span class="sd">        max_post : bool, optional, default ``True``</span>
<span class="sd">            If ``True``, then ``lpost1`` and ``lpost2`` should be :class:`Posterior` subclass</span>
<span class="sd">            objects; if ``False``, then ``lpost1`` and ``lpost2`` should be</span>
<span class="sd">            :class:`LogLikelihood` subclass objects</span>

<span class="sd">        seed : int, optional default ``None``</span>
<span class="sd">            A seed to initialize the ``numpy.random.RandomState`` object to be</span>
<span class="sd">            passed on to ``_generate_data``. Useful for producing exactly</span>
<span class="sd">            reproducible results</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lrt_sim : numpy.ndarray</span>
<span class="sd">            An array with the simulated likelihood ratios for the simulated</span>
<span class="sd">            data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">lpost1</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">lpost2</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;Both LogLikelihood or &quot;</span> <span class="s2">&quot;Posterior objects must be &quot;</span> <span class="s2">&quot;of the same class!&quot;</span>
        <span class="p">)</span>

        <span class="n">nsim</span> <span class="o">=</span> <span class="n">s_all</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lrt_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsim</span><span class="p">)</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># now I can loop over all simulated parameter sets to generate a PSD</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_all</span><span class="p">):</span>
            <span class="c1"># generate fake PSD</span>
            <span class="n">sim_ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_data</span><span class="p">(</span><span class="n">lpost1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>

            <span class="n">neg</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># make LogLikelihood objects for both:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lpost1</span><span class="p">,</span> <span class="n">LogLikelihood</span><span class="p">):</span>
                <span class="n">sim_lpost1</span> <span class="o">=</span> <span class="n">PSDLogLikelihood</span><span class="p">(</span>
                    <span class="n">sim_ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">sim_ps</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">lpost1</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">sim_ps</span><span class="o">.</span><span class="n">m</span>
                <span class="p">)</span>
                <span class="n">sim_lpost2</span> <span class="o">=</span> <span class="n">PSDLogLikelihood</span><span class="p">(</span>
                    <span class="n">sim_ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">sim_ps</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">lpost2</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">sim_ps</span><span class="o">.</span><span class="n">m</span>
                <span class="p">)</span>
                <span class="n">max_post</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># make a :class:`Posterior` object</span>
                <span class="n">sim_lpost1</span> <span class="o">=</span> <span class="n">PSDPosterior</span><span class="p">(</span><span class="n">sim_ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">sim_ps</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="n">lpost1</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">sim_ps</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
                <span class="n">sim_lpost1</span><span class="o">.</span><span class="n">logprior</span> <span class="o">=</span> <span class="n">lpost1</span><span class="o">.</span><span class="n">logprior</span>

                <span class="n">sim_lpost2</span> <span class="o">=</span> <span class="n">PSDPosterior</span><span class="p">(</span><span class="n">sim_ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">sim_ps</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="n">lpost2</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">sim_ps</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>

                <span class="n">sim_lpost2</span><span class="o">.</span><span class="n">logprior</span> <span class="o">=</span> <span class="n">lpost2</span><span class="o">.</span><span class="n">logprior</span>
                <span class="n">max_post</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">parest_sim</span> <span class="o">=</span> <span class="n">PSDParEst</span><span class="p">(</span><span class="n">sim_ps</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="n">max_post</span><span class="p">,</span> <span class="n">fitmethod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fitmethod</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">lrt_sim</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">parest_sim</span><span class="o">.</span><span class="n">compute_lrt</span><span class="p">(</span>
                    <span class="n">sim_lpost1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">sim_lpost2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="n">neg</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="n">max_post</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Fitting was unsuccessful. &quot;</span> <span class="s2">&quot;Skipping this simulation!&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

        <span class="k">return</span> <span class="n">lrt_sim</span></div>


<div class="viewcode-block" id="PSDParEst.calibrate_highest_outlier">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.PSDParEst.calibrate_highest_outlier">[docs]</a>
    <span class="k">def</span> <span class="nf">calibrate_highest_outlier</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lpost</span><span class="p">,</span>
        <span class="n">t0</span><span class="p">,</span>
        <span class="n">sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_post</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nsim</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">niter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">nwalkers</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">burnin</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">namestr</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate the highest outlier in a data set using MCMC-simulated</span>
<span class="sd">        power spectra.</span>

<span class="sd">        In short, the procedure does a MAP fit to the data, computes the</span>
<span class="sd">        statistic</span>

<span class="sd">        .. math::</span>

<span class="sd">            \max{(T_R = 2(\mathrm{data}/\mathrm{model}))}</span>

<span class="sd">        and then does an MCMC run using the data and the model, or generates parameter samples</span>
<span class="sd">        from the likelihood distribution using the derived covariance in a Maximum Likelihood</span>
<span class="sd">        fit.</span>
<span class="sd">        From the (posterior) samples, it generates fake power spectra. Each fake spectrum is fit</span>
<span class="sd">        in the same way as the data, and the highest data/model outlier extracted as for the data.</span>
<span class="sd">        The observed value of :math:`T_R` can then be directly compared to the simulated</span>
<span class="sd">        distribution of :math:`T_R` values in order to derive a p-value of the null</span>
<span class="sd">        hypothesis that the observed :math:`T_R` is compatible with being generated by</span>
<span class="sd">        noise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost : :class:`stingray.modeling.PSDPosterior` object</span>
<span class="sd">            An instance of class :class:`stingray.modeling.PSDPosterior` that defines the</span>
<span class="sd">            function to be minimized (either in ``loglikelihood`` or ``logposterior``)</span>

<span class="sd">        t0 : {list | numpy.ndarray}</span>
<span class="sd">            List/array with set of initial parameters</span>

<span class="sd">        sample : :class:`SamplingResults` instance, optional, default ``None``</span>
<span class="sd">            If a sampler has already been run, the :class:`SamplingResults` instance can be</span>
<span class="sd">            fed into this method here, otherwise this method will run a sampler</span>
<span class="sd">            automatically</span>

<span class="sd">        max_post: bool, optional, default ``False``</span>
<span class="sd">            If ``True``, do MAP fits on the power spectrum to find the highest data/model outlier</span>
<span class="sd">            Otherwise, do a Maximum Likelihood fit. If ``True``, the simulated power spectra will</span>
<span class="sd">            be generated from an MCMC run, otherwise the method will employ the approximated</span>
<span class="sd">            covariance matrix for the parameters derived from the likelihood surface to generate</span>
<span class="sd">            samples from that likelihood function.</span>

<span class="sd">        nsim : int, optional, default ``1000``</span>
<span class="sd">            Number of fake power spectra to simulate from the posterior sample. Note that this</span>
<span class="sd">            number sets the resolution of the resulting p-value. For ``nsim=1000``, the highest</span>
<span class="sd">            resolution that can be achieved is :math:`10^{-3}`.</span>

<span class="sd">        niter : int, optional, default 200</span>
<span class="sd">            If ``sample`` is ``None``, this variable will be used to set the number of steps in the</span>
<span class="sd">            MCMC procedure *after* burn-in.</span>

<span class="sd">        nwalkers : int, optional, default 500</span>
<span class="sd">             If ``sample`` is ``None``, this variable will be used to set the number of MCMC chains</span>
<span class="sd">             run in parallel in the sampler.</span>

<span class="sd">        burnin : int, optional, default 200</span>
<span class="sd">             If ``sample`` is ``None``, this variable will be used to set the number of burn-in steps</span>
<span class="sd">             to be discarded in the initial phase of the MCMC run</span>

<span class="sd">        namestr : str, optional, default ``test``</span>
<span class="sd">            A string to be used for storing MCMC output and plots to disk</span>

<span class="sd">        seed : int, optional, default ``None``</span>
<span class="sd">            An optional number to seed the random number generator with, for reproducibility of</span>
<span class="sd">            the results obtained with this method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pval : float</span>
<span class="sd">            The p-value that the highest data/model outlier is produced by random noise, calibrated</span>
<span class="sd">            using simulated power spectra from an MCMC run.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        For more details on the procedure employed here, see</span>

<span class="sd">            * Vaughan, 2010: https://arxiv.org/abs/0910.2706</span>
<span class="sd">            * Huppenkothen et al, 2013: https://arxiv.org/abs/1212.1011</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fit the model to the data</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># find the highest data/model outlier:</span>
        <span class="n">out_high</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_highest_outlier</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="c1"># simulate parameter sets from the simpler model</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">max_post</span><span class="p">:</span>
            <span class="c1"># using Maximum Likelihood, so I&#39;m going to simulate parameters</span>
            <span class="c1"># from a multivariate Gaussian</span>

            <span class="c1"># set up the distribution</span>
            <span class="n">mvn</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">p_opt</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">lpost</span><span class="o">.</span><span class="n">npar</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># sample parameters</span>
                <span class="n">s_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">mvn</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">nsim</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">s_all</span> <span class="o">=</span> <span class="n">mvn</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">nsim</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># sample the :class:`Posterior` using MCMC</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                    <span class="n">lpost</span><span class="p">,</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">p_opt</span><span class="p">,</span>
                    <span class="n">cov</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span>
                    <span class="n">nwalkers</span><span class="o">=</span><span class="n">nwalkers</span><span class="p">,</span>
                    <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span>
                    <span class="n">burnin</span><span class="o">=</span><span class="n">burnin</span><span class="p">,</span>
                    <span class="n">namestr</span><span class="o">=</span><span class="n">namestr</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># pick nsim samples out of the :class:`Posterior` sample</span>
            <span class="n">s_all</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsim</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>

        <span class="c1"># simulate LRTs</span>
        <span class="c1"># this method is defined in the subclasses!</span>
        <span class="n">out_high_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulate_highest_outlier</span><span class="p">(</span><span class="n">s_all</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="n">max_post</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="c1"># now I can compute the p-value:</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="n">ParameterEstimation</span><span class="o">.</span><span class="n">_compute_pvalue</span><span class="p">(</span><span class="n">out_high</span><span class="p">,</span> <span class="n">out_high_sim</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pval</span></div>


<div class="viewcode-block" id="PSDParEst.simulate_highest_outlier">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.PSDParEst.simulate_highest_outlier">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate_highest_outlier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_all</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate :math:`n` power spectra from a model and then find the highest</span>
<span class="sd">        data/model outlier in each.</span>

<span class="sd">        The data/model outlier is defined as</span>

<span class="sd">        .. math::</span>

<span class="sd">             \max{(T_R = 2(\mathrm{data}/\mathrm{model}))} .</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s_all : numpy.ndarray</span>
<span class="sd">            A list of parameter values derived either from an approximation of the</span>
<span class="sd">            likelihood surface, or from an MCMC run. Has dimensions ``(n, ndim)``, where</span>
<span class="sd">            ``n`` is the number of simulated power spectra to generate, and ``ndim`` the</span>
<span class="sd">            number of model parameters.</span>

<span class="sd">        lpost : instance of a :class:`Posterior` subclass</span>
<span class="sd">            an instance of class :class:`Posterior` or one of its subclasses</span>
<span class="sd">            that defines the function to be minimized (either in ``loglikelihood``</span>
<span class="sd">            or ``logposterior``)</span>

<span class="sd">        t0 : iterable</span>
<span class="sd">            list or array containing the starting parameters. Its length</span>
<span class="sd">            must match ``lpost.model.npar``.</span>

<span class="sd">        max_post: bool, optional, default ``False``</span>
<span class="sd">            If ``True``, do MAP fits on the power spectrum to find the highest data/model outlier</span>
<span class="sd">            Otherwise, do a Maximum Likelihood fit. If True, the simulated power spectra will</span>
<span class="sd">            be generated from an MCMC run, otherwise the method will employ the approximated</span>
<span class="sd">            covariance matrix for the parameters derived from the likelihood surface to generate</span>
<span class="sd">            samples from that likelihood function.</span>

<span class="sd">        seed : int, optional, default ``None``</span>
<span class="sd">            An optional number to seed the random number generator with, for reproducibility of</span>
<span class="sd">            the results obtained with this method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        max_y_all : numpy.ndarray</span>
<span class="sd">            An array of maximum outliers for each simulated power spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the number of simulations</span>
        <span class="n">nsim</span> <span class="o">=</span> <span class="n">s_all</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># empty array for the simulation results</span>
        <span class="n">max_y_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsim</span><span class="p">)</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># now I can loop over all simulated parameter sets to generate a PSD</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_all</span><span class="p">):</span>
            <span class="c1"># generate fake PSD</span>
            <span class="n">sim_ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_data</span><span class="p">(</span><span class="n">lpost</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>

            <span class="c1"># make LogLikelihood objects for both:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">max_post</span><span class="p">:</span>
                <span class="n">sim_lpost</span> <span class="o">=</span> <span class="n">PSDLogLikelihood</span><span class="p">(</span>
                    <span class="n">sim_ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">sim_ps</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">sim_ps</span><span class="o">.</span><span class="n">m</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># make a :class:`Posterior` object</span>
                <span class="n">sim_lpost</span> <span class="o">=</span> <span class="n">PSDPosterior</span><span class="p">(</span><span class="n">sim_ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">sim_ps</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="n">lpost</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">sim_ps</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
                <span class="n">sim_lpost</span><span class="o">.</span><span class="n">logprior</span> <span class="o">=</span> <span class="n">lpost</span><span class="o">.</span><span class="n">logprior</span>

            <span class="n">parest_sim</span> <span class="o">=</span> <span class="n">PSDParEst</span><span class="p">(</span><span class="n">sim_ps</span><span class="p">,</span> <span class="n">max_post</span><span class="o">=</span><span class="n">max_post</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">parest_sim</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">sim_lpost</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">max_y</span><span class="p">,</span> <span class="n">maxfreq</span><span class="p">,</span> <span class="n">maxind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_highest_outlier</span><span class="p">(</span><span class="n">sim_lpost</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">max_y_all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Fitting unsuccessful! &quot;</span> <span class="s2">&quot;Skipping this simulation!&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">max_y_all</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_compute_highest_outlier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpost</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Auxiliary method calculating the highest outlier statistic in</span>
<span class="sd">        a power spectrum.</span>

<span class="sd">        The maximum data/model outlier is defined as</span>

<span class="sd">        .. math::</span>

<span class="sd">             \max{(T_R = 2(\mathrm{data}/\mathrm{model}))}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpost : instance of a :class:`Posterior` subclass</span>
<span class="sd">            and instance of class :class:`Posterior` or one of its subclasses</span>
<span class="sd">            that defines the function to be minimized (either in ``loglikelihood``</span>
<span class="sd">            or ``logposterior``)</span>

<span class="sd">        res : :class:`OptimizationResults` object</span>
<span class="sd">            An object containing useful summaries of the fitting procedure.</span>
<span class="sd">            For details, see documentation of :class:`OptimizationResults`.</span>

<span class="sd">        nmax : int, optional, default ``1``</span>
<span class="sd">            The number of maxima to extract from the power spectra. By default,</span>
<span class="sd">            only the highest data/model outlier is extracted. This number allows</span>
<span class="sd">            to extract the ``nmax`` highest outliers, useful when looking for</span>
<span class="sd">            multiple signals in a power spectrum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        max_y : {float | numpy.ndarray}</span>
<span class="sd">            The ``nmax`` highest data/model outliers</span>

<span class="sd">        max_x : {float | numpy.ndarray}</span>
<span class="sd">            The frequencies corresponding to the outliers in ``max_y``</span>

<span class="sd">        max_ind : {int | numpy.ndarray}</span>
<span class="sd">            The indices corresponding to the outliers in ``max_y``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">lpost</span><span class="o">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">res</span><span class="o">.</span><span class="n">mfit</span>

        <span class="n">ratio_sort</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
        <span class="n">ratio_sort</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">max_y</span> <span class="o">=</span> <span class="n">ratio_sort</span><span class="p">[</span><span class="o">-</span><span class="n">nmax</span><span class="p">:]</span>

        <span class="n">max_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">max_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">my</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">max_y</span><span class="p">):</span>
            <span class="n">max_x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_outlier</span><span class="p">(</span><span class="n">lpost</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">residuals</span><span class="p">,</span> <span class="n">my</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_ind</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_outlier</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">max_y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small auxiliary method that finds the index where an array has</span>
<span class="sd">        its maximum, and the corresponding value in ``xdata``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xdata : numpy.ndarray</span>
<span class="sd">            A list of independent variables</span>

<span class="sd">        ratio : Numpy.ndarray</span>
<span class="sd">            A list of dependent variables corresponding to ``xdata``</span>

<span class="sd">        max_y : float</span>
<span class="sd">            The maximum value of ``ratio``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        max_x : float</span>
<span class="sd">            The value in ``xdata`` corresponding to the entry in ``ratio`` where</span>
<span class="sd">            ``ratio == `max_y``</span>

<span class="sd">        max_ind : float</span>
<span class="sd">            The index of the entry in ``ratio`` where ``ratio == max_y``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ratio</span> <span class="o">==</span> <span class="n">max_y</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">max_x</span> <span class="o">=</span> <span class="n">xdata</span><span class="p">[</span><span class="n">max_ind</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_ind</span>

<div class="viewcode-block" id="PSDParEst.plotfits">
<a class="viewcode-back" href="../../../api.html#stingray.modeling.PSDParEst.plotfits">[docs]</a>
    <span class="k">def</span> <span class="nf">plotfits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res1</span><span class="p">,</span> <span class="n">res2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">namestr</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plotting method that allows to plot either one or two best-fit models</span>
<span class="sd">        with the data.</span>

<span class="sd">        Plots a power spectrum with the best-fit model, as well as the data/model</span>
<span class="sd">        residuals for each model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        res1 : :class:`OptimizationResults` object</span>
<span class="sd">            Output of a successful fitting procedure</span>

<span class="sd">        res2 : :class:`OptimizationResults` object, optional, default ``None``</span>
<span class="sd">            Optional output of a second successful fitting procedure, e.g. with a</span>
<span class="sd">            competing model</span>

<span class="sd">        save_plot : bool, optional, default ``False``</span>
<span class="sd">            If ``True``, the resulting figure will be saved to a file</span>

<span class="sd">        namestr : str, optional, default ``test``</span>
<span class="sd">            If ``save_plot`` is ``True``, this string defines the path and file name</span>
<span class="sd">            for the output plot</span>

<span class="sd">        log : bool, optional, default ``False``</span>
<span class="sd">            If ``True``, plot the axes logarithmically.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make a figure</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="c1"># adjust subplots such that the space between the top and bottom</span>
        <span class="c1"># of each are zero</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>

        <span class="c1"># first subplot of the grid, twice as high as the other two</span>
        <span class="c1"># This is the periodogram with the two fitted models overplotted</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">rowspan</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">logx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="n">logy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">power</span><span class="p">)</span>
            <span class="n">logpar1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">res1</span><span class="o">.</span><span class="n">mfit</span><span class="p">)</span>

            <span class="p">(</span><span class="n">p1</span><span class="p">,)</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">logy</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">drawstyle</span><span class="o">=</span><span class="s2">&quot;steps-mid&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="n">p2</span><span class="p">,)</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">logpar1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">s1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">logx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logx</span><span class="p">)])</span>
            <span class="n">s1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">logy</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logy</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;leahy&quot;</span><span class="p">:</span>
                <span class="n">s1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;log(Leahy-Normalized Power)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;rms&quot;</span><span class="p">:</span>
                <span class="n">s1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;log(RMS-Normalized Power)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;log(Power)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">p1</span><span class="p">,)</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">drawstyle</span><span class="o">=</span><span class="s2">&quot;steps-mid&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="n">p2</span><span class="p">,)</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">res1</span><span class="o">.</span><span class="n">mfit</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">s1</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
            <span class="n">s1</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>

            <span class="n">s1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">)])</span>
            <span class="n">s1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">power</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">])</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;leahy&quot;</span><span class="p">:</span>
                <span class="n">s1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Leahy-Normalized Power&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;rms&quot;</span><span class="p">:</span>
                <span class="n">s1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;RMS-Normalized Power&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">res2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="n">logpar2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">res2</span><span class="o">.</span><span class="n">mfit</span><span class="p">)</span>
                <span class="p">(</span><span class="n">p3</span><span class="p">,)</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">logpar2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">p3</span><span class="p">,)</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">res2</span><span class="o">.</span><span class="n">mfit</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">s1</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;model 1 fit&quot;</span><span class="p">,</span> <span class="s2">&quot;model 2 fit&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s1</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;model fit&quot;</span><span class="p">])</span>

        <span class="n">s1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Periodogram and fits for data set &quot;</span> <span class="o">+</span> <span class="n">namestr</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

        <span class="c1"># second subplot: power/model for Power law and straight line</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">rowspan</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pldif</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">power</span> <span class="o">/</span> <span class="n">res1</span><span class="o">.</span><span class="n">mfit</span>

        <span class="n">s2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Residuals, </span><span class="se">\n</span><span class="s2"> first model&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">pldif</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">drawstyle</span><span class="o">=</span><span class="s2">&quot;steps-mid&quot;</span><span class="p">)</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">logx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logx</span><span class="p">)])</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pldif</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pldif</span><span class="p">)])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">pldif</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">drawstyle</span><span class="o">=</span><span class="s2">&quot;steps-mid&quot;</span><span class="p">)</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">power</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">s2</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">)])</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pldif</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pldif</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">res2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bpldif</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">power</span> <span class="o">/</span> <span class="n">res2</span><span class="o">.</span><span class="n">mfit</span>

            <span class="c1"># third subplot: power/model for bent power law and straight line</span>
            <span class="n">s3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot2grid</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">rowspan</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">bpldif</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">drawstyle</span><span class="o">=</span><span class="s2">&quot;steps-mid&quot;</span><span class="p">)</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">logx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bpldif</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bpldif</span><span class="p">)])</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;log(Frequency) [Hz]&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">bpldif</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">drawstyle</span><span class="o">=</span><span class="s2">&quot;steps-mid&quot;</span><span class="p">)</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">freq</span><span class="p">)])</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bpldif</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bpldif</span><span class="p">)])</span>
                <span class="n">s3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [Hz]&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

            <span class="n">s3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Residuals, </span><span class="se">\n</span><span class="s2"> second model&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="n">s2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;log(Frequency) [Hz]&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [Hz]&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="o">+</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">():</span>
            <span class="n">label</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>

        <span class="c1"># make sure xticks are taken from first plots, but don&#39;t</span>
        <span class="c1"># appear there</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
            <span class="c1"># save figure in png file and close plot device</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">namestr</span> <span class="o">+</span> <span class="s2">&quot;_ps_fit.png&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">)</span>

        <span class="k">return</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, [{&#39;name&#39;: &#39;Stingray Developers&#39;, &#39;email&#39;: &#39;spectraltiming-stingray@googlegroups.com&#39;}].<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 8.0.2. &nbsp;
    Last built 09 Oct 2024. <br/>
  </p>
</footer>
  </body>
</html>