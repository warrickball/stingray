<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>stingray.lightcurve &#8212; stingray v</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-astropy.css?v=9d21690f" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=2afd17ea" />
    
    <script src="../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <link rel="icon" href="../../_static/stingray_logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../index.html">stingray v</a>
	 &#187;
      </li>
      <li><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for stingray.lightcurve</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Definition of :class::class:`Lightcurve`.</span>

<span class="sd">:class::class:`Lightcurve` is used to create light curves out of photon counting data</span>
<span class="sd">or to save existing light curves in a class that&#39;s easy to use.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">TimeDelta</span><span class="p">,</span> <span class="n">Time</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>

<span class="kn">from</span> <span class="nn">stingray.base</span> <span class="kn">import</span> <span class="n">StingrayTimeseries</span><span class="p">,</span> <span class="n">reduce_precision_if_extended</span>
<span class="kn">import</span> <span class="nn">stingray.utils</span> <span class="k">as</span> <span class="nn">utils</span>
<span class="kn">from</span> <span class="nn">stingray.exceptions</span> <span class="kn">import</span> <span class="n">StingrayError</span>
<span class="kn">from</span> <span class="nn">stingray.gti</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">check_gtis</span><span class="p">,</span>
    <span class="n">create_gti_mask</span><span class="p">,</span>
    <span class="n">cross_two_gtis</span><span class="p">,</span>
    <span class="n">join_gtis</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">stingray.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">assign_value_if_none</span><span class="p">,</span>
    <span class="n">baseline_als</span><span class="p">,</span>
    <span class="n">poisson_symmetrical_errors</span><span class="p">,</span>
    <span class="n">simon</span><span class="p">,</span>
    <span class="n">is_sorted</span><span class="p">,</span>
    <span class="n">check_isallfinite</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">stingray.io</span> <span class="kn">import</span> <span class="n">lcurve_from_fits</span>
<span class="kn">from</span> <span class="nn">stingray</span> <span class="kn">import</span> <span class="n">bexvar</span>
<span class="kn">from</span> <span class="nn">stingray.base</span> <span class="kn">import</span> <span class="n">interpret_times</span>
<span class="kn">from</span> <span class="nn">stingray.loggingconfig</span> <span class="kn">import</span> <span class="n">setup_logger</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Lightcurve&quot;</span><span class="p">]</span>

<span class="n">valid_statistics</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="s2">&quot;gauss&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">()</span>


<div class="viewcode-block" id="Lightcurve">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve">[docs]</a>
<span class="k">class</span> <span class="nc">Lightcurve</span><span class="p">(</span><span class="n">StingrayTimeseries</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a light curve object from an array of time stamps and an</span>
<span class="sd">    array of counts.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time: Iterable, `:class:astropy.time.Time`, or `:class:astropy.units.Quantity` object</span>
<span class="sd">        A list or array of time stamps for a light curve. Must be a type that</span>
<span class="sd">        can be cast to `:class:np.array` or `:class:List` of floats, or that</span>
<span class="sd">        has a `value` attribute that does (e.g. a</span>
<span class="sd">        `:class:astropy.units.Quantity` or `:class:astropy.time.Time` object).</span>

<span class="sd">    counts: iterable, optional, default ``None``</span>
<span class="sd">        A list or array of the counts in each bin corresponding to the</span>
<span class="sd">        bins defined in `time` (note: use ``input_counts=False`` to</span>
<span class="sd">        input the count range, i.e. counts/second, otherwise use</span>
<span class="sd">        counts/bin).</span>

<span class="sd">    err: iterable, optional, default ``None``</span>
<span class="sd">        A list or array of the uncertainties in each bin corresponding to</span>
<span class="sd">        the bins defined in ``time`` (note: use ``input_counts=False`` to</span>
<span class="sd">        input the count rage, i.e. counts/second, otherwise use</span>
<span class="sd">        counts/bin). If ``None``, we assume the data is poisson distributed</span>
<span class="sd">        and calculate the error from the average of the lower and upper</span>
<span class="sd">        1-sigma confidence intervals for the Poissonian distribution with</span>
<span class="sd">        mean equal to ``counts``.</span>

<span class="sd">    input_counts: bool, optional, default True</span>
<span class="sd">        If True, the code assumes that the input data in ``counts``</span>
<span class="sd">        is in units of counts/bin. If False, it assumes the data</span>
<span class="sd">        in ``counts`` is in counts/second.</span>

<span class="sd">    gti: 2-d float array, default ``None``</span>
<span class="sd">        ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">        Good Time Intervals. They are *not* applied to the data by default.</span>
<span class="sd">        They will be used by other methods to have an indication of the</span>
<span class="sd">        &quot;safe&quot; time intervals to use during analysis.</span>

<span class="sd">    err_dist: str, optional, default ``None``</span>
<span class="sd">        Statistical distribution used to calculate the</span>
<span class="sd">        uncertainties and other statistical values appropriately.</span>
<span class="sd">        Default makes no assumptions and keep errors equal to zero.</span>

<span class="sd">    bg_counts: iterable,`:class:numpy.array` or `:class:List` of floats, optional, default ``None``</span>
<span class="sd">        A list or array of background counts detected in the background extraction region</span>
<span class="sd">        in each bin corresponding to the bins defined in `time`.</span>

<span class="sd">    bg_ratio: iterable, `:class:numpy.array` or `:class:List` of floats, optional, default ``None``</span>
<span class="sd">        A list or array of source region area to background region area ratio in each bin. These are</span>
<span class="sd">        factors by which the `bg_counts` should be scaled to estimate background counts within the</span>
<span class="sd">        source aperture.</span>

<span class="sd">    frac_exp: iterable, `:class:numpy.array` or `:class:List` of floats, optional, default ``None``</span>
<span class="sd">        A list or array of fractional exposers in each bin.</span>

<span class="sd">    mjdref: float</span>
<span class="sd">        MJD reference (useful in most high-energy mission data)</span>

<span class="sd">    dt: float or array of floats. Default median(diff(time))</span>
<span class="sd">        Time resolution of the light curve. Can be an array of the same dimension</span>
<span class="sd">        as ``time`` specifying width of each bin.</span>

<span class="sd">    skip_checks: bool</span>
<span class="sd">        If True, the user specifies that data are already sorted and contain no</span>
<span class="sd">        infinite or nan points. Use at your own risk</span>

<span class="sd">    low_memory: bool</span>
<span class="sd">        If True, all the lazily evaluated attribute (e.g., countrate and</span>
<span class="sd">        countrate_err if input_counts is True) will _not_ be stored in memory,</span>
<span class="sd">        but calculated every time they are requested.</span>

<span class="sd">    mission : str</span>
<span class="sd">        Mission that recorded the data (e.g. NICER)</span>

<span class="sd">    instr : str</span>
<span class="sd">        Instrument onboard the mission</span>

<span class="sd">    header : str</span>
<span class="sd">        The full header of the original FITS file, if relevant</span>

<span class="sd">    **other_kw :</span>
<span class="sd">        Used internally. Any other keyword arguments will be ignored</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    time: numpy.ndarray</span>
<span class="sd">        The array of midpoints of time bins.</span>

<span class="sd">    bin_lo: numpy.ndarray</span>
<span class="sd">        The array of lower time stamp of time bins.</span>

<span class="sd">    bin_hi: numpy.ndarray</span>
<span class="sd">        The array of higher time stamp of time bins.</span>

<span class="sd">    counts: numpy.ndarray</span>
<span class="sd">        The counts per bin corresponding to the bins in ``time``.</span>

<span class="sd">    counts_err: numpy.ndarray</span>
<span class="sd">        The uncertainties corresponding to ``counts``</span>

<span class="sd">    bg_counts: numpy.ndarray</span>
<span class="sd">        The background counts corresponding to the bins in `time`.</span>

<span class="sd">    bg_ratio: numpy.ndarray</span>
<span class="sd">        The ratio of source region area to background region area corresponding to each bin.</span>

<span class="sd">    frac_exp: numpy.ndarray</span>
<span class="sd">        The fractional exposers in each bin.</span>

<span class="sd">    countrate: numpy.ndarray</span>
<span class="sd">        The counts per second in each of the bins defined in ``time``.</span>

<span class="sd">    countrate_err: numpy.ndarray</span>
<span class="sd">        The uncertainties corresponding to ``countrate``</span>

<span class="sd">    meanrate: float</span>
<span class="sd">        The mean count rate of the light curve.</span>

<span class="sd">    meancounts: float</span>
<span class="sd">        The mean counts of the light curve.</span>

<span class="sd">    n: int</span>
<span class="sd">        The number of data points in the light curve.</span>

<span class="sd">    dt: float or array of floats</span>
<span class="sd">        The time resolution of the light curve.</span>

<span class="sd">    mjdref: float</span>
<span class="sd">        MJD reference date (``tstart`` / 86400 gives the date in MJD at the</span>
<span class="sd">        start of the observation)</span>

<span class="sd">    tseg: float</span>
<span class="sd">        The total duration of the light curve.</span>

<span class="sd">    tstart: float</span>
<span class="sd">        The start time of the light curve.</span>

<span class="sd">    gti: 2-d float array</span>
<span class="sd">        ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">        Good Time Intervals. They indicate the &quot;safe&quot; time intervals</span>
<span class="sd">        to be used during the analysis of the light curve.</span>

<span class="sd">    err_dist: string</span>
<span class="sd">        Statistic of the Lightcurve, it is used to calculate the</span>
<span class="sd">        uncertainties and other statistical values appropriately.</span>
<span class="sd">        It propagates to Spectrum classes.</span>

<span class="sd">    mission : str</span>
<span class="sd">        Mission that recorded the data (e.g. NICER)</span>

<span class="sd">    instr : str</span>
<span class="sd">        Instrument onboard the mission</span>

<span class="sd">    detector_id : iterable</span>
<span class="sd">        The detector that recoded each photon, if relevant (e.g. XMM, Chandra)</span>

<span class="sd">    header : str</span>
<span class="sd">        The full header of the original FITS file, if relevant</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">main_array_attr</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">input_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">gti</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">err_dist</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span>
        <span class="n">bg_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bg_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">frac_exp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mjdref</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">skip_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mission</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">instr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">other_kw</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_countrate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_countrate_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meanrate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meancounts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_lo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_hi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">StingrayTimeseries</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other_kw</span> <span class="o">!=</span> <span class="p">{}:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized keywords: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">other_kw</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mission</span> <span class="o">=</span> <span class="n">mission</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instr</span> <span class="o">=</span> <span class="n">instr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_counts</span> <span class="o">=</span> <span class="n">input_counts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_memory</span> <span class="o">=</span> <span class="n">low_memory</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">=</span> <span class="n">mjdref</span>

        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">counts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">StingrayError</span><span class="p">(</span>
                <span class="s2">&quot;Empty or invalid counts array. Time and counts array should have the same length.&quot;</span>
                <span class="s2">&quot;If you are providing event data, please use Lightcurve.make_lightcurve()&quot;</span>
            <span class="p">)</span>

        <span class="n">time</span><span class="p">,</span> <span class="n">mjdref</span> <span class="o">=</span> <span class="n">interpret_times</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">mjdref</span><span class="o">=</span><span class="n">mjdref</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">=</span> <span class="n">mjdref</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_checks</span><span class="p">:</span>
            <span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_optional_checks</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">gti</span><span class="o">=</span><span class="n">gti</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">err_dist</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_statistics</span><span class="p">:</span>
            <span class="c1"># err_dist set can be increased with other statistics</span>
            <span class="k">raise</span> <span class="n">StingrayError</span><span class="p">(</span>
                <span class="s2">&quot;Statistic not recognized.&quot;</span> <span class="s2">&quot;Please select one of these: &quot;</span><span class="p">,</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">valid_statistics</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">err_dist</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
            <span class="n">simon</span><span class="p">(</span>
                <span class="s2">&quot;Stingray only uses poisson err_dist at the moment. &quot;</span>
                <span class="s2">&quot;All analysis in the light curve will assume Poisson &quot;</span>
                <span class="s2">&quot;errors. &quot;</span>
                <span class="s2">&quot;Sorry for the inconvenience.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">time</span>

        <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Computing the bin time ``dt``. This can take &quot;</span>
                <span class="s2">&quot;time. If you know the bin time, please specify it&quot;</span>
                <span class="s2">&quot; at light curve creation&quot;</span>
            <span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Only one time bin and no dt specified. Setting dt=1. &quot;</span>
                <span class="s2">&quot;Please specify dt if you want to use a different value&quot;</span>
            <span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Some functionalities of Stingray Lightcurve will not work when `dt` is Iterable&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">err_dist</span> <span class="o">=</span> <span class="n">err_dist</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">gti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;nt&quot;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;On Windows, the size of an integer is 32 bits. &quot;</span>
                <span class="s2">&quot;To avoid integer overflow, I&#39;m converting the input array to float&quot;</span>
            <span class="p">)</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">input_counts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span> <span class="o">=</span> <span class="n">err</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_countrate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_countrate_err</span> <span class="o">=</span> <span class="n">err</span>

        <span class="k">if</span> <span class="n">bg_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bg_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">bg_counts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bg_counts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">bg_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bg_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">bg_ratio</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bg_ratio</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">frac_exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frac_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">frac_exp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frac_exp</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_checks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_lightcurve</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

    <span class="nd">@time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_and_format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_array_attrs</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_lo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_hi</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meanrate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meanrate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meanrate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">countrate</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meanrate</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meancounts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meancounts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meancounts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meancounts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_countrate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_countrate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
            <span class="c1"># If not in low-memory regime, cache the values</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_memory</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_counts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="o">=</span> <span class="n">counts</span>

        <span class="k">return</span> <span class="n">counts</span>

    <span class="nd">@counts</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_and_format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_countrate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meancounts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meancountrate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_counts</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">counts_err</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">counts_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span>
        <span class="k">if</span> <span class="n">counts_err</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_countrate_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">counts_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_countrate_err</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">elif</span> <span class="n">counts_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_dist</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
                <span class="n">counts_err</span> <span class="o">=</span> <span class="n">poisson_symmetrical_errors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">counts_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>

        <span class="c1"># If not in low-memory regime, cache the values ONLY if they have</span>
        <span class="c1"># been changed!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">counts_err</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_memory</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_counts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span> <span class="o">=</span> <span class="n">counts_err</span>

        <span class="k">return</span> <span class="n">counts_err</span>

    <span class="nd">@counts_err</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">counts_err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_and_format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;counts_err&quot;</span><span class="p">,</span> <span class="s2">&quot;counts&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_countrate_err</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">countrate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">countrate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_countrate</span>
        <span class="k">if</span> <span class="n">countrate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">countrate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
            <span class="c1"># If not in low-memory regime, cache the values</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_memory</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_counts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_countrate</span> <span class="o">=</span> <span class="n">countrate</span>

        <span class="k">return</span> <span class="n">countrate</span>

    <span class="nd">@countrate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">countrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_and_format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;countrate&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_countrate</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meancounts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meancountrate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_counts</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">countrate_err</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">countrate_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_countrate_err</span>
        <span class="k">if</span> <span class="n">countrate_err</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">countrate_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">elif</span> <span class="n">countrate_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">countrate_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>

        <span class="c1"># If not in low-memory regime, cache the values ONLY if they have</span>
        <span class="c1"># been changed!</span>
        <span class="k">if</span> <span class="n">countrate_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_countrate_err</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_memory</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_counts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_countrate_err</span> <span class="o">=</span> <span class="n">countrate_err</span>

        <span class="k">return</span> <span class="n">countrate_err</span>

    <span class="nd">@countrate_err</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">countrate_err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_and_format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;countrate_err&quot;</span><span class="p">,</span> <span class="s2">&quot;countrate&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_countrate_err</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_lo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_lo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bin_lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_lo</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_hi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_hi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bin_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_hi</span>

    <span class="k">def</span> <span class="nf">initial_optional_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">gti</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Checking if light curve is well behaved. This &quot;</span>
            <span class="s2">&quot;can take time, so if you are sure it is already &quot;</span>
            <span class="s2">&quot;sorted, specify skip_checks=True at light curve &quot;</span>
            <span class="s2">&quot;creation.&quot;</span>
        <span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">gti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">create_gti_mask</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Check if there are non-finite values in the light curve</span>
        <span class="c1"># This will result in a warning if GTIs are defined and non-finite points</span>
        <span class="c1"># are outside the GTIs, otherwise an error.</span>
        <span class="c1"># To do this, we use this ``nonfinite_flag`` variable and a ``nonfinite`` list.</span>
        <span class="c1"># This list will contain all arrays with non-finite points inside GTIs.</span>
        <span class="c1"># If the nonfinite_flag is True but the nonfinite list is empty, then there are no non-finite</span>
        <span class="c1"># points in the GTIs.</span>
        <span class="n">nonfinite_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">nonfinite</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">arr</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">err</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="s2">&quot;err&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_isallfinite</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="n">nonfinite_flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">check_isallfinite</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mask</span><span class="p">])):</span>
                    <span class="n">nonfinite</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonfinite</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nonfinite</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nonfinite values inside GTIs in </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nonfinite_flag</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;There are non-finite points in the data, but they are outside GTIs. &quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Checking if light curve is sorted.&quot;</span><span class="p">)</span>
        <span class="n">unsorted</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">is_sorted</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unsorted</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The light curve is unsorted.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">err</span>

<div class="viewcode-block" id="Lightcurve.check_lightcurve">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.check_lightcurve">[docs]</a>
    <span class="k">def</span> <span class="nf">check_lightcurve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make various checks on the lightcurve.</span>

<span class="sd">        It can be slow, use it if you are not sure about your</span>
<span class="sd">        input data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Issue a warning if the input time iterable isn&#39;t regularly spaced,</span>
        <span class="c1"># i.e. the bin sizes aren&#39;t equal throughout.</span>

        <span class="n">check_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span>
        <span class="n">uneven</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">uneven</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idxs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">istart</span><span class="p">,</span> <span class="n">istop</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">idxs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">local_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">istart</span><span class="p">:</span><span class="n">istop</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">local_diff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)):</span>
                    <span class="n">uneven</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">uneven</span><span class="p">:</span>
            <span class="n">simon</span><span class="p">(</span>
                <span class="s2">&quot;Bin sizes in input time array aren&#39;t equal throughout! &quot;</span>
                <span class="s2">&quot;This could cause problems with Fourier transforms. &quot;</span>
                <span class="s2">&quot;Please make the input time evenly sampled.&quot;</span>
                <span class="s2">&quot;Only use with LombScargleCrossspectrum, LombScarglePowerspectrum and QPO using GPResult&quot;</span>
            <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_operation_with_other_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">operation</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to codify an operation of one light curve with another (e.g. add, subtract, ...).</span>
<span class="sd">        Takes into account the GTIs correctly, and returns a new :class:`Lightcurve` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`Lightcurve` object</span>
<span class="sd">            A second light curve object</span>

<span class="sd">        operation : function</span>
<span class="sd">            An operation between the :class:`Lightcurve` object calling this method, and ``other``,</span>
<span class="sd">            operating on the ``counts`` attribute in each :class:`Lightcurve` object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc_new : Lightcurve object</span>
<span class="sd">            The new light curve calculated in ``operation``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">mjdref</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;MJDref is different in the two light curves&quot;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">change_mjdref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">)</span>

        <span class="n">common_gti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">common_gti</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The good time intervals in the two time series are different. Data outside the &quot;</span>
                <span class="s2">&quot;common GTIs will be discarded.&quot;</span>
            <span class="p">)</span>
        <span class="n">mask_self</span> <span class="o">=</span> <span class="n">create_gti_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">common_gti</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">mask_other</span> <span class="o">=</span> <span class="n">create_gti_mask</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">common_gti</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>

        <span class="c1"># ValueError is raised by Numpy while asserting np.equal over arrays</span>
        <span class="c1"># with different dimensions.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">mask_self</span><span class="p">]</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">mask_other</span><span class="p">]))</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;GTI-filtered time arrays of both light curves &quot;</span>
                <span class="s2">&quot;must be of same dimension and equal.&quot;</span>
            <span class="p">)</span>

        <span class="n">new_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">mask_self</span><span class="p">]</span>
        <span class="n">new_counts</span> <span class="o">=</span> <span class="n">operation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">mask_self</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">mask_other</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_dist</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">err_dist</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">simon</span><span class="p">(</span>
                <span class="s2">&quot;Lightcurves have different statistics!&quot;</span>
                <span class="s2">&quot;We are setting the errors to zero to avoid complications.&quot;</span>
            <span class="p">)</span>
            <span class="n">new_counts_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_counts</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_dist</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">valid_statistics</span><span class="p">:</span>
            <span class="n">new_counts_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts_err</span><span class="p">[</span><span class="n">mask_self</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">counts_err</span><span class="p">[</span><span class="n">mask_other</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># More conditions can be implemented for other statistics</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">StingrayError</span><span class="p">(</span>
                <span class="s2">&quot;Statistics not recognized.&quot;</span>
                <span class="s2">&quot; Please use one of these: &quot;</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">valid_statistics</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">lc_new</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span>
            <span class="n">new_time</span><span class="p">,</span>
            <span class="n">new_counts</span><span class="p">,</span>
            <span class="n">err</span><span class="o">=</span><span class="n">new_counts_err</span><span class="p">,</span>
            <span class="n">gti</span><span class="o">=</span><span class="n">common_gti</span><span class="p">,</span>
            <span class="n">mjdref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span>
            <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">lc_new</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the counts of two light curves element by element, assuming the light curves</span>
<span class="sd">        have the same time array.</span>

<span class="sd">        This magic method adds two :class:`Lightcurve` objects having the same time</span>
<span class="sd">        array such that the corresponding counts arrays get summed up.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [5, 10, 15]</span>
<span class="sd">        &gt;&gt;&gt; count1 = [300, 100, 400]</span>
<span class="sd">        &gt;&gt;&gt; count2 = [600, 1200, 800]</span>
<span class="sd">        &gt;&gt;&gt; gti1 = [[0, 20]]</span>
<span class="sd">        &gt;&gt;&gt; gti2 = [[0, 25]]</span>
<span class="sd">        &gt;&gt;&gt; lc1 = Lightcurve(time, count1, gti=gti1, dt=5)</span>
<span class="sd">        &gt;&gt;&gt; lc2 = Lightcurve(time, count2, gti=gti2, dt=5)</span>
<span class="sd">        &gt;&gt;&gt; lc = lc1 + lc2</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(lc.counts, [ 900, 1300, 1200])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract the counts/flux of one light curve from the counts/flux of another</span>
<span class="sd">        light curve element by element, assuming the ``time`` arrays of the light curves</span>
<span class="sd">        match exactly.</span>

<span class="sd">        This magic method takes two :class:`Lightcurve` objects having the same</span>
<span class="sd">        ``time`` array and subtracts the ``counts`` of one :class:`Lightcurve` with</span>
<span class="sd">        that of another, while also updating ``countrate``, ``counts_err`` and ``countrate_err``</span>
<span class="sd">        correctly.</span>

<span class="sd">        GTIs are crossed, so that only common intervals are saved.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [10, 20, 30]</span>
<span class="sd">        &gt;&gt;&gt; count1 = [600, 1200, 800]</span>
<span class="sd">        &gt;&gt;&gt; count2 = [300, 100, 400]</span>
<span class="sd">        &gt;&gt;&gt; gti1 = [[0, 35]]</span>
<span class="sd">        &gt;&gt;&gt; gti2 = [[0, 35]]</span>
<span class="sd">        &gt;&gt;&gt; lc1 = Lightcurve(time, count1, gti=gti1, dt=10)</span>
<span class="sd">        &gt;&gt;&gt; lc2 = Lightcurve(time, count2, gti=gti2, dt=10)</span>
<span class="sd">        &gt;&gt;&gt; lc = lc1 - lc2</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(lc.counts, [ 300, 1100,  400])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operation_with_other_obj</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement the behavior of negation of the light curve objects.</span>

<span class="sd">        The negation operator ``-`` is supposed to invert the sign of the count</span>
<span class="sd">        values of a light curve object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; count1 = [100, 200, 300]</span>
<span class="sd">        &gt;&gt;&gt; count2 = [200, 300, 400]</span>
<span class="sd">        &gt;&gt;&gt; lc1 = Lightcurve(time, count1)</span>
<span class="sd">        &gt;&gt;&gt; lc2 = Lightcurve(time, count2)</span>
<span class="sd">        &gt;&gt;&gt; lc_new = -lc1 + lc2</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(lc_new.counts, [100, 100, 100])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lc_new</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span>
            <span class="n">err</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">counts_err</span><span class="p">,</span>
            <span class="n">gti</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span>
            <span class="n">mjdref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span>
            <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">lc_new</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the corresponding count value at the index or a new :class:`Lightcurve`</span>
<span class="sd">        object upon slicing.</span>

<span class="sd">        This method adds functionality to retrieve the count value at</span>
<span class="sd">        a particular index. This also can be used for slicing and generating</span>
<span class="sd">        a new :class:`Lightcurve` object. GTIs are recalculated based on the new light</span>
<span class="sd">        curve segment</span>

<span class="sd">        If the slice object is of kind ``start:stop:step``, GTIs are also sliced,</span>
<span class="sd">        and rewritten as ``zip(time - self.dt /2, time + self.dt / 2)``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or slice instance</span>
<span class="sd">            Index value of the time array or a slice object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; count = [11, 22, 33, 44, 55, 66, 77, 88, 99]</span>
<span class="sd">        &gt;&gt;&gt; lc = Lightcurve(time, count, dt=1)</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(lc[2], 33)</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(lc[:2].counts, [11, 22])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">))</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">new_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
            <span class="n">new_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>

            <span class="n">new_gti</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">]]</span>
            <span class="n">new_gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">new_gti</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_gt1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">new_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">new_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>
                <span class="n">new_gti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="n">new_gti</span><span class="p">,</span> <span class="n">new_gt1</span><span class="p">)</span>
            <span class="n">new_gti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">new_gti</span><span class="p">)</span>

            <span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span>
                <span class="n">new_time</span><span class="p">,</span>
                <span class="n">new_counts</span><span class="p">,</span>
                <span class="n">mjdref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span>
                <span class="n">gti</span><span class="o">=</span><span class="n">new_gti</span><span class="p">,</span>
                <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
                <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">err_dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">err_dist</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lc</span><span class="o">.</span><span class="n">_counts_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts_err</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">lc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The index must be either an integer or a slice &quot;</span> <span class="s2">&quot;object !&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Lightcurve.baseline">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.baseline">[docs]</a>
    <span class="k">def</span> <span class="nf">baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">offset_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the baseline of the light curve, accounting for GTIs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lam : float</span>
<span class="sd">            &quot;smoothness&quot; parameter. Larger values make the baseline stiffer</span>
<span class="sd">            Typically ``1e2 &lt; lam &lt; 1e9``</span>
<span class="sd">        p : float</span>
<span class="sd">            &quot;asymmetry&quot; parameter. Smaller values make the baseline more</span>
<span class="sd">            &quot;horizontal&quot;. Typically ``0.001 &lt; p &lt; 0.1``, but not necessary.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        offset_correction : bool, default False</span>
<span class="sd">            by default, this method does not align to the running mean of the</span>
<span class="sd">            light curve, but it goes below the light curve. Setting align to</span>
<span class="sd">            True, an additional step is done to shift the baseline so that it</span>
<span class="sd">            is shifted to the middle of the light curve noise distribution.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        baseline : numpy.ndarray</span>
<span class="sd">            An array with the baseline of the light curve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">:</span>
            <span class="n">good</span> <span class="o">=</span> <span class="n">create_gti_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="n">g</span><span class="p">],</span> <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">baseline</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">baseline_als</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">good</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">good</span><span class="p">],</span>
                <span class="n">lam</span><span class="p">,</span>
                <span class="n">p</span><span class="p">,</span>
                <span class="n">niter</span><span class="p">,</span>
                <span class="n">offset_correction</span><span class="o">=</span><span class="n">offset_correction</span><span class="p">,</span>
                <span class="n">return_baseline</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">baseline</span></div>


<div class="viewcode-block" id="Lightcurve.make_lightcurve">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.make_lightcurve">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">make_lightcurve</span><span class="p">(</span><span class="n">toa</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gti</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mjdref</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_hist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a light curve out of photon arrival times, with a given time resolution ``dt``.</span>
<span class="sd">        Note that ``dt`` should be larger than the native time resolution of the instrument</span>
<span class="sd">        that has taken the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        toa: iterable</span>
<span class="sd">            list of photon arrival times</span>

<span class="sd">        dt: float</span>
<span class="sd">            time resolution of the light curve (the bin width)</span>

<span class="sd">        tseg: float, optional, default ``None``</span>
<span class="sd">            The total duration of the light curve.</span>
<span class="sd">            If this is ``None``, then the total duration of the light curve will</span>
<span class="sd">            be the interval between the arrival between either the first and the last</span>
<span class="sd">            gti boundary or, if gti is not set, the first and the last photon in ``toa``.</span>

<span class="sd">                **Note**: If ``tseg`` is not divisible by ``dt`` (i.e. if ``tseg``/``dt`` is</span>
<span class="sd">                not an integer number), then the last fractional bin will be</span>
<span class="sd">                dropped!</span>

<span class="sd">        tstart: float, optional, default ``None``</span>
<span class="sd">            The start time of the light curve.</span>
<span class="sd">            If this is ``None``, either the first gti boundary or, if not available,</span>
<span class="sd">            the arrival time of the first photon will be used</span>
<span class="sd">            as the start time of the light curve.</span>

<span class="sd">        gti: 2-d float array</span>
<span class="sd">            ``[[gti0_0, gti0_1], [gti1_0, gti1_1], ...]``</span>
<span class="sd">            Good Time Intervals</span>

<span class="sd">        use_hist : bool</span>
<span class="sd">            Use ``np.histogram`` instead of ``np.bincounts``. Might be advantageous</span>
<span class="sd">            for very short datasets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc: :class:`Lightcurve` object</span>
<span class="sd">            A :class:`Lightcurve` object with the binned light curve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">toa</span><span class="p">,</span> <span class="n">mjdref</span> <span class="o">=</span> <span class="n">interpret_times</span><span class="p">(</span><span class="n">toa</span><span class="p">,</span> <span class="n">mjdref</span><span class="o">=</span><span class="n">mjdref</span><span class="p">)</span>

        <span class="n">toa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">toa</span><span class="p">))</span>
        <span class="c1"># tstart is an optional parameter to set a starting time for</span>
        <span class="c1"># the light curve in case this does not coincide with the first photon</span>
        <span class="k">if</span> <span class="n">tstart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if tstart is not set, assume light curve starts with first photon</span>
            <span class="c1"># or the first gti if is set</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">toa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">gti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span>

        <span class="c1"># compute the number of bins in the light curve</span>
        <span class="c1"># for cases where tseg/dt is not integer.</span>
        <span class="c1"># TODO: check that this is always consistent and that we</span>
        <span class="c1"># are not throwing away good events.</span>
        <span class="k">if</span> <span class="n">tseg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tseg</span> <span class="o">=</span> <span class="n">toa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tstart</span>
            <span class="k">if</span> <span class="n">gti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gti</span><span class="p">)</span> <span class="o">-</span> <span class="n">tstart</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;make_lightcurve: tseg: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tseg</span><span class="p">))</span>

        <span class="n">timebin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tseg</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
        <span class="c1"># If we are missing the next bin by just 1%, let&#39;s round up:</span>
        <span class="k">if</span> <span class="n">tseg</span> <span class="o">/</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">timebin</span> <span class="o">&gt;=</span> <span class="mf">0.99</span><span class="p">:</span>
            <span class="n">timebin</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;make_lightcurve: timebin:  &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">timebin</span><span class="p">))</span>

        <span class="n">tend</span> <span class="o">=</span> <span class="n">tstart</span> <span class="o">+</span> <span class="n">timebin</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">good</span> <span class="o">=</span> <span class="p">(</span><span class="n">tstart</span> <span class="o">&lt;=</span> <span class="n">toa</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">toa</span> <span class="o">&lt;</span> <span class="n">tend</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_hist</span><span class="p">:</span>
            <span class="n">binned_toas</span> <span class="o">=</span> <span class="p">((</span><span class="n">toa</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span> <span class="o">//</span> <span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">binned_toas</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">timebin</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">tstart</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">))</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">histbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span> <span class="o">+</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
            <span class="n">counts</span><span class="p">,</span> <span class="n">histbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">toa</span><span class="p">[</span><span class="n">good</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">histbins</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">histbins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span>

        <span class="k">return</span> <span class="n">Lightcurve</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">gti</span><span class="o">=</span><span class="n">gti</span><span class="p">,</span> <span class="n">mjdref</span><span class="o">=</span><span class="n">mjdref</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">err_dist</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.rebin">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.rebin">[docs]</a>
    <span class="k">def</span> <span class="nf">rebin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt_new</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rebin the light curve to a new time resolution. While the new</span>
<span class="sd">        resolution need not be an integer multiple of the previous time</span>
<span class="sd">        resolution, be aware that if it is not, the last bin will be cut</span>
<span class="sd">        off by the fraction left over by the integer division.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt_new: float</span>
<span class="sd">            The new time resolution of the light curve. Must be larger than</span>
<span class="sd">            the time resolution of the old light curve!</span>

<span class="sd">        method: {``sum`` | ``mean`` | ``average``}, optional, default ``sum``</span>
<span class="sd">            This keyword argument sets whether the counts in the new bins</span>
<span class="sd">            should be summed or averaged.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        f: float</span>
<span class="sd">            the rebin factor. If specified, it substitutes ``dt_new`` with</span>
<span class="sd">            ``f*self.dt``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc_new: :class:`Lightcurve` object</span>
<span class="sd">            The :class:`Lightcurve` object with the new, binned light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt_new</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to specify at least one between f and &quot;</span> <span class="s2">&quot;dt_new&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt_new</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>

        <span class="k">if</span> <span class="n">dt_new</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;New time resolution must be larger than &quot;</span> <span class="s2">&quot;old time resolution!&quot;</span><span class="p">)</span>

        <span class="n">bin_time</span><span class="p">,</span> <span class="n">bin_counts</span><span class="p">,</span> <span class="n">bin_err</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">gti_new</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># If it does not exist, we create it on the spot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts_err</span>

        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dt_new</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># find start and end of GTI segment in data</span>
                <span class="n">start_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">end_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="n">t_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">end_ind</span><span class="p">]</span>
                <span class="n">c_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">end_ind</span><span class="p">]</span>

                <span class="n">e_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts_err</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">end_ind</span><span class="p">]</span>

                <span class="n">bin_t</span><span class="p">,</span> <span class="n">bin_c</span><span class="p">,</span> <span class="n">bin_e</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">rebin_data</span><span class="p">(</span>
                    <span class="n">t_temp</span><span class="p">,</span> <span class="n">c_temp</span><span class="p">,</span> <span class="n">dt_new</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">e_temp</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span>
                <span class="p">)</span>

                <span class="n">bin_time</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bin_t</span><span class="p">)</span>
                <span class="n">bin_counts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bin_c</span><span class="p">)</span>
                <span class="n">bin_err</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bin_e</span><span class="p">)</span>
                <span class="n">gti_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gti_new</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid GTIs after rebin.&quot;</span><span class="p">)</span>

        <span class="n">lc_new</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span>
            <span class="n">bin_time</span><span class="p">,</span>
            <span class="n">bin_counts</span><span class="p">,</span>
            <span class="n">err</span><span class="o">=</span><span class="n">bin_err</span><span class="p">,</span>
            <span class="n">mjdref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span>
            <span class="n">dt</span><span class="o">=</span><span class="n">dt_new</span><span class="p">,</span>
            <span class="n">gti</span><span class="o">=</span><span class="n">gti_new</span><span class="p">,</span>
            <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">lc_new</span></div>


<div class="viewcode-block" id="Lightcurve.join">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.join">[docs]</a>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join two lightcurves into a single object.</span>

<span class="sd">        The new :class:`Lightcurve` object will contain time stamps from both the</span>
<span class="sd">        objects. The ``counts`` and ``countrate`` attributes in the resulting object</span>
<span class="sd">        will contain the union of the non-overlapping parts of the two individual objects,</span>
<span class="sd">        or the average in case of overlapping ``time`` arrays of both :class:`Lightcurve` objects.</span>

<span class="sd">        Good Time Intervals are also joined.</span>

<span class="sd">        Note : Ideally, the ``time`` array of both lightcurves should not overlap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`Lightcurve` object</span>
<span class="sd">            The other :class:`Lightcurve` object which is supposed to be joined with.</span>
<span class="sd">        skip_checks: bool</span>
<span class="sd">            If True, the user specifies that data are already sorted and</span>
<span class="sd">            contain no infinite or nan points. Use at your own risk.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc_new : :class:`Lightcurve` object</span>
<span class="sd">            The resulting :class:`Lightcurve` object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time1 = [5, 10, 15]</span>
<span class="sd">        &gt;&gt;&gt; count1 = [300, 100, 400]</span>
<span class="sd">        &gt;&gt;&gt; time2 = [20, 25, 30]</span>
<span class="sd">        &gt;&gt;&gt; count2 = [600, 1200, 800]</span>
<span class="sd">        &gt;&gt;&gt; lc1 = Lightcurve(time1, count1, dt=5)</span>
<span class="sd">        &gt;&gt;&gt; lc2 = Lightcurve(time2, count2, dt=5)</span>
<span class="sd">        &gt;&gt;&gt; lc = lc1.join(lc2)</span>
<span class="sd">        &gt;&gt;&gt; lc.time</span>
<span class="sd">        array([ 5, 10, 15, 20, 25, 30])</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(lc.counts, [ 300,  100,  400,  600, 1200,  800])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">mjdref</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;MJDref is different in the two light curves&quot;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">change_mjdref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dt</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">simon</span><span class="p">(</span><span class="s2">&quot;The two light curves have different bin widths.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">tstart</span><span class="p">:</span>
            <span class="n">first_lc</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">second_lc</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_lc</span> <span class="o">=</span> <span class="n">other</span>
            <span class="n">second_lc</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">simon</span><span class="p">(</span>
                <span class="s2">&quot;The two light curves have overlapping time ranges. &quot;</span>
                <span class="s2">&quot;In the common time range, the resulting count will &quot;</span>
                <span class="s2">&quot;be the average of the counts in the two light &quot;</span>
                <span class="s2">&quot;curves. If you wish to sum, use `lc_sum = lc1 + &quot;</span>
                <span class="s2">&quot;lc2`.&quot;</span>
            <span class="p">)</span>
            <span class="n">valid_err</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_dist</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">err_dist</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">simon</span><span class="p">(</span><span class="s2">&quot;Lightcurves have different statistics!&quot;</span> <span class="s2">&quot;We are setting the errors to zero.&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_dist</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">valid_statistics</span><span class="p">:</span>
                <span class="n">valid_err</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># More conditions can be implemented for other statistics</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">StingrayError</span><span class="p">(</span>
                    <span class="s2">&quot;Statistics not recognized.&quot;</span>
                    <span class="s2">&quot; Please use one of these: &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">valid_statistics</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

            <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
            <span class="n">counts_err</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">first_lc</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_lc</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">counts_err</span><span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_lc</span><span class="o">.</span><span class="n">counts_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">second_lc</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Common time</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">+</span> <span class="n">second_lc</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">counts_err</span><span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="p">((</span><span class="n">counts_err</span><span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">second_lc</span><span class="o">.</span><span class="n">counts_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_lc</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">counts_err</span><span class="p">[</span><span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_lc</span><span class="o">.</span><span class="n">counts_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">new_time</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">new_counts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">valid_err</span><span class="p">:</span>
                <span class="n">new_counts_err</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">counts_err</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_counts_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_counts</span><span class="p">)</span>

            <span class="k">del</span> <span class="p">[</span><span class="n">counts</span><span class="p">,</span> <span class="n">counts_err</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">first_lc</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">second_lc</span><span class="o">.</span><span class="n">time</span><span class="p">])</span>
            <span class="n">new_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">first_lc</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="n">second_lc</span><span class="o">.</span><span class="n">counts</span><span class="p">])</span>
            <span class="n">new_counts_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">first_lc</span><span class="o">.</span><span class="n">counts_err</span><span class="p">,</span> <span class="n">second_lc</span><span class="o">.</span><span class="n">counts_err</span><span class="p">])</span>

        <span class="n">new_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">new_time</span><span class="p">)</span>
        <span class="n">new_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">new_counts</span><span class="p">)</span>
        <span class="n">new_counts_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">new_counts_err</span><span class="p">)</span>
        <span class="n">gti</span> <span class="o">=</span> <span class="n">join_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span>

        <span class="n">lc_new</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span>
            <span class="n">new_time</span><span class="p">,</span>
            <span class="n">new_counts</span><span class="p">,</span>
            <span class="n">err</span><span class="o">=</span><span class="n">new_counts_err</span><span class="p">,</span>
            <span class="n">gti</span><span class="o">=</span><span class="n">gti</span><span class="p">,</span>
            <span class="n">mjdref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span>
            <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
            <span class="n">skip_checks</span><span class="o">=</span><span class="n">skip_checks</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">lc_new</span></div>


<div class="viewcode-block" id="Lightcurve.truncate">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.truncate">[docs]</a>
    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncate a :class:`Lightcurve` object.</span>

<span class="sd">        This method takes a ``start`` and a ``stop`` point (either as indices,</span>
<span class="sd">        or as times in the same unit as those in the ``time`` attribute, and truncates</span>
<span class="sd">        all bins before ``start`` and after ``stop``, then returns a new :class:`Lightcurve`</span>
<span class="sd">        object with the truncated light curve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, default 0</span>
<span class="sd">            Index (or time stamp) of the starting point of the truncation. If no value is set</span>
<span class="sd">            for the start point, then all points from the first element in the ``time`` array</span>
<span class="sd">            are taken into account.</span>

<span class="sd">        stop : int, default ``None``</span>
<span class="sd">            Index (or time stamp) of the ending point (exclusive) of the truncation. If no</span>
<span class="sd">            value of stop is set, then points including the last point in</span>
<span class="sd">            the counts array are taken in count.</span>

<span class="sd">        method : {``index`` | ``time``}, optional, default ``index``</span>
<span class="sd">            Type of the start and stop values. If set to ``index`` then</span>
<span class="sd">            the values are treated as indices of the counts array, or</span>
<span class="sd">            if set to ``time``, the values are treated as actual time values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc_new: :class:`Lightcurve` object</span>
<span class="sd">            The :class:`Lightcurve` object with truncated time and counts</span>
<span class="sd">            arrays.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; count = [10, 20, 30, 40, 50, 60, 70, 80, 90]</span>
<span class="sd">        &gt;&gt;&gt; lc = Lightcurve(time, count, dt=1)</span>
<span class="sd">        &gt;&gt;&gt; lc_new = lc.truncate(start=2, stop=8)</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(lc_new.counts, [30, 40, 50, 60, 70, 80])</span>
<span class="sd">        &gt;&gt;&gt; lc_new.time</span>
<span class="sd">        array([3, 4, 5, 6, 7, 8])</span>
<span class="sd">        &gt;&gt;&gt; # Truncation can also be done by time values</span>
<span class="sd">        &gt;&gt;&gt; lc_new = lc.truncate(start=6, method=&#39;time&#39;)</span>
<span class="sd">        &gt;&gt;&gt; lc_new.time</span>
<span class="sd">        array([6, 7, 8, 9])</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(lc_new.counts, [60, 70, 80, 90])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.split">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.split">[docs]</a>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_gap</span><span class="p">,</span> <span class="n">min_points</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For data with gaps, it can sometimes be useful to be able to split</span>
<span class="sd">        the light curve into separate, evenly sampled objects along those</span>
<span class="sd">        data gaps. This method allows to do this: it finds data gaps of a</span>
<span class="sd">        specified minimum size, and produces a list of new `Lightcurve`</span>
<span class="sd">        objects for each contiguous segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_gap : float</span>
<span class="sd">            The length of a data gap, in the same units as the `time` attribute</span>
<span class="sd">            of the `Lightcurve` object. Any smaller gaps will be ignored, any</span>
<span class="sd">            larger gaps will be identified and used to split the light curve.</span>

<span class="sd">        min_points : int, default 1</span>
<span class="sd">            The minimum number of data points in each light curve. Light</span>
<span class="sd">            curves with fewer data points will be ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc_split : iterable of `Lightcurve` objects</span>
<span class="sd">            The list of all contiguous light curves</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = np.array([1, 2, 3, 6, 7, 8, 11, 12, 13])</span>
<span class="sd">        &gt;&gt;&gt; counts = np.random.rand(time.shape[0])</span>
<span class="sd">        &gt;&gt;&gt; lc = Lightcurve(time, counts, dt=1, skip_checks=True)</span>
<span class="sd">        &gt;&gt;&gt; split_lc = lc.split(1.5)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate the difference between time bins</span>
        <span class="n">tdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="c1"># find all distances between time bins that are larger than `min_gap`</span>
        <span class="n">gap_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tdiff</span> <span class="o">&gt;=</span> <span class="n">min_gap</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># tolerance for the newly created GTIs: Note that this seems to work</span>
        <span class="c1"># with a tolerance of 2, but not if I substitute 10. I don&#39;t know why</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tdiff</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># calculate new GTIs</span>
        <span class="n">gti_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">epsilon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">gap_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">epsilon</span><span class="p">])</span>
        <span class="n">gti_stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">gap_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">])</span>

        <span class="n">gti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">gti_start</span><span class="p">,</span> <span class="n">gti_stop</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;gti&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">gti</span><span class="p">)</span>

        <span class="n">lc_split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_by_gti</span><span class="p">(</span><span class="n">gti</span><span class="p">,</span> <span class="n">min_points</span><span class="o">=</span><span class="n">min_points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lc_split</span></div>


<div class="viewcode-block" id="Lightcurve.sort">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.sort">[docs]</a>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort a Lightcurve object by time.</span>

<span class="sd">        A Lightcurve can be sorted in either increasing or decreasing order</span>
<span class="sd">        using this method. The time array gets sorted and the counts array is</span>
<span class="sd">        changed accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reverse : boolean, default False</span>
<span class="sd">            If True then the object is sorted in reverse order.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current light curve. Otherwise, return a new one.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [2, 1, 3]</span>
<span class="sd">        &gt;&gt;&gt; count = [200, 100, 300]</span>
<span class="sd">        &gt;&gt;&gt; lc = Lightcurve(time, count, dt=1, skip_checks=True)</span>
<span class="sd">        &gt;&gt;&gt; lc_new = lc.sort()</span>
<span class="sd">        &gt;&gt;&gt; lc_new.time</span>
<span class="sd">        array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(lc_new.counts, [100, 200, 300])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc_new: :class:`Lightcurve` object</span>
<span class="sd">            The :class:`Lightcurve` object with sorted time and counts</span>
<span class="sd">            arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.sort_counts">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.sort_counts">[docs]</a>
    <span class="k">def</span> <span class="nf">sort_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort a :class:`Lightcurve` object in accordance with its counts array.</span>

<span class="sd">        A :class:`Lightcurve` can be sorted in either increasing or decreasing order</span>
<span class="sd">        using this method. The counts array gets sorted and the time array is</span>
<span class="sd">        changed accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reverse : boolean, default ``False``</span>
<span class="sd">            If ``True`` then the object is sorted in reverse order.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current light curve. Otherwise, return a new one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc_new: :class:`Lightcurve` object</span>
<span class="sd">            The :class:`Lightcurve` object with sorted ``time`` and ``counts``</span>
<span class="sd">            arrays.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; time = [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; count = [200, 100, 300]</span>
<span class="sd">        &gt;&gt;&gt; lc = Lightcurve(time, count, dt=1, skip_checks=True)</span>
<span class="sd">        &gt;&gt;&gt; lc_new = lc.sort_counts()</span>
<span class="sd">        &gt;&gt;&gt; lc_new.time</span>
<span class="sd">        array([2, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(lc_new.counts, [100, 200, 300])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.estimate_chunk_length">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.estimate_chunk_length">[docs]</a>
    <span class="k">def</span> <span class="nf">estimate_chunk_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated alias of estimate_segment_size.&quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;This function was renamed to estimate_segment_size&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.estimate_segment_size">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.estimate_segment_size">[docs]</a>
    <span class="k">def</span> <span class="nf">estimate_segment_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_counts</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">even_sampling</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate a reasonable segment length for segment-by-segment analysis.</span>

<span class="sd">        The user has to specify a criterion based on a minimum number of counts (if</span>
<span class="sd">        the time series has a ``counts`` attribute) or a minimum number of time samples.</span>
<span class="sd">        At least one between ``min_counts`` and ``min_samples`` must be specified.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        min_counts : int</span>
<span class="sd">            Minimum number of counts for each chunk. Optional (but needs ``min_samples``</span>
<span class="sd">            if left unspecified). Only makes sense if the series has a ``counts`` attribute and</span>
<span class="sd">            it is evenly sampled.</span>
<span class="sd">        min_samples : int</span>
<span class="sd">            Minimum number of time bins. Optional (but needs ``min_counts`` if left unspecified).</span>
<span class="sd">        even_sampling : bool</span>
<span class="sd">            Force the treatment of the data as evenly sampled or not. If None, the data are</span>
<span class="sd">            considered evenly sampled if ``self.dt`` is larger than zero and the median</span>
<span class="sd">            separation between subsequent times is within 1% of ``self.dt``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        segment_size : float</span>
<span class="sd">            The length of the light curve chunks that satisfies the conditions</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; time = np.arange(150)</span>
<span class="sd">        &gt;&gt;&gt; count = np.zeros_like(time) + 3</span>
<span class="sd">        &gt;&gt;&gt; lc = Lightcurve(time, count, dt=1)</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(</span>
<span class="sd">        ...     lc.estimate_segment_size(min_counts=10, min_samples=3), 4)</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(lc.estimate_segment_size(min_counts=10, min_samples=5), 5)</span>
<span class="sd">        &gt;&gt;&gt; count[2:4] = 1</span>
<span class="sd">        &gt;&gt;&gt; lc = Lightcurve(time, count, dt=1)</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(lc.estimate_segment_size(min_counts=3, min_samples=1), 3)</span>
<span class="sd">        &gt;&gt;&gt; # A slightly more complex example</span>
<span class="sd">        &gt;&gt;&gt; dt=0.2</span>
<span class="sd">        &gt;&gt;&gt; time = np.arange(0, 1000, dt)</span>
<span class="sd">        &gt;&gt;&gt; counts = np.random.poisson(100, size=len(time))</span>
<span class="sd">        &gt;&gt;&gt; lc = Lightcurve(time, counts, dt=dt)</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(lc.estimate_segment_size(100, 2), 0.4)</span>
<span class="sd">        &gt;&gt;&gt; min_total_bins = 40</span>
<span class="sd">        &gt;&gt;&gt; assert np.isclose(lc.estimate_segment_size(100, 40), 8.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">estimate_segment_size</span><span class="p">(</span><span class="n">min_counts</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">,</span> <span class="n">even_sampling</span><span class="o">=</span><span class="n">even_sampling</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.analyze_lc_chunks">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.analyze_lc_chunks">[docs]</a>
    <span class="k">def</span> <span class="nf">analyze_lc_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Analyze segments of the light curve with any function.</span>

<span class="sd">        .. deprecated:: 2.0</span>
<span class="sd">            Use :meth:`Lightcurve.analyze_segments(func, segment_size)` instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_size : float</span>
<span class="sd">            Length in seconds of the light curve segments</span>
<span class="sd">        func : function</span>
<span class="sd">            Function accepting a :class:`Lightcurve` object as single argument, plus</span>
<span class="sd">            possible additional keyword arguments, and returning a number or a</span>
<span class="sd">            tuple - e.g., ``(result, error)`` where both ``result`` and ``error`` are</span>
<span class="sd">            numbers.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        fraction_step : float</span>
<span class="sd">            By default, segments do not overlap (``fraction_step`` = 1). If ``fraction_step`` &lt; 1,</span>
<span class="sd">            then the start points of consecutive segments are ``fraction_step * segment_size``</span>
<span class="sd">            apart, and consecutive segments overlap. For example, for ``fraction_step`` = 0.5,</span>
<span class="sd">            the window shifts one half of ``segment_size``)</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            These additional keyword arguments, if present, they will be passed</span>
<span class="sd">            to ``func``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        start_times : array</span>
<span class="sd">            Lower time boundaries of all time segments.</span>
<span class="sd">        stop_times : array</span>
<span class="sd">            upper time boundaries of all segments.</span>
<span class="sd">        result : array of N elements</span>
<span class="sd">            The result of ``func`` for each segment of the light curve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The analyze_lc_chunks method was superseded by analyze_segments&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">analyze_segments</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">fraction_step</span><span class="o">=</span><span class="n">fraction_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.to_lightkurve">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.to_lightkurve">[docs]</a>
    <span class="k">def</span> <span class="nf">to_lightkurve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a `lightkurve.LightCurve` object.</span>
<span class="sd">        This feature requires ``Lightkurve`` to be installed</span>
<span class="sd">        (e.g. ``pip install lightkurve``).  An `ImportError` will</span>
<span class="sd">        be raised if this package is not available.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lightcurve : `lightkurve.LightCurve`</span>
<span class="sd">            A lightkurve LightCurve object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">lightkurve</span> <span class="kn">import</span> <span class="n">LightCurve</span> <span class="k">as</span> <span class="n">lk</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;You need to install Lightkurve to use &quot;</span> <span class="s2">&quot;the Lightcurve.to_lightkurve() method.&quot;</span>
            <span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">/</span> <span class="mi">86400</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;mjd&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s2">&quot;utc&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lk</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="n">flux_err</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">counts_err</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.from_lightkurve">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.from_lightkurve">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_lightkurve</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new `Lightcurve` from a `lightkurve.LightCurve`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lk : `lightkurve.LightCurve`</span>
<span class="sd">            A lightkurve LightCurve object</span>
<span class="sd">        skip_checks: bool</span>
<span class="sd">            If True, the user specifies that data are already sorted and contain no</span>
<span class="sd">            infinite or nan points. Use at your own risk.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Lightcurve</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="n">lk</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">counts</span><span class="o">=</span><span class="n">lk</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span>
            <span class="n">err</span><span class="o">=</span><span class="n">lk</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span>
            <span class="n">input_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">skip_checks</span><span class="o">=</span><span class="n">skip_checks</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.to_astropy_timeseries">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.to_astropy_timeseries">[docs]</a>
    <span class="k">def</span> <span class="nf">to_astropy_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the light curve to an :class:`astropy.timeseries.TimeSeries` object.</span>

<span class="sd">        The time array and all the array attributes become columns. The meta attributes become</span>
<span class="sd">        metadata of the :class:`astropy.timeseries.TimeSeries` object.</span>
<span class="sd">        The time array is saved as a TimeDelta object.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        no_longdouble : bool, default False</span>
<span class="sd">            If True, the data are converted to double precision before being saved.</span>
<span class="sd">            This is useful, e.g., for saving to FITS files, which do not support long double precision.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_astropy_object</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;timeseries&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.to_astropy_table">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.to_astropy_table">[docs]</a>
    <span class="k">def</span> <span class="nf">to_astropy_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the light curve to an :class:`astropy.table.Table` object.</span>

<span class="sd">        The time array and all the array attributes become columns. The meta attributes become</span>
<span class="sd">        metadata of the :class:`astropy.table.Table` object.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        no_longdouble : bool, default False</span>
<span class="sd">            If True, the data are converted to double precision before being saved.</span>
<span class="sd">            This is useful, e.g., for saving to FITS files, which do not support long double precision.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_astropy_object</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_to_astropy_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="n">no_longdouble</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the light curve to an :class:`astropy.table.Table` or :class:`astropy.timeseries.TimeSeries` object.</span>

<span class="sd">        If ``kind`` is ``timeseries``, the time array and all the array attributes become columns.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kind : str, default ``table``</span>
<span class="sd">            The type of object to return. Accepted values are ``table`` or ``timeseries``.</span>
<span class="sd">        no_longdouble : bool, default False</span>
<span class="sd">            If True, the data are converted to double precision before being saved.</span>
<span class="sd">            This is useful, e.g., for saving to FITS files, which do not support long double precision.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s2">&quot;_counts&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_counts_err&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_countrate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_countrate_err&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_bin_lo&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_bin_hi&quot;</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">no_longdouble</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">reduce_precision_if_extended</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">attr</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="n">time_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span>
        <span class="k">if</span> <span class="n">no_longdouble</span><span class="p">:</span>
            <span class="n">time_array</span> <span class="o">=</span> <span class="n">reduce_precision_if_extended</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;table&quot;</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_array</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;timeseries&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">astropy.timeseries</span> <span class="kn">import</span> <span class="n">TimeSeries</span>

            <span class="n">ts</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">TimeDelta</span><span class="p">(</span><span class="n">time_array</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid kind (accepted: table or timeseries)&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s2">&quot;_gti&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mjdref&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_meancounts&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_meancountrate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;instr&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mission&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dt&quot;</span><span class="p">,</span>
            <span class="s2">&quot;err_dist&quot;</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="c1"># Work around issue with Numpy 2.0 and Yaml serializer.</span>
                <span class="k">if</span> <span class="n">rep</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;np.float&quot;</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">no_longdouble</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">reduce_precision_if_extended</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="n">attr</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="k">return</span> <span class="n">ts</span>

<div class="viewcode-block" id="Lightcurve.from_astropy_timeseries">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.from_astropy_timeseries">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_astropy_timeseries</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Lightcurve</span><span class="o">.</span><span class="n">_from_astropy_object</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.from_astropy_table">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.from_astropy_table">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_astropy_table</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Lightcurve</span><span class="o">.</span><span class="n">_from_astropy_object</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_from_astropy_object</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">err_dist</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">time</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">meta</span>
        <span class="n">err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">input_counts</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="s2">&quot;counts_err&quot;</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="s2">&quot;counts_err&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;countrate_err&quot;</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="s2">&quot;countrate_err&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;counts&quot;</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="s2">&quot;counts&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;countrate&quot;</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="s2">&quot;countrate&quot;</span><span class="p">]</span>
            <span class="n">input_counts</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Input timeseries must contain at least a &quot;</span> <span class="s2">&quot;`counts` or a `countrate` column&quot;</span>
            <span class="p">)</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
                <span class="s2">&quot;counts&quot;</span><span class="p">:</span> <span class="n">counts</span><span class="p">,</span>
                <span class="s2">&quot;err&quot;</span><span class="p">:</span> <span class="n">err</span><span class="p">,</span>
                <span class="s2">&quot;input_counts&quot;</span><span class="p">:</span> <span class="n">input_counts</span><span class="p">,</span>
                <span class="s2">&quot;skip_checks&quot;</span><span class="p">:</span> <span class="n">skip_checks</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;err_dist&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;err_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">err_dist</span>

        <span class="n">lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lc</span>

<div class="viewcode-block" id="Lightcurve.plot">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">witherrors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_btis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the light curve using ``matplotlib``.</span>

<span class="sd">        Plot the light curve object on a graph ``self.time`` on x-axis and</span>
<span class="sd">        ``self.counts`` on y-axis with ``self.counts_err`` optionally</span>
<span class="sd">        as error bars.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        witherrors: boolean, default False</span>
<span class="sd">            Whether to plot the Lightcurve with errorbars or not</span>

<span class="sd">        labels : iterable, default ``None``</span>
<span class="sd">            A list of tuple with ``xlabel`` and ``ylabel`` as strings.</span>

<span class="sd">        axis_limits : list, tuple, string, default ``None``</span>
<span class="sd">            Parameter to set axis properties of the ``matplotlib`` figure. For example</span>
<span class="sd">            it can be a list like ``[xmin, xmax, ymin, ymax]`` or any other</span>
<span class="sd">            acceptable argument for the``matplotlib.pyplot.axis()`` method.</span>

<span class="sd">        axis : list, tuple, string, default ``None``</span>
<span class="sd">            Deprecated in favor of ``axis_limits``, same functionality.</span>

<span class="sd">        title : str, default ``None``</span>
<span class="sd">            The title of the plot.</span>

<span class="sd">        marker : str, default &#39;-&#39;</span>
<span class="sd">            Line style and color of the plot. Line styles and colors are</span>
<span class="sd">            combined in a single format string, as in ``&#39;bo&#39;`` for blue</span>
<span class="sd">            circles. See ``matplotlib.pyplot.plot`` for more options.</span>

<span class="sd">        save : boolean, optional, default ``False``</span>
<span class="sd">            If ``True``, save the figure with specified filename.</span>

<span class="sd">        filename : str</span>
<span class="sd">            File name of the image to save. Depends on the boolean ``save``.</span>

<span class="sd">        ax : ``matplotlib.pyplot.axis`` object</span>
<span class="sd">            Axis to be used for plotting. Defaults to creating a new one.</span>

<span class="sd">        plot_btis : bool</span>
<span class="sd">            Plot the bad time intervals as red areas on the plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The ``axis`` argument is deprecated in favor of ``axis_limits``. &quot;</span>
                <span class="s2">&quot;Please use that instead.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">axis_limits</span> <span class="o">=</span> <span class="n">axis</span>

        <span class="n">flux_attr</span> <span class="o">=</span> <span class="s2">&quot;counts&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_counts</span><span class="p">:</span>
            <span class="n">flux_attr</span> <span class="o">=</span> <span class="s2">&quot;countrate&quot;</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">flux_attr</span><span class="p">,</span>
            <span class="n">witherrors</span><span class="o">=</span><span class="n">witherrors</span><span class="p">,</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
            <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">,</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">plot_btis</span><span class="o">=</span><span class="n">plot_btis</span><span class="p">,</span>
            <span class="n">axis_limits</span><span class="o">=</span><span class="n">axis_limits</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.read">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.read">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">format_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">err_dist</span><span class="o">=</span><span class="s2">&quot;gauss&quot;</span><span class="p">,</span> <span class="n">skip_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">fits_kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a :class:`Lightcurve` object from file.</span>

<span class="sd">        Currently supported formats are</span>

<span class="sd">        * pickle (not recommended for long-term storage)</span>
<span class="sd">        * hea : FITS Light curves from HEASARC-supported missions.</span>
<span class="sd">        * any other formats compatible with the writers in</span>
<span class="sd">          :class:`astropy.table.Table` (ascii.ecsv, hdf5, etc.)</span>

<span class="sd">        Files that need the :class:`astropy.table.Table` interface MUST contain</span>
<span class="sd">        at least a ``time`` column and a ``counts`` or ``countrate`` column.</span>
<span class="sd">        The default ascii format is enhanced CSV (ECSV). Data formats</span>
<span class="sd">        supporting the serialization of metadata (such as ECSV and HDF5) can</span>
<span class="sd">        contain all lightcurve attributes such as ``dt``, ``gti``, etc with</span>
<span class="sd">        no significant loss of information. Other file formats might lose part</span>
<span class="sd">        of the metadata, so must be used with care.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename: str</span>
<span class="sd">            Path and file name for the file to be read.</span>

<span class="sd">        fmt: str</span>
<span class="sd">            Available options are &#39;pickle&#39;, &#39;hea&#39;, and any `Table`-supported</span>
<span class="sd">            format such as &#39;hdf5&#39;, &#39;ascii.ecsv&#39;, etc.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>

<span class="sd">        err_dist: str, default=&#39;gauss&#39;</span>
<span class="sd">            Default error distribution if not specified in the file (e.g. for</span>
<span class="sd">            ASCII files). The default is &#39;gauss&#39; just because it is likely</span>
<span class="sd">            that people using ASCII light curves will want to specify Gaussian</span>
<span class="sd">            error bars, if any.</span>
<span class="sd">        skip_checks : bool</span>
<span class="sd">            See :class:`Lightcurve` documentation</span>
<span class="sd">        **fits_kwargs : additional keyword arguments</span>
<span class="sd">            Any other arguments to be passed to `lcurve_from_fits` (only relevant</span>
<span class="sd">            for hea/ogip formats)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc : :class:`Lightcurve` object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;hea&quot;</span><span class="p">,</span> <span class="s2">&quot;ogip&quot;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">lcurve_from_fits</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">fits_kwargs</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;err_dist&quot;</span><span class="p">:</span> <span class="n">err_dist</span><span class="p">,</span> <span class="s2">&quot;skip_checks&quot;</span><span class="p">:</span> <span class="n">skip_checks</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lightcurve.apply_gtis">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.apply_gtis">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_gtis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply GTIs to a light curve. Filters the ``time``, ``counts``,</span>
<span class="sd">        ``countrate``, ``counts_err`` and ``countrate_err`` arrays for all bins</span>
<span class="sd">        that fall into Good Time Intervals and recalculates mean countrate</span>
<span class="sd">        and the number of bins.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, overwrite the current light curve. Otherwise, return a new one.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span>

        <span class="n">good</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">newlc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">good</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">newlc</span><span class="o">.</span><span class="n">dt</span>
        <span class="k">if</span> <span class="s2">&quot;dt&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_attrs</span><span class="p">():</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">newlc</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">newlc</span><span class="o">.</span><span class="n">tstart</span> <span class="o">=</span> <span class="n">newlc</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">newlc</span><span class="o">.</span><span class="n">tseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">newlc</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">newlc</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newlc</span></div>


<div class="viewcode-block" id="Lightcurve.bexvar">
<a class="viewcode-back" href="../../api.html#stingray.Lightcurve.bexvar">[docs]</a>
    <span class="k">def</span> <span class="nf">bexvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds posterior samples of Bayesian excess variance (bexvar) for the light curve.</span>
<span class="sd">        It requires source counts in ``counts`` and time intervals for each bin.</span>
<span class="sd">        If the ``dt`` is an array then uses its elements as time intervals</span>
<span class="sd">        for each bin. If ``dt`` is float, it calculates the time intervals by assuming</span>
<span class="sd">        all intervals to be equal to ``dt``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc_bexvar : iterable, `:class:numpy.array` of floats</span>
<span class="sd">            An array of posterior samples of Bayesian excess variance (bexvar).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate time intervals for each bin if not provided by user</span>
        <span class="c1"># assumes that time intervals in each bin are equal to ``dt``</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">time_del</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_del</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>

        <span class="n">lc_bexvar</span> <span class="o">=</span> <span class="n">bexvar</span><span class="o">.</span><span class="n">bexvar</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">,</span>
            <span class="n">time_del</span><span class="o">=</span><span class="n">time_del</span><span class="p">,</span>
            <span class="n">src_counts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span>
            <span class="n">bg_counts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bg_counts</span><span class="p">,</span>
            <span class="n">bg_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bg_ratio</span><span class="p">,</span>
            <span class="n">frac_exp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_exp</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">lc_bexvar</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, [{&#39;name&#39;: &#39;Stingray Developers&#39;, &#39;email&#39;: &#39;spectraltiming-stingray@googlegroups.com&#39;}].<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 8.0.2. &nbsp;
    Last built 09 Oct 2024. <br/>
  </p>
</footer>
  </body>
</html>